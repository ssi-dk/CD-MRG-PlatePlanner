{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Easy Plate Layouts for LC-MS Studies and Beyond","text":"<p>PlatePlanner is a Python package designed to simplify plate layout creation for LC-MS studies, and is also applicable for various laboratory applications where sample distribution to plates is required, with or without QC sample patterns. Its user-friendly API supports dynamic QC sample patterns, easy creation of run lists, and plate visualizations.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Dynamic QC Sample Patterns: Create plate layouts with customizable QC sample patterns.</li> <li>Flexible Sample Distribution: Distribute samples within groups across plates, accommodating variable numbers of samples per group.</li> <li>Non-Split/Split Group Handling: Control over distributing samples within groups without splitting them over plates or splitting when necessary.</li> <li>Customizable Run Lists &amp; Plate Visualizations: Generate run lists and visualize plate assignments.</li> <li>Block Randomization: Perform sample randomizaition or sample block randomization to prevent run order bias.</li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plate-planner\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Here's a quick guide to using PlatePlanner:</p> <pre><code>from plate-planner import Study, QCPlate\n\n# Create a study and load your file with sample records (csv, xls/xlsx)\nstudy_with_qc = Study(name=\"cancer\")\nstudy_with_qc.load_specimen_records(\n    records_file=\"./data/study_samples.csv\",\n    sample_group_id_column=\"pair_ID\",\n    sample_id_column=\"specimen_ID\"\n)\n\n# Block randomize groups\nstudy_with_qc.randomize_order(case_control=True, reproducible=False)\n\n# Distribute samples to a 96-well plate with QC samples as defined in the toml file\nqc_plate = QCPlate(plate_dim=(8, 12), QC_config=\"./data/plate_config_dynamic.toml\")\nstudy_with_qc.distribute_samples_to_plates(plate_layout=qc_plate)\n\n# Create visualization for plate 3\nfig = study_with_qc[2].as_figure(\n    color_metadata_key=\"organ\",\n    annotation_metadata_key=\"date_of_birth\",\n    rotation=45,\n    )\n\n#mshow distribution of sample attribute across all plates\nfig = study_with_qc.plot_attribute_plate_distributions(attribute=\"organ\", normalize=True, plt_style=\"fivethirtyeight\")\n</code></pre>"},{"location":"#visualization-examples","title":"Visualization Examples","text":"<p>Here are some examples of plate visualizations created using PlatePlanner:</p> <p></p> <p></p>"},{"location":"plate/","title":"Plate Documentation","text":""},{"location":"plate/#src.plate_planner.plate.Plate","title":"<code>Plate</code>","text":"<p>A class to represent a multiwell plate.</p> <p>This class manages a multiwell plate, with functionalities to access, modify, and visualize the wells, along with their metadata.</p> <p>Attributes:</p> Name Type Description <code>_default_n_rows</code> <code>int</code> <p>Default number of rows in the plate.</p> <code>_default_n_columns</code> <code>int</code> <p>Default number of columns in the plate.</p> <code>_default_well_color</code> <code>Tuple[float, float, float]</code> <p>Default RGB color of the wells.</p> <code>_default_exclude_metadata</code> <code>list</code> <p>Default metadata keys to exclude.</p> <code>_default_colormap</code> <code>str</code> <p>Default colormap for visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>plate_dim</code> <code>Tuple[int, int]</code> <p>The dimensions of the plate as (rows, columns).</p> <code>None</code> <code>plate_id</code> <code>int</code> <p>A unique identifier for the plate.</p> <code>1</code> Source code in <code>src/plate_planner/plate.py</code> <pre><code>class Plate:\n    \"\"\"\n    A class to represent a multiwell plate.\n\n    This class manages a multiwell plate, with functionalities to access, modify, and visualize\n    the wells, along with their metadata.\n\n    Attributes:\n        _default_n_rows (int): Default number of rows in the plate.\n        _default_n_columns (int): Default number of columns in the plate.\n        _default_well_color (Tuple[float, float, float]): Default RGB color of the wells.\n        _default_exclude_metadata (list): Default metadata keys to exclude.\n        _default_colormap (str): Default colormap for visualizations.\n\n    Parameters:\n        plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n        plate_id (int, optional): A unique identifier for the plate.\n\n    \"\"\"\n\n    _default_n_rows: int = 8\n    _default_n_columns: int = 12\n    _default_well_color: Tuple[float, float, float] = (1, 1, 1)\n    _default_exclude_metadata = [\"rgb_color\", \"coordinate\"]\n    _default_colormap: str = \"tab20\"\n\n    def __init__(self, plate_dim: Union[Tuple[int, int], List[int], Dict[str, int], int] = None, plate_id: int = 1):\n        \"\"\"\n        Initialize a new Plate instance.\n\n        Args:\n            plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n                If None, default dimensions are used.\n            plate_id (int, optional): A unique identifier for the plate.\n\n        The constructor initializes the plate with the specified dimensions, generating wells \n        with default properties and assigning them unique coordinates and identifiers.\n\n        Examples:\n            Creating a Plate instance with default dimensions and a specific plate ID:\n\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; plate.size\n            96\n\n            &gt;&gt;&gt; plate = Plate(plate_dim=(16, 24))\n            &gt;&gt;&gt; plate.size\n            384\n\n        \"\"\"\n\n        self._n_rows, self._n_columns = self._parse_plate_dimensions(plate_dim)\n\n        self._rows = list(range(self._n_rows))\n        self._columns = list(range(self._n_columns))\n\n        self._alphanumerical_coordinates = self.create_alphanumerical_coordinates(self._rows, self._columns)\n        self._coordinates = self.create_index_coordinates(self._rows, self._columns)\n\n        self.size = self._n_rows * self._n_columns\n\n        self.wells = [Well(name=self._alphanumerical_coordinates[index], \n                           coordinate=(row, col), \n                           index=index, \n                           plate_id=plate_id, \n                           rgb_color=self._default_well_color)\n                      for index, (row, col) in enumerate(itertools.product(self._rows[::-1], self._columns))]\n\n        self.plate_id = plate_id\n\n        # dictionary to map well names to indices\n        self._name_to_index_map = {well.name: well.index for well in self.wells}\n        self._index_to_coordinates_map = {well.index: well.coordinate for well in self.wells}\n        self._index_to_name_map = {well.index: well.name for well in self.wells}\n\n        logger.info(f\"Created a {self._n_rows}x{self._n_columns} plate with {self.size} wells.\")\n\n    def __iter__(self):\n        \"\"\"\n        Return an iterator over the wells of the plate.\n\n        This allows direct iteration over the plate object itself.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; [well.name for well in plate]\n            ['A1', 'A2', 'B1', 'B2']\n        \"\"\"\n        return iter(self.wells)\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of wells in the plate.\n\n        Returns:\n            int: The number of wells.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; len(plate)\n            96\n        \"\"\"\n        return len(self.wells)\n\n    def __str__(self):\n        plate_summary = f\"Plate ID: {self.plate_id}\\n\"\n        plate_summary += f\"Dimensions: {self._n_rows} rows x {self._n_columns} columns\\n\"\n        plate_summary += \"Plate Layout (Well Names):\\n\"\n        plate_array_str = np.array_str(self.get_metadata_as_numpy_array(\"name\"))\n        plate_summary += plate_array_str\n        return plate_summary\n\n    def __getitem__(self, key: Union[int, Tuple[int,int], str]):\n        \"\"\"\n        Retrieve a well from the plate based on its index, coordinate, or name.\n\n        Args:\n            key (int, tuple, or str): The identifier for the well. Can be an integer index, \n            a tuple indicating row and column coordinates, or a string specifying the well's name.\n\n        Returns:\n            Well: The well object corresponding to the given key.\n\n        Raises:\n            TypeError: If the key is not an integer, tuple, or string.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; plate[0].name\n            'A1'\n            &gt;&gt;&gt; plate[(0, 0)].name\n            'A1'\n            &gt;&gt;&gt; plate[\"A1\"].name\n            'A1'\n        \"\"\"\n        if isinstance(key, int):\n            # Access by index\n            return self.wells[key]\n        elif isinstance(key, tuple):\n            # Access by coordinate\n            index = self._coordinates_to_index(key)\n            return self.wells[index]\n        elif isinstance(key, str):\n            # Access by name\n            index = self._name_to_index_map[key]\n            return self.wells[index]\n        else:\n            raise TypeError(\"Key must be an integer, tuple, or string\")\n\n    def __setitem__(self, key, well_object: Well):\n        \"\"\"\n        Set or replace a well in the plate based on its index, coordinate, or name.\n\n        Args:\n            key (int, tuple, or str): The identifier for the well to be set or replaced. \n                Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.\n        well_object (Well): The well object to set at the specified key.\n\n        Raises:\n            ValueError: If the well_object is not an instance of Well.\n            IndexError: If the well index is out of range.\n            TypeError: If the key is not a string, integer, or tuple.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))  # Create a small 2x2 plate for simplicity\n            &gt;&gt;&gt; new_well = Well(name=\"C3\", plate_id=1, coordinate=(0, 1), metadata={\"study_group\": \"control\"})  # Define a new well\n            &gt;&gt;&gt; plate[0] = new_well  # Set this well at the first position\n            &gt;&gt;&gt; plate[0].name\n            'A1'\n            &gt;&gt;&gt; plate[0].metadata[\"study_group\"]\n            'control'\n        \"\"\"\n        if not isinstance(well_object, Well):\n            raise ValueError(\"Value must be an instance of Well\")\n\n        if isinstance(key, str):\n            index = self._name_to_index_map[key]\n            coordinate = self._index_to_coordinates_map[index]\n            name = key\n        elif isinstance(key, int):\n            if key &lt; 0 or key &gt;= len(self.wells):\n                raise IndexError(\"Well index out of range\")\n            index = key\n            coordinate = self._index_to_coordinates_map[index]\n            name = self.wells[index].name\n        elif isinstance(key, tuple):\n            index = self._coordinates_to_index(key)\n            coordinate = key\n            name = self._index_to_name_map(index)\n        else:\n            raise TypeError(\"Key must be a string, integer, or tuple\")\n\n        # Update the well object's attributes\n        well_object.name = name\n        well_object.coordinate = coordinate\n        well_object.index = index\n        well_object.plate_id = self.plate_id\n\n        # Update the well at the specified index on the plate\n        self.wells[index] = well_object\n        # Update the name-to-index mapping\n        self._name_to_index_map[name] = index\n\n    def __add__(self, other: \"Plate\") -&gt; \"Plate\":\n        \"\"\"\n        Combine the content of this Plate with another Plate.\n\n        The wells of both plates are combined. If wells at the same coordinates \n        exist in both plates, their metadata is merged.\n\n        Args:\n            other (Plate): Another Plate to combine with.\n\n        Returns:\n            Plate: A new Plate with combined content from both plates.\n\n        Raises:\n            ValueError: If the dimensions of the two plates do not match.\n\n        Example:\n            &gt;&gt;&gt; plate1 = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; plate1.wells[0].metadata = {'sample': 'A'}\n            &gt;&gt;&gt; plate2 = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; plate2.wells[0].metadata = {'volume': 100}\n            &gt;&gt;&gt; combined_plate = plate1 + plate2\n            &gt;&gt;&gt; combined_plate.wells[0].metadata\n            {'sample': 'A', 'volume': 100}\n        \"\"\"\n        if (self._n_rows, self._n_columns) != (other._n_rows, other._n_columns):\n            raise ValueError(\"Cannot add plates of different dimensions\")\n\n        # Create a new Plate for the combined content\n        new_plate = Plate(plate_dim=(self._n_rows, self._n_columns))\n\n        # Iterate through wells and combine metadata\n        for (well_self, well_other) in zip(self.wells, other.wells):\n            combined_metadata = {**well_self.metadata, **well_other.metadata}\n            new_well = Well(name=well_self.name, plate_id=new_plate.plate_id,\n                            coordinate=well_self.coordinate, index=well_self.index,\n                            rgb_color=well_self.rgb_color, metadata=combined_metadata)\n            new_plate.wells[well_self.index] = new_well\n\n        return new_plate\n\n    def _parse_plate_dimensions(self, plate_dim: Union[Tuple[int, int], List[int], Dict[str, int], int]) -&gt; Tuple[int, int]:\n        \"\"\"\n        Parse the dimensions of the plate and return the number of rows and columns. This method can handle various \n        formats for specifying the dimensions: as a tuple or list (rows, columns), as a dictionary with 'rows' and \n        'columns' keys, or as an integer representing the total number of wells in a plate. For integer inputs, \n        the method attempts to design a plate with a 2:3 aspect ratio (height to width).\n\n        Args:\n            plate_dim (tuple, list, dict, or int): The dimensions of the plate. This can be a tuple or list specifying \n                (rows, columns), a dictionary with 'rows' and 'columns' keys, or an integer specifying the total number \n                of wells, which the method will attempt to fit into a plate with a 2:3 aspect ratio.\n\n        Returns:\n            tuple: A tuple containing the number of rows and columns (rows, columns). The method ensures that the \n                resulting plate size can accommodate at least the specified number of wells while trying to maintain \n                the aspect ratio as close to 2:3 as possible.\n\n        Raises:\n            ValueError: If the plate_dim format is unsupported or incorrect, or if the number of wells specified by \n                an integer cannot be reasonably fitted into a 2:3 aspect ratio plate.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; plate._parse_plate_dimensions((3, 5))\n            (3, 5)\n            &gt;&gt;&gt; plate._parse_plate_dimensions([4, 6])\n            [4, 6]\n            &gt;&gt;&gt; plate._parse_plate_dimensions({\"rows\": 2, \"columns\": 8})\n            (2, 8)\n            &gt;&gt;&gt; plate._parse_plate_dimensions(24)  # Assuming 2:3 aspect ratio\n            (4, 6)\n        \"\"\"\n        if plate_dim is None:\n            return self._default_n_rows, self._default_n_columns\n\n        if isinstance(plate_dim, (tuple, list)):\n            if len(plate_dim) == 2:\n                return plate_dim\n            else:\n                raise ValueError(\"Plate dimension must be a tuple or list with two elements (rows, columns).\")\n\n        if isinstance(plate_dim, dict):\n            return plate_dim.get(\"rows\", self._default_n_rows), plate_dim.get(\"columns\", self._default_n_columns)\n\n        if isinstance(plate_dim, int):\n            # Calculate the ideal dimensions for a plate with a 2:3 aspect ratio\n            aspect_ratio_width = 3\n            aspect_ratio_height = 2\n\n            ideal_height = np.sqrt(plate_dim / (aspect_ratio_width * aspect_ratio_height / aspect_ratio_height**2))\n            ideal_width = (aspect_ratio_width / aspect_ratio_height) * ideal_height\n\n            # Round the dimensions and adjust if necessary to accommodate all elements\n            rows = int(np.round(ideal_height))\n            columns = int(np.round(ideal_width))\n\n            while rows * columns &lt; plate_dim:\n                if (rows + 1) * columns &lt;= plate_dim:\n                    rows += 1\n                elif rows * (columns + 1) &lt;= plate_dim:\n                    columns += 1\n                else:\n                    rows += 1\n                    columns += 1\n\n            return rows, columns\n\n        raise ValueError(\"Unsupported plate format: Must be a tuple, list, dict, or integer.\")\n\n    def _coordinates_to_index(self, coordinate: tuple):\n        \"\"\"\n        Convert a well coordinate to its corresponding index in the plate's well list.\n\n        Args:\n            coordinate (tuple): The row and column coordinate of the well (row, col).\n\n        Returns:\n            int: The index of the well corresponding to the given coordinate.\n\n        Raises:\n            IndexError: If the coordinate is out of range of the plate's dimensions.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(3, 4))  # A 3x4 plate\n            &gt;&gt;&gt; plate._coordinates_to_index((0, 0))\n            0\n            &gt;&gt;&gt; plate._coordinates_to_index((2, 3))\n            11\n            &gt;&gt;&gt; plate._coordinates_to_index((3, 0))  # This should raise an IndexError\n            Traceback (most recent call last):\n            ...\n            IndexError: Coordinate out of range\n        \"\"\"\n        row, col = coordinate\n        if row &lt; 0 or row &gt;= self._n_rows or col &lt; 0 or col &gt;= self._n_columns:\n            raise IndexError(\"Coordinate out of range\")\n        return row * self._n_columns + col\n\n    def _to_numpy_array(self, data: list) -&gt; np.ndarray:\n        \"\"\"\n        Convert a list of data corresponding to each well into a numpy array matching the plate's layout.\n\n        Args:\n            data (list): A list of data values corresponding to each well in the plate.\n\n        Returns:\n            numpy.ndarray: A numpy array representing the plate's layout with the provided data.\n\n        Raises:\n            Warning: If the number of data elements does not match the plate's size.\n\n        Example:\n            # Using a Plate with 4 wells (2x2) for demonstration\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; data = [1, 2, 3, 4]  # Sample data corresponding to each well\n            &gt;&gt;&gt; array = plate._to_numpy_array(data)\n            &gt;&gt;&gt; array.shape\n            (2, 2)\n            &gt;&gt;&gt; array[0, 1]  # Check the value in the first well (after flipping)\n            2\n            &gt;&gt;&gt; array[1, 0]  # Check the value in the last well (after flipping)\n            3\n        \"\"\"\n        # Create an empty array of the right shape\n        plate_array = np.empty((self._n_rows, self._n_columns), dtype=object)\n\n        # Check if the data list matches the number of wells\n        if len(data) != self.size:\n            raise Warning(f\"Number of data elements ({len(data)}) does not match the plate's size ({self.size}).\")\n\n        # Populate the array with data\n        for i, (row, col) in enumerate(self._coordinates):\n            plate_array[row, col] = data[i]\n\n        return np.flipud(plate_array)  # Flip to match the physical layout\n\n    def get_metadata(self, metadata_key: Optional[str]) -&gt; list:\n        \"\"\"\n        Retrieve metadata values for all wells in the plate based on the specified key.\n\n        Args:\n            metadata_key (str, optional): The metadata key for which values are to be retrieved. \n                If None, a default value of 'NaN' is returned for each well.\n\n        Returns:\n            list: A list of metadata values for each well in the plate.\n\n        Example:\n            # Using a Plate with 4 wells and adding metadata for demonstration\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; for well in plate.wells:\n            ...     well.metadata['sample_type'] = 'RNA'\n            &gt;&gt;&gt; plate.get_metadata('sample_type')\n            ['RNA', 'RNA', 'RNA', 'RNA']\n            &gt;&gt;&gt; plate.get_metadata('non_existing_key')  # Key not present\n            ['NaN', 'NaN', 'NaN', 'NaN']\n        \"\"\"\n        if metadata_key is None:\n            return [\"NaN\" for _ in self.wells]\n\n        metadata_values = []\n        for well in self.wells:\n            value = well.get_attribute_or_metadata(metadata_key)\n            metadata_values.append(value)\n\n        return metadata_values\n\n    def get_metadata_as_numpy_array(self, metadata_key : str) -&gt; object:\n        \"\"\"\n        Retrieve metadata values for all wells in a numpy array format based on the specified key.\n\n        Args:\n            metadata_key (str): The metadata key for which values are to be retrieved.\n\n        Returns:\n            numpy.ndarray: A numpy array representing the metadata values for the plate's layout.\n\n         Example:\n            # Using a Plate with 4 wells and adding metadata for demonstration\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; for well in plate.wells:\n            ...     well.metadata['concentration'] = 10.0\n            &gt;&gt;&gt; array = plate.get_metadata_as_numpy_array('concentration')\n            &gt;&gt;&gt; array.shape\n            (2, 2)\n            &gt;&gt;&gt; array[0, 0]  # Value in the first well\n            10.0\n        \"\"\"\n        metadata = self.get_metadata(metadata_key)\n\n        return self._to_numpy_array(metadata)\n\n\n    def _assign_well_color(self, metadata_key: Optional[str], colormap: str) -&gt; None:\n        \"\"\"\n        Assign colors to each well in the plate based on the specified metadata key and colormap.\n\n        Args:\n            metadata_key (str, optional): The metadata key to use for coloring the wells. \n                If None, a default color is assigned to each well.\n        colormap (str): The name of the colormap to use for coloring the wells.\n\n        Raises:\n            ValueError: If the metadata_key is invalid or not found.\n        \"\"\"\n\n        def is_qualitative_colormap(colormap_name):\n            \"\"\"Check if a given colormap is qualitative.\"\"\"\n            # This list can be expanded with more qualitative colormaps\n            qualitative_colormaps = ['Pastel1', 'Pastel2', 'Paired', 'Accent', 'Dark2', \n                                    'Set1', 'Set2', 'Set3', 'tab10', 'tab20', 'tab20b', 'tab20c']\n            return colormap_name in qualitative_colormaps\n\n        if colormap is None:\n            colormap = self._default_colormap\n\n        self._metadata_color_map = {}\n\n        if metadata_key is not None:\n\n            metadata_values = self.get_metadata(metadata_key)\n            unique_values = list(set(metadata_values))\n\n            cmap = plt.get_cmap(colormap)\n\n            if is_qualitative_colormap(colormap):\n                # Use colors directly for qualitative colormaps\n                colors = cmap.colors\n                for i, value in enumerate(unique_values):\n                    if value is None or value == \"NaN\":\n                        self._metadata_color_map[value] = self._default_well_color\n                    else:\n                        color_index = i % len(colors)\n                        self._metadata_color_map[value] = colors[color_index][0:3]  # RGB color\n            else:\n                # Use scaling for non-qualitative colormaps\n                color_norm = mcolors.Normalize(vmin=0, vmax=len(unique_values) - 1)\n                scalar_map = cm.ScalarMappable(norm=color_norm, cmap=cmap)\n\n                for i, value in enumerate(unique_values):\n                    if value is None or value == \"NaN\":\n                        self._metadata_color_map[value] = self._default_well_color\n                    else:\n                        self._metadata_color_map[value] = scalar_map.to_rgba(i)[0:3]  # RGB color\n\n            for well in self.wells:\n                metadata_value = well.get_attribute_or_metadata(metadata_key)\n                well.rgb_color = self._metadata_color_map.get(metadata_value, self._default_well_color)\n        else:\n            # Assign default color when metadata_key is None\n            for well in self.wells:\n                well.rgb_color = self._default_well_color\n\n    def as_records(self):\n        \"\"\"\n        Convert the plate's well data into a list of dictionaries.\n\n        Each well's attributes are converted into a dictionary, and all these dictionaries\n        are compiled into a list, with one dictionary per well.\n\n        Returns:\n            list of dict: A list where each element is a dictionary representing a well's attributes.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(1, 2))\n            &gt;&gt;&gt; plate[0].metadata[\"sample_type\"] = \"plasma\" # set metadata for first well\n            &gt;&gt;&gt; records = plate.as_records()\n            &gt;&gt;&gt; len(records)  # Number of wells in the plate\n            2\n            &gt;&gt;&gt; sorted(records[0].keys())  # Show the keys of the first well's dictionary\n            ['coordinate', 'empty', 'index', 'name', 'plate_id', 'rgb_color', 'sample_type']\n        \"\"\"\n        return [well.as_dict() for well in self]\n\n    def as_dataframe(self):\n        \"\"\"\n        Converts the plate data into a Pandas DataFrame.\n\n        Each well and its attributes are represented as a row in the DataFrame.\n\n        Returns:\n            pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.\n\n        Example:\n        &gt;&gt;&gt; plate = Plate()\n        &gt;&gt;&gt; df = plate.as_dataframe()\n        &gt;&gt;&gt; len(df)\n        96\n        \"\"\"\n        return pd.DataFrame(self.as_records())\n\n    def is_valid_metadata_key(self, key:str) -&gt; bool:\n        \"\"\"\n        Check if the provided key is a valid metadata key for the Well instances in the plate.\n\n        This method verifies whether the specified key is either a direct attribute of the Well instances\n        or a key within their metadata dictionary.\n\n        Args:\n            key (str): The key to check for validity as a metadata key.\n\n        Returns:\n            bool: True if the key is a valid metadata key, False otherwise.\n        \"\"\"\n        if not key:  # If key is None or empty\n            return False\n\n        # Check if the key is a direct attribute or in the metadata dictionary of any well\n        for well in self.wells:\n            if hasattr(well, key) or key in well.metadata:\n                return True\n\n        return False\n\n    def as_figure(self, annotation_metadata_key=None, \n                  color_metadata_key=None,\n                  fontsize=8,\n                  rotation=0,\n                  step=10,\n                  title_str=None,\n                  title_fontsize=14,\n                  alpha=0.7,\n                  well_size=1200,\n                  fig_width=11.69,\n                  fig_height=8.27,\n                  dpi=100,\n                  plt_style=\"fivethirtyeight\",\n                  grid_color=(1, 1, 1),\n                  edge_color=(0.5, 0.5, 0.5),\n                  legend_bb=(0.15, -0.15, 0.7, 1.3),\n                  legend_n_columns=6,\n                  colormap=\"tab10\",\n                  show_grid=True,\n                  show_frame=True\n                  ) -&gt; 'matplotlib.figure.Figure':\n        \"\"\"\n        Create a visual representation of the plate using matplotlib.\n\n        This method generates a figure representing the plate, with options for annotations,\n        coloring based on metadata, and various styling adjustments.\n\n        Args:\n            annotation_metadata_key (str, optional): Metadata key to use for annotating wells.\n            color_metadata_key (str, optional): Metadata key to determine the color of wells.\n            fontsize (int, optional): Font size for annotations. Default is 8.\n            rotation (int, optional): Rotation angle for annotations. Default is 0.\n            step (int, optional): Step size between wells in the grid. Default is 10.\n            title_str (str, optional): Title of the figure. If None, a default title is used.\n            title_fontsize (str, optional): Font size for title.\n            alpha (float, optional): Alpha value for well colors. Default is 0.7.\n            well_size (int, optional): Size of the wells in the figure. Default is 1200.\n            fig_width (float, optional): Width of the figure. Default is 11.69.\n            fig_height (float, optional): Height of the figure. Default is 8.27.\n            dpi (int, optional): Dots per inch for the figure. Default is 100.\n            plt_style (str, optional): Matplotlib style to use. Default is 'bmh'.\n            grid_color (tuple, optional): Color for the grid. Default is (1, 1, 1).\n            edge_color (tuple, optional): Color for the edges of wells. Default is (0.5, 0.5, 0.5).\n            legend_bb (tuple, optional): Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).\n            legend_n_columns (int, optional): Number of columns in the legend. Default is 6.\n            colormap (str, optional): Colormap name for coloring wells. Uses default colormap if None.\n            show_grid (bool, optional): If True, displays a grid anchored at the well centers; default is True.\n            show_grid (bool, optional): If True, plot a rectangle to frame the wells; default is True.\n\n        Returns:\n            matplotlib.figure.Figure: A figure object representing the plate.\n\n        Raises:\n            ValueError: If provided metadata keys are not valid.\n        \"\"\"\n        colormap = colormap if colormap else self._default_colormap\n\n        # Validate metadata keys\n        if color_metadata_key and not self.is_valid_metadata_key(color_metadata_key):\n            raise ValueError(f\"Invalid color_metadata_key: {color_metadata_key}\")\n        if annotation_metadata_key and not self.is_valid_metadata_key(annotation_metadata_key):\n            raise ValueError(f\"Invalid annotation_metadata_key: {annotation_metadata_key}\")\n\n        # Define title\n        if not title_str:\n            title_str = f\"Plate {self.plate_id}\"\n            if annotation_metadata_key or color_metadata_key:\n                title_str += f\", showing {annotation_metadata_key or ''} colored by {color_metadata_key or ''}\"\n\n        # Assign colors to wells\n        self._assign_well_color(color_metadata_key, colormap)\n\n        # Prepare grid and data for plotting\n        minX, maxX, minY, maxY = 0, len(self._columns)*step, 0, len(self._rows)*step\n        x = np.arange(minX, maxX, step)\n        y = np.arange(minY, maxY, step)\n\n        # Generate grid with columns first (column-major format)\n        Xgrid, Ygrid = np.meshgrid(x, y)\n\n        size_grid = np.ones_like(Xgrid) * well_size\n\n        well_colors = np.ravel((self.get_metadata_as_numpy_array(\"rgb_color\")[::-1]))\n\n        # Plot setup\n        plt.style.use(plt_style)\n        fig = plt.figure(facecolor='white', figsize=(fig_width, fig_height), dpi=dpi,)\n        ax = fig.add_subplot(111, facecolor='white')\n        # fig, ax = plt.subplots(figsize=(fig_width, fig_height), dpi=dpi, facecolor=\"white\")\n        # Remove the axis lines\n        ax.spines['top'].set_visible(False)\n        ax.spines['bottom'].set_visible(False)\n        ax.spines['left'].set_visible(False)\n        ax.spines['right'].set_visible(False)\n\n        ax.scatter(Xgrid, Ygrid, s=size_grid, c=well_colors, alpha=alpha, edgecolors=edge_color)\n\n        # Annotations\n        if annotation_metadata_key:\n            for well in self:\n                x_i = Xgrid[well.coordinate]\n                y_i = Ygrid[well.coordinate]\n                annotation_label = well.get_attribute_or_metadata(annotation_metadata_key)\n                ax.annotate(annotation_label, (x_i, y_i), ha='center', va='center', rotation=rotation, fontsize=fontsize, bbox=dict(facecolor='white', alpha=0.5, boxstyle=\"round,pad=0.25,rounding_size=0.5\"))\n\n        # Legends\n        if color_metadata_key:\n            # Get unique categories and their corresponding colors\n            legend_marker_size = np.sqrt(well_size) * 0.5\n            unique_categories = set(self.get_metadata(color_metadata_key))\n            legend_handles = [plt.Line2D([0], [0], marker='o', color=self._metadata_color_map.get(category, self._default_well_color), alpha=alpha, label=category, markersize=legend_marker_size, linestyle='None') \n                            for category in unique_categories]\n\n            ax.legend(handles=legend_handles, bbox_to_anchor=legend_bb, loc='lower center', frameon=False, labelspacing=1, ncol=legend_n_columns)\n\n        # Axis settings\n        # Move x-axis ticks to the top\n        ax.xaxis.tick_top()\n        ax.xaxis.set_label_position('top') \n\n        # Adjust the axis limits to fit the plot tightly\n        # Assuming 'step' is the distance between wells\n        ax.set_xlim(minX - step/2, maxX - step/2)\n        ax.set_ylim(minY - step/2, maxY - step/2)\n\n        # Set x and y tick labels\n        ax.set_xticks(x)\n        ax.set_xticklabels([str(i + 1) for i in self._columns])\n        ax.set_yticks(y)\n        ax.set_yticklabels(self.row_labels[::-1])\n\n        # Remove the tick marks but keep the labels\n        ax.tick_params(axis='both', length=0) \n\n        # Grid settings\n        if show_grid:\n            ax.xaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n            ax.yaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n        else:\n            ax.xaxis.grid(color=grid_color, linestyle='none',)\n            ax.yaxis.grid(color=grid_color, linestyle='none',)\n\n\n        # ax.set_xlim(minX - maxX*0.08, maxX - maxX*0.035)\n        ax.set_ylim(minY - maxY*0.07, maxY - maxY*0.07)\n\n        # # Set tick labels inside the plotting box\n        # ax.tick_params(direction='in')\n\n        # # Ugly but works to adjust label padding\n        TICK_PADDING = 5\n        xticks = [*ax.xaxis.get_major_ticks(), *ax.xaxis.get_minor_ticks()]\n        yticks = [*ax.yaxis.get_major_ticks(), *ax.yaxis.get_minor_ticks()]\n\n        for tick in (*xticks, *yticks):\n                tick.set_pad(TICK_PADDING)\n\n        # ax.set_axisbelow(False)\n                # fig.subplots_adjust(left=0.15, right=0.95, top=0.85, bottom=0.15)\n        ax.set_title(title_str+\"\\n\", fontsize=title_fontsize)\n\n\n        if show_frame:\n\n            x = minX- maxX*0.03  # X-coordinate of the lower-left corner\n            y = minY - maxY*0.04 # Y-coordinate of the lower-left corner\n            width = maxX*0.975 # Width of the rectangle\n            height = maxY*0.955  # Height of the rectangle\n            border_radius = 1  # Radius of the rounded corners\n\n            edge_alpha = 0.1\n            line_width = 2  \n\n            # Create a rounded rectangle\n            rounded_rectangle = FancyBboxPatch(\n                (x, y),\n                width,\n                height,\n                boxstyle=f\"round, pad={border_radius}\",\n                lw=line_width,\n                ec=(0, 0, 0,\n                edge_alpha),\n                fc=(0.95,0.95,0.95),\n                zorder=0)\n\n            # Add the rounded rectangle to the axis\n            ax.add_patch(rounded_rectangle)\n\n        return fig\n\n    def as_plotly_figure(\n        self,\n        annotation_metadata_key=None, \n        color_metadata_key=None,\n        fontsize=14,\n        title_str=None,\n        title_fontsize=14,\n        alpha=0.7,\n        well_size=45,  # Adjusted for Plotly marker size\n        fig_width=1000,  # Adjusted for Plotly size in pixels\n        fig_height=700,  # Adjusted for Plotly size in pixels\n        colormap_continuous=\"Viridis\",  # Default colormap in Plotly\n        colormap_discrete=\"D3\",  # Default colormap in Plotly\n        text_rotation=0,\n        show_grid=True,\n        theme='plotly',\n        dark_mode=False,\n        marker_shape='circle'\n    ) -&gt; 'plotly.graph_objs._figure.Figure':\n        \"\"\"\n        Generates a Plotly scatter plot representing the data of a biological plate.\n\n        This function takes various parameters for customization of the plot such as colors, \n        font sizes, title, and dimensions. It handles both continuous and discrete data types \n        for coloring and allows annotations on each point in the scatter plot.\n\n        Args:\n            annotation_metadata_key (str, optional): Metadata key for annotations. \n                Default is None.\n            color_metadata_key (str, optional): Metadata key for color mapping.\n                Default is None.\n            fontsize (int): Font size for annotations. Default is 14.\n            title_str (str, optional): Title of the plot. Default is None.\n            title_fontsize (int): Font size for the plot title. Default is 14.\n            alpha (float): Opacity level for markers. Default is 0.7.\n            well_size (int): Marker size. Default is 45.\n            fig_width (int): Width of the figure in pixels. Default is 1000.\n            fig_height (int): Height of the figure in pixels. Default is 700.\n            colormap_continuous (str): Colormap for continuous data. Default is \"Viridis\".\n            colormap_discrete (str): Colormap for discrete data. Default is \"D3\".\n            text_rotation (int): Rotation angle of text annotations. Default is 0.\n            show_grid (bool): Whether to show grid lines. Default is True.\n            theme (str): Plotly theme. Default is 'plotly'.\n\n        Returns:\n            plotly.graph_objs._figure.Figure.Figure: A Plotly scatter plot figure.\n\n        Example:\n\n        ```python\n        plate = Plate()\n        fig = plate.as_plotly_figure(\n            annotation_metadata_key='gene_name',\n            color_metadata_key='expression_level',\n            fontsize=12,\n            title_str='Gene Expression Levels',\n            title_fontsize=16,\n            alpha=0.8,\n            well_size=50,\n            fig_width=1200,\n            fig_height=800,\n            colormap_continuous=\"Plasma\",\n            text_rotation=45,\n            show_grid=False,\n            theme='plotly_dark'\n        )\n        fig.show()\n        ```\n\n        This example generates a scatter plot with gene names as annotations, colors representing\n        expression levels, customized font sizes, and a dark theme.\n\n        \"\"\"\n         # Transform the plate data into a DataFrame for easier manipulation\n        df = self.as_dataframe()\n\n        if dark_mode:\n            annotation_bg_color = 'rgba(10, 10, 10, 0.75)'\n            # annotation_font_color = \"black\"\n        else:\n            annotation_bg_color = 'rgba(255, 255, 255, 0.75)'\n\n        # Default values if parameters are not provided\n        if annotation_metadata_key is None:\n            annotation_metadata_key = 'name'\n        if color_metadata_key is None:\n            color_metadata_key = 'white'\n\n        if color_metadata_key == 'white':\n            df[color_metadata_key] = 'white' \n\n\n        # Calculate the maximum size for each well\n        # Assuming margins are set or default\n        margins = dict(l=50, r=50, t=50, b=50, pad=4)  # Default margins, update if changed in your layout\n        available_width = fig_width - margins['l'] - margins['r']\n        available_height = fig_height - margins['t'] - margins['b']\n\n        # Calculate space per well\n        space_per_well_x = available_width / self._n_columns\n        space_per_well_y = available_height / self._n_rows\n\n        # Set well size to be the minimum of the two, with a certain scaling factor\n        scaling_factor = 0.8  # Adjust this factor as needed\n        well_size = min(space_per_well_x, space_per_well_y) * scaling_factor\n\n        # Modify the plot based on marker_shape\n        marker_symbol = 'square' if marker_shape == 'square' else 'circle'\n\n        # Calculate the axis limits\n\n        # # Calculate the grid dimensions\n        step = 1 \n\n         # Calculate the axis limits\n        x_axis_min = -0.5 * step\n        x_axis_max = self._n_columns * step - 0.5 * step\n        y_axis_min = -0.5 * step\n        y_axis_max = self._n_rows * step - 0.5 * step\n\n        # Generate grid data for plotting, assuming equal spacing between wells\n        x = np.arange(0, len(self._columns)*step, step)\n        y = np.arange(0, len(self._rows)*step, step)\n        Xgrid, Ygrid = np.meshgrid(x, y)\n\n        # Convert coordinate tuples to separate columns for x and y\n        df['column'] = df['coordinate'].apply(lambda c: step*c[1])\n        df['row'] = df['coordinate'].apply(lambda c: step*c[0])\n\n        # hover_data = [\"name\"] + list(plate[0].metadata.keys())\n        hover_data = [\"name\"] + list(self[0].metadata.keys())\n\n        # Determine color scale and plot type based on the data type of color_metadata_key\n        if df[color_metadata_key].dtype.kind in 'ifc':  # Numeric data - continuous\n            color_scale = colormap_continuous\n            fig = px.scatter(\n                df,\n                x='column',\n                y='row',\n                hover_data=hover_data,\n                color=color_metadata_key,\n                color_continuous_scale=color_scale,\n                # other parameters...\n            )\n        else:  # Categorical data - discrete\n            discrete_color_sequence = px.colors.qualitative.__getattribute__(colormap_discrete)\n            fig = px.scatter(\n                df,\n                x='column',\n                y='row',\n                hover_data=hover_data,\n                color=color_metadata_key,\n                color_discrete_sequence=discrete_color_sequence,\n                # other parameters...\n            )\n\n        # Add annotations to each well in the plate\n        for well in self:\n            fig.add_annotation(\n                x=Xgrid[well.coordinate],\n                y=Ygrid[well.coordinate],\n                text=str(well.get_attribute_or_metadata(annotation_metadata_key)),\n                textangle= -1*text_rotation,\n                showarrow=False,\n                # font=dict(size=fontsize, color=annotation_font_color),\n                bgcolor=annotation_bg_color\n            )\n\n        fig.update_traces(\n            marker=dict(\n                size=well_size,\n                line=dict(width=2),\n            opacity=alpha,\n            symbol=marker_symbol,\n            ),\n            selector=dict(mode='markers')\n        )\n\n        # Adjust plot layout, axes, and other visual elements\n        fig.update_layout(\n            title=dict(text=title_str, font_size=title_fontsize),\n            width=fig_width,\n            height=fig_height,\n            xaxis=dict(\n                title=\"\",\n                showgrid=show_grid, \n                zeroline=False, \n                showticklabels=True, \n                tickmode=\"array\",\n                tickvals=list(range(0, step*self._n_columns, step)),\n                ticktext=self.column_labels,\n                side=\"top\",\n                tickfont=dict(size=18),\n                range=[x_axis_min, x_axis_max]\n            ),\n            yaxis=dict(\n                title=\"\",\n                showgrid=show_grid, \n                zeroline=False, \n                showticklabels=True, \n                tickmode=\"array\",\n                tickvals=list(range(0, step*step*self._n_rows, step)),\n                ticktext=self.row_labels[::-1],\n                tickfont=dict(size=18),\n                range=[y_axis_min, y_axis_max]\n            ),\n            template=theme,\n            legend=dict(\n                orientation=\"h\",  # Horizontal orientation\n                yanchor=\"bottom\",\n                y=-0.1,  # Adjust this value to move the legend up or down\n                xanchor=\"center\",\n                x=0.5\n            ),\n            margin=margins,\n        )\n\n        # # Make the layout responsive\n        # fig.update_layout(\n        #     autosize=True,\n        #     margin=dict(l=50, r=50, t=50, b=50, pad=4),  # Adjust margins as needed\n        #     # Remove fixed width and height, or set them to None\n        #     width=None,\n        #     height=None\n        # )\n\n        return fig\n\n    def to_file(self, file_path : str = None,\n                file_format : str = \"csv\",\n                metadata_keys : list = []) -&gt; None:\n        \"\"\"\n        Write the plate data to a file in the specified format.\n\n        The method supports various file formats such as CSV, TSV, and Excel. It allows \n        selection of specific metadata keys to be included in the output. If no file path \n        is specified, the file is saved in the current working directory with a default \n        name based on the plate ID.\n\n        Args:\n            file_path (str, optional): The path where the file will be saved. \n                If not specified, the file is saved in the current working directory.\n            file_format (str, optional): The format of the file ('csv', 'tsv', 'xls').\n            metadata_keys (list, optional): A list of metadata keys to include in the file. \n                If empty, all metadata except those in _default_exclude_metadata are included.\n\n        Raises:\n            ValueError: If an unsupported file format is specified.\n        \"\"\"\n\n        if file_path is None:\n            file_name = f\"plate_{self.plate_id}.{file_format}\"\n            file_path = Path.cwd() / file_name\n        else:\n            file_path = Path(file_path)\n            if file_path.is_dir():\n                file_name = f\"plate_{self.plate_id}.{file_format}\"\n                file_path = file_path / file_name\n            else:\n                if file_path.suffix == \"\":\n                    file_path = file_path.with_suffix(f\".{file_format}\")\n                else:\n                    file_format = file_path.suffix.lstrip('.')\n\n        logger.info(f\"Writing to file:\\n\\t{file_path}\")\n\n        df = self.as_dataframe()\n\n        if len(metadata_keys) &gt; 0:\n            df = df[metadata_keys]\n        else:  # use all metadata except those in default_exclude_metadata\n            df = df.drop(columns=self._default_exclude_metadata)\n\n        match file_format:\n            case \"csv\":\n                df.to_csv(file_path, index=False)\n\n            case \"tsv\":\n                df.to_csv(file_path, sep=\"\\t\", index=False)\n\n            case \"xls\":\n                df.to_excel(file_path, index=False)\n\n    def add_metadata(self, key, values):\n        \"\"\"\n        Add or update metadata for all wells in the plate. If a list of values is provided,\n        assign each value to the corresponding well. If a single value is provided, assign it to all wells.\n\n        Args:\n            key (str): The metadata key to add or update.\n            values: A single value or a list of values to set for the given metadata key. \n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n            &gt;&gt;&gt; plate.add_metadata('sample_type', ['RNA', 'DNA', 'RNA', 'DNA'])\n            &gt;&gt;&gt; [well.metadata['sample_type'] for well in plate.wells]\n            ['RNA', 'DNA', 'RNA', 'DNA']\n            &gt;&gt;&gt; plate.add_metadata('study', 'oncology')\n            &gt;&gt;&gt; all(well.metadata['study'] == 'oncology' for well in plate.wells)\n            True\n\n        \"\"\"\n        if isinstance(values, list):\n            # Case when values is a list\n            if len(values) != len(self.wells):\n                raise ValueError(\"The length of values list does not match the number of wells\")\n\n            for well, value in zip(self.wells, values):\n                well.metadata[key] = value\n        else:\n            # Case when a single value is provided\n            for well in self.wells:\n                well.metadata[key] = values\n\n    @property\n    def row_labels(self):\n        \"\"\"\n        Get the row labels for the plate.\n\n        This property generates a list of alphabetical characters representing the row labels\n        of the plate, based on the number of rows in the plate.\n\n        Returns:\n            list: A list of strings, each representing a row label.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate\n            &gt;&gt;&gt; plate.row_labels\n            ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']\n        \"\"\"\n        return list(string.ascii_uppercase)[:len(self._rows)]\n\n    @property\n    def column_labels(self):\n        \"\"\"\n        Get the column labels for the plate.\n\n        This property generates a list of numerical strings representing the column labels\n        of the plate, based on the number of columns in the plate.\n\n        Returns:\n            list: A list of strings, each representing a column label.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate\n            &gt;&gt;&gt; plate.column_labels\n            ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']\n        \"\"\"\n        return [str(row_id+1) for row_id in self._columns]\n\n    @property\n    def capacity(self):\n        \"\"\"\n        Get the number of samples that can be added to the plate, which is the same as the number of wells in this class\n\n        Example:\n            &gt;&gt;&gt; plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate\n            &gt;&gt;&gt; plate.capacity\n            96\n        \"\"\"\n        return self.size\n\n    @property\n    def plate_id(self):\n        \"\"\"\n        Get the plate ID.\n\n        This property returns the unique identifier of the plate.\n\n        Returns:\n            int: The plate ID.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; plate.plate_id\n            1\n        \"\"\"\n        return self._plate_id\n\n    @plate_id.setter\n    def plate_id(self, new_id):\n        \"\"\"\n        Set a new plate ID.\n\n        This method updates the plate ID and propagates the change to all the wells \n        within the plate.\n\n        Args:\n            new_id (int): The new plate ID to be set.\n\n        Example:\n            &gt;&gt;&gt; plate = Plate()\n            &gt;&gt;&gt; plate.plate_id = 2\n            &gt;&gt;&gt; plate.plate_id\n            2\n        \"\"\"\n        self._plate_id = new_id\n        for well in self.wells:\n            well.plate_id = new_id\n\n    @staticmethod    \n    def create_index_coordinates(rows, columns) -&gt; list:\n        \"\"\"\n        Static method to create a list of index coordinates for the wells in a plate.\n\n        The method generates a grid of coordinates, counting from left to right, \n        starting at the well in the top left. It is used to map the wells to their \n        respective positions in the plate.\n\n        Args:\n            rows (iterable): An iterable representing the rows of the plate.\n            columns (iterable): An iterable representing the columns of the plate.\n\n        Returns:\n            list: A list of tuples, each representing the (row, column) index of a well.\n\n        Example:\n            &gt;&gt;&gt; Plate.create_index_coordinates(range(2), range(2))\n            [(1, 0), (1, 1), (0, 0), (0, 1)]\n        \"\"\"\n        # count from left to right, starting at well in top left\n        return list(itertools.product(\n                                    range(len(rows)-1, -1, -1),\n                                    range(0, len(columns))\n                                    )\n                )\n\n    @staticmethod\n    def create_alphanumerical_coordinates(rows, columns):\n        \"\"\"\n        Static method to create alphanumerical coordinates for the wells.\n\n        Args:\n            rows (list): A list of row indices.\n            columns (list): A list of column indices.\n\n        Returns:\n            list: A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").\n\n        Example:\n            &gt;&gt;&gt; Plate.create_alphanumerical_coordinates([0, 1], [0, 1, 2])\n            ['A1', 'A2', 'A3', 'B1', 'B2', 'B3']\n            &gt;&gt;&gt; Plate.create_alphanumerical_coordinates([0], [0, 1])\n            ['A1', 'A2']\n        \"\"\"\n        row_labels = list(string.ascii_uppercase)[:len(rows)]\n        return [f\"{row_labels[row]}{col+1}\" for row, col in itertools.product(rows, columns)]\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.capacity","title":"<code>capacity</code>  <code>property</code>","text":"<p>Get the number of samples that can be added to the plate, which is the same as the number of wells in this class</p> Example <p>plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate plate.capacity 96</p>"},{"location":"plate/#src.plate_planner.plate.Plate.column_labels","title":"<code>column_labels</code>  <code>property</code>","text":"<p>Get the column labels for the plate.</p> <p>This property generates a list of numerical strings representing the column labels of the plate, based on the number of columns in the plate.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of strings, each representing a column label.</p> Example <p>plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate plate.column_labels ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10', '11', '12']</p>"},{"location":"plate/#src.plate_planner.plate.Plate.plate_id","title":"<code>plate_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the plate ID.</p> <p>This property returns the unique identifier of the plate.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The plate ID.</p> Example <p>plate = Plate() plate.plate_id 1</p>"},{"location":"plate/#src.plate_planner.plate.Plate.row_labels","title":"<code>row_labels</code>  <code>property</code>","text":"<p>Get the row labels for the plate.</p> <p>This property generates a list of alphabetical characters representing the row labels of the plate, based on the number of rows in the plate.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of strings, each representing a row label.</p> Example <p>plate = Plate(plate_dim=(8, 12))  # A standard 96-well plate plate.row_labels ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']</p>"},{"location":"plate/#src.plate_planner.plate.Plate.__add__","title":"<code>__add__(other)</code>","text":"<p>Combine the content of this Plate with another Plate.</p> <p>The wells of both plates are combined. If wells at the same coordinates  exist in both plates, their metadata is merged.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Plate</code> <p>Another Plate to combine with.</p> required <p>Returns:</p> Name Type Description <code>Plate</code> <code>Plate</code> <p>A new Plate with combined content from both plates.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the dimensions of the two plates do not match.</p> Example <p>plate1 = Plate(plate_dim=(2, 2)) plate1.wells[0].metadata = {'sample': 'A'} plate2 = Plate(plate_dim=(2, 2)) plate2.wells[0].metadata = {'volume': 100} combined_plate = plate1 + plate2 combined_plate.wells[0].metadata {'sample': 'A', 'volume': 100}</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __add__(self, other: \"Plate\") -&gt; \"Plate\":\n    \"\"\"\n    Combine the content of this Plate with another Plate.\n\n    The wells of both plates are combined. If wells at the same coordinates \n    exist in both plates, their metadata is merged.\n\n    Args:\n        other (Plate): Another Plate to combine with.\n\n    Returns:\n        Plate: A new Plate with combined content from both plates.\n\n    Raises:\n        ValueError: If the dimensions of the two plates do not match.\n\n    Example:\n        &gt;&gt;&gt; plate1 = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; plate1.wells[0].metadata = {'sample': 'A'}\n        &gt;&gt;&gt; plate2 = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; plate2.wells[0].metadata = {'volume': 100}\n        &gt;&gt;&gt; combined_plate = plate1 + plate2\n        &gt;&gt;&gt; combined_plate.wells[0].metadata\n        {'sample': 'A', 'volume': 100}\n    \"\"\"\n    if (self._n_rows, self._n_columns) != (other._n_rows, other._n_columns):\n        raise ValueError(\"Cannot add plates of different dimensions\")\n\n    # Create a new Plate for the combined content\n    new_plate = Plate(plate_dim=(self._n_rows, self._n_columns))\n\n    # Iterate through wells and combine metadata\n    for (well_self, well_other) in zip(self.wells, other.wells):\n        combined_metadata = {**well_self.metadata, **well_other.metadata}\n        new_well = Well(name=well_self.name, plate_id=new_plate.plate_id,\n                        coordinate=well_self.coordinate, index=well_self.index,\n                        rgb_color=well_self.rgb_color, metadata=combined_metadata)\n        new_plate.wells[well_self.index] = new_well\n\n    return new_plate\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve a well from the plate based on its index, coordinate, or name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int, tuple, or str</code> <p>The identifier for the well. Can be an integer index, </p> required <p>Returns:</p> Name Type Description <code>Well</code> <p>The well object corresponding to the given key.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the key is not an integer, tuple, or string.</p> Example <p>plate = Plate() plate[0].name 'A1' plate[(0, 0)].name 'A1' plate[\"A1\"].name 'A1'</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __getitem__(self, key: Union[int, Tuple[int,int], str]):\n    \"\"\"\n    Retrieve a well from the plate based on its index, coordinate, or name.\n\n    Args:\n        key (int, tuple, or str): The identifier for the well. Can be an integer index, \n        a tuple indicating row and column coordinates, or a string specifying the well's name.\n\n    Returns:\n        Well: The well object corresponding to the given key.\n\n    Raises:\n        TypeError: If the key is not an integer, tuple, or string.\n\n    Example:\n        &gt;&gt;&gt; plate = Plate()\n        &gt;&gt;&gt; plate[0].name\n        'A1'\n        &gt;&gt;&gt; plate[(0, 0)].name\n        'A1'\n        &gt;&gt;&gt; plate[\"A1\"].name\n        'A1'\n    \"\"\"\n    if isinstance(key, int):\n        # Access by index\n        return self.wells[key]\n    elif isinstance(key, tuple):\n        # Access by coordinate\n        index = self._coordinates_to_index(key)\n        return self.wells[index]\n    elif isinstance(key, str):\n        # Access by name\n        index = self._name_to_index_map[key]\n        return self.wells[index]\n    else:\n        raise TypeError(\"Key must be an integer, tuple, or string\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.__init__","title":"<code>__init__(plate_dim=None, plate_id=1)</code>","text":"<p>Initialize a new Plate instance.</p> <p>Parameters:</p> Name Type Description Default <code>plate_dim</code> <code>Tuple[int, int]</code> <p>The dimensions of the plate as (rows, columns). If None, default dimensions are used.</p> <code>None</code> <code>plate_id</code> <code>int</code> <p>A unique identifier for the plate.</p> <code>1</code> <p>The constructor initializes the plate with the specified dimensions, generating wells  with default properties and assigning them unique coordinates and identifiers.</p> <p>Examples:</p> <p>Creating a Plate instance with default dimensions and a specific plate ID:</p> <pre><code>&gt;&gt;&gt; plate = Plate()\n&gt;&gt;&gt; plate.size\n96\n</code></pre> <pre><code>&gt;&gt;&gt; plate = Plate(plate_dim=(16, 24))\n&gt;&gt;&gt; plate.size\n384\n</code></pre> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __init__(self, plate_dim: Union[Tuple[int, int], List[int], Dict[str, int], int] = None, plate_id: int = 1):\n    \"\"\"\n    Initialize a new Plate instance.\n\n    Args:\n        plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n            If None, default dimensions are used.\n        plate_id (int, optional): A unique identifier for the plate.\n\n    The constructor initializes the plate with the specified dimensions, generating wells \n    with default properties and assigning them unique coordinates and identifiers.\n\n    Examples:\n        Creating a Plate instance with default dimensions and a specific plate ID:\n\n        &gt;&gt;&gt; plate = Plate()\n        &gt;&gt;&gt; plate.size\n        96\n\n        &gt;&gt;&gt; plate = Plate(plate_dim=(16, 24))\n        &gt;&gt;&gt; plate.size\n        384\n\n    \"\"\"\n\n    self._n_rows, self._n_columns = self._parse_plate_dimensions(plate_dim)\n\n    self._rows = list(range(self._n_rows))\n    self._columns = list(range(self._n_columns))\n\n    self._alphanumerical_coordinates = self.create_alphanumerical_coordinates(self._rows, self._columns)\n    self._coordinates = self.create_index_coordinates(self._rows, self._columns)\n\n    self.size = self._n_rows * self._n_columns\n\n    self.wells = [Well(name=self._alphanumerical_coordinates[index], \n                       coordinate=(row, col), \n                       index=index, \n                       plate_id=plate_id, \n                       rgb_color=self._default_well_color)\n                  for index, (row, col) in enumerate(itertools.product(self._rows[::-1], self._columns))]\n\n    self.plate_id = plate_id\n\n    # dictionary to map well names to indices\n    self._name_to_index_map = {well.name: well.index for well in self.wells}\n    self._index_to_coordinates_map = {well.index: well.coordinate for well in self.wells}\n    self._index_to_name_map = {well.index: well.name for well in self.wells}\n\n    logger.info(f\"Created a {self._n_rows}x{self._n_columns} plate with {self.size} wells.\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.__iter__","title":"<code>__iter__()</code>","text":"<p>Return an iterator over the wells of the plate.</p> <p>This allows direct iteration over the plate object itself.</p> Example <p>plate = Plate(plate_dim=(2, 2)) [well.name for well in plate] ['A1', 'A2', 'B1', 'B2']</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __iter__(self):\n    \"\"\"\n    Return an iterator over the wells of the plate.\n\n    This allows direct iteration over the plate object itself.\n\n    Example:\n        &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; [well.name for well in plate]\n        ['A1', 'A2', 'B1', 'B2']\n    \"\"\"\n    return iter(self.wells)\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of wells in the plate.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of wells.</p> Example <p>plate = Plate() len(plate) 96</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Returns the number of wells in the plate.\n\n    Returns:\n        int: The number of wells.\n\n    Example:\n        &gt;&gt;&gt; plate = Plate()\n        &gt;&gt;&gt; len(plate)\n        96\n    \"\"\"\n    return len(self.wells)\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.__setitem__","title":"<code>__setitem__(key, well_object)</code>","text":"<p>Set or replace a well in the plate based on its index, coordinate, or name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int, tuple, or str</code> <p>The identifier for the well to be set or replaced.  Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.</p> required <p>well_object (Well): The well object to set at the specified key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the well_object is not an instance of Well.</p> <code>IndexError</code> <p>If the well index is out of range.</p> <code>TypeError</code> <p>If the key is not a string, integer, or tuple.</p> Example <p>plate = Plate(plate_dim=(2, 2))  # Create a small 2x2 plate for simplicity new_well = Well(name=\"C3\", plate_id=1, coordinate=(0, 1), metadata={\"study_group\": \"control\"})  # Define a new well plate[0] = new_well  # Set this well at the first position plate[0].name 'A1' plate[0].metadata[\"study_group\"] 'control'</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __setitem__(self, key, well_object: Well):\n    \"\"\"\n    Set or replace a well in the plate based on its index, coordinate, or name.\n\n    Args:\n        key (int, tuple, or str): The identifier for the well to be set or replaced. \n            Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.\n    well_object (Well): The well object to set at the specified key.\n\n    Raises:\n        ValueError: If the well_object is not an instance of Well.\n        IndexError: If the well index is out of range.\n        TypeError: If the key is not a string, integer, or tuple.\n\n    Example:\n        &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))  # Create a small 2x2 plate for simplicity\n        &gt;&gt;&gt; new_well = Well(name=\"C3\", plate_id=1, coordinate=(0, 1), metadata={\"study_group\": \"control\"})  # Define a new well\n        &gt;&gt;&gt; plate[0] = new_well  # Set this well at the first position\n        &gt;&gt;&gt; plate[0].name\n        'A1'\n        &gt;&gt;&gt; plate[0].metadata[\"study_group\"]\n        'control'\n    \"\"\"\n    if not isinstance(well_object, Well):\n        raise ValueError(\"Value must be an instance of Well\")\n\n    if isinstance(key, str):\n        index = self._name_to_index_map[key]\n        coordinate = self._index_to_coordinates_map[index]\n        name = key\n    elif isinstance(key, int):\n        if key &lt; 0 or key &gt;= len(self.wells):\n            raise IndexError(\"Well index out of range\")\n        index = key\n        coordinate = self._index_to_coordinates_map[index]\n        name = self.wells[index].name\n    elif isinstance(key, tuple):\n        index = self._coordinates_to_index(key)\n        coordinate = key\n        name = self._index_to_name_map(index)\n    else:\n        raise TypeError(\"Key must be a string, integer, or tuple\")\n\n    # Update the well object's attributes\n    well_object.name = name\n    well_object.coordinate = coordinate\n    well_object.index = index\n    well_object.plate_id = self.plate_id\n\n    # Update the well at the specified index on the plate\n    self.wells[index] = well_object\n    # Update the name-to-index mapping\n    self._name_to_index_map[name] = index\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.add_metadata","title":"<code>add_metadata(key, values)</code>","text":"<p>Add or update metadata for all wells in the plate. If a list of values is provided, assign each value to the corresponding well. If a single value is provided, assign it to all wells.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The metadata key to add or update.</p> required <code>values</code> <p>A single value or a list of values to set for the given metadata key. </p> required Example <p>plate = Plate(plate_dim=(2, 2)) plate.add_metadata('sample_type', ['RNA', 'DNA', 'RNA', 'DNA']) [well.metadata['sample_type'] for well in plate.wells] ['RNA', 'DNA', 'RNA', 'DNA'] plate.add_metadata('study', 'oncology') all(well.metadata['study'] == 'oncology' for well in plate.wells) True</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def add_metadata(self, key, values):\n    \"\"\"\n    Add or update metadata for all wells in the plate. If a list of values is provided,\n    assign each value to the corresponding well. If a single value is provided, assign it to all wells.\n\n    Args:\n        key (str): The metadata key to add or update.\n        values: A single value or a list of values to set for the given metadata key. \n\n    Example:\n        &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; plate.add_metadata('sample_type', ['RNA', 'DNA', 'RNA', 'DNA'])\n        &gt;&gt;&gt; [well.metadata['sample_type'] for well in plate.wells]\n        ['RNA', 'DNA', 'RNA', 'DNA']\n        &gt;&gt;&gt; plate.add_metadata('study', 'oncology')\n        &gt;&gt;&gt; all(well.metadata['study'] == 'oncology' for well in plate.wells)\n        True\n\n    \"\"\"\n    if isinstance(values, list):\n        # Case when values is a list\n        if len(values) != len(self.wells):\n            raise ValueError(\"The length of values list does not match the number of wells\")\n\n        for well, value in zip(self.wells, values):\n            well.metadata[key] = value\n    else:\n        # Case when a single value is provided\n        for well in self.wells:\n            well.metadata[key] = values\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.as_dataframe","title":"<code>as_dataframe()</code>","text":"<p>Converts the plate data into a Pandas DataFrame.</p> <p>Each well and its attributes are represented as a row in the DataFrame.</p> <p>Returns:</p> Type Description <p>pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.</p> <p>Example:</p> <p>plate = Plate() df = plate.as_dataframe() len(df) 96</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Converts the plate data into a Pandas DataFrame.\n\n    Each well and its attributes are represented as a row in the DataFrame.\n\n    Returns:\n        pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.\n\n    Example:\n    &gt;&gt;&gt; plate = Plate()\n    &gt;&gt;&gt; df = plate.as_dataframe()\n    &gt;&gt;&gt; len(df)\n    96\n    \"\"\"\n    return pd.DataFrame(self.as_records())\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.as_figure","title":"<code>as_figure(annotation_metadata_key=None, color_metadata_key=None, fontsize=8, rotation=0, step=10, title_str=None, title_fontsize=14, alpha=0.7, well_size=1200, fig_width=11.69, fig_height=8.27, dpi=100, plt_style='fivethirtyeight', grid_color=(1, 1, 1), edge_color=(0.5, 0.5, 0.5), legend_bb=(0.15, -0.15, 0.7, 1.3), legend_n_columns=6, colormap='tab10', show_grid=True, show_frame=True)</code>","text":"<p>Create a visual representation of the plate using matplotlib.</p> <p>This method generates a figure representing the plate, with options for annotations, coloring based on metadata, and various styling adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_metadata_key</code> <code>str</code> <p>Metadata key to use for annotating wells.</p> <code>None</code> <code>color_metadata_key</code> <code>str</code> <p>Metadata key to determine the color of wells.</p> <code>None</code> <code>fontsize</code> <code>int</code> <p>Font size for annotations. Default is 8.</p> <code>8</code> <code>rotation</code> <code>int</code> <p>Rotation angle for annotations. Default is 0.</p> <code>0</code> <code>step</code> <code>int</code> <p>Step size between wells in the grid. Default is 10.</p> <code>10</code> <code>title_str</code> <code>str</code> <p>Title of the figure. If None, a default title is used.</p> <code>None</code> <code>title_fontsize</code> <code>str</code> <p>Font size for title.</p> <code>14</code> <code>alpha</code> <code>float</code> <p>Alpha value for well colors. Default is 0.7.</p> <code>0.7</code> <code>well_size</code> <code>int</code> <p>Size of the wells in the figure. Default is 1200.</p> <code>1200</code> <code>fig_width</code> <code>float</code> <p>Width of the figure. Default is 11.69.</p> <code>11.69</code> <code>fig_height</code> <code>float</code> <p>Height of the figure. Default is 8.27.</p> <code>8.27</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure. Default is 100.</p> <code>100</code> <code>plt_style</code> <code>str</code> <p>Matplotlib style to use. Default is 'bmh'.</p> <code>'fivethirtyeight'</code> <code>grid_color</code> <code>tuple</code> <p>Color for the grid. Default is (1, 1, 1).</p> <code>(1, 1, 1)</code> <code>edge_color</code> <code>tuple</code> <p>Color for the edges of wells. Default is (0.5, 0.5, 0.5).</p> <code>(0.5, 0.5, 0.5)</code> <code>legend_bb</code> <code>tuple</code> <p>Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).</p> <code>(0.15, -0.15, 0.7, 1.3)</code> <code>legend_n_columns</code> <code>int</code> <p>Number of columns in the legend. Default is 6.</p> <code>6</code> <code>colormap</code> <code>str</code> <p>Colormap name for coloring wells. Uses default colormap if None.</p> <code>'tab10'</code> <code>show_grid</code> <code>bool</code> <p>If True, displays a grid anchored at the well centers; default is True.</p> <code>True</code> <code>show_grid</code> <code>bool</code> <p>If True, plot a rectangle to frame the wells; default is True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Figure</code> <p>matplotlib.figure.Figure: A figure object representing the plate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided metadata keys are not valid.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def as_figure(self, annotation_metadata_key=None, \n              color_metadata_key=None,\n              fontsize=8,\n              rotation=0,\n              step=10,\n              title_str=None,\n              title_fontsize=14,\n              alpha=0.7,\n              well_size=1200,\n              fig_width=11.69,\n              fig_height=8.27,\n              dpi=100,\n              plt_style=\"fivethirtyeight\",\n              grid_color=(1, 1, 1),\n              edge_color=(0.5, 0.5, 0.5),\n              legend_bb=(0.15, -0.15, 0.7, 1.3),\n              legend_n_columns=6,\n              colormap=\"tab10\",\n              show_grid=True,\n              show_frame=True\n              ) -&gt; 'matplotlib.figure.Figure':\n    \"\"\"\n    Create a visual representation of the plate using matplotlib.\n\n    This method generates a figure representing the plate, with options for annotations,\n    coloring based on metadata, and various styling adjustments.\n\n    Args:\n        annotation_metadata_key (str, optional): Metadata key to use for annotating wells.\n        color_metadata_key (str, optional): Metadata key to determine the color of wells.\n        fontsize (int, optional): Font size for annotations. Default is 8.\n        rotation (int, optional): Rotation angle for annotations. Default is 0.\n        step (int, optional): Step size between wells in the grid. Default is 10.\n        title_str (str, optional): Title of the figure. If None, a default title is used.\n        title_fontsize (str, optional): Font size for title.\n        alpha (float, optional): Alpha value for well colors. Default is 0.7.\n        well_size (int, optional): Size of the wells in the figure. Default is 1200.\n        fig_width (float, optional): Width of the figure. Default is 11.69.\n        fig_height (float, optional): Height of the figure. Default is 8.27.\n        dpi (int, optional): Dots per inch for the figure. Default is 100.\n        plt_style (str, optional): Matplotlib style to use. Default is 'bmh'.\n        grid_color (tuple, optional): Color for the grid. Default is (1, 1, 1).\n        edge_color (tuple, optional): Color for the edges of wells. Default is (0.5, 0.5, 0.5).\n        legend_bb (tuple, optional): Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).\n        legend_n_columns (int, optional): Number of columns in the legend. Default is 6.\n        colormap (str, optional): Colormap name for coloring wells. Uses default colormap if None.\n        show_grid (bool, optional): If True, displays a grid anchored at the well centers; default is True.\n        show_grid (bool, optional): If True, plot a rectangle to frame the wells; default is True.\n\n    Returns:\n        matplotlib.figure.Figure: A figure object representing the plate.\n\n    Raises:\n        ValueError: If provided metadata keys are not valid.\n    \"\"\"\n    colormap = colormap if colormap else self._default_colormap\n\n    # Validate metadata keys\n    if color_metadata_key and not self.is_valid_metadata_key(color_metadata_key):\n        raise ValueError(f\"Invalid color_metadata_key: {color_metadata_key}\")\n    if annotation_metadata_key and not self.is_valid_metadata_key(annotation_metadata_key):\n        raise ValueError(f\"Invalid annotation_metadata_key: {annotation_metadata_key}\")\n\n    # Define title\n    if not title_str:\n        title_str = f\"Plate {self.plate_id}\"\n        if annotation_metadata_key or color_metadata_key:\n            title_str += f\", showing {annotation_metadata_key or ''} colored by {color_metadata_key or ''}\"\n\n    # Assign colors to wells\n    self._assign_well_color(color_metadata_key, colormap)\n\n    # Prepare grid and data for plotting\n    minX, maxX, minY, maxY = 0, len(self._columns)*step, 0, len(self._rows)*step\n    x = np.arange(minX, maxX, step)\n    y = np.arange(minY, maxY, step)\n\n    # Generate grid with columns first (column-major format)\n    Xgrid, Ygrid = np.meshgrid(x, y)\n\n    size_grid = np.ones_like(Xgrid) * well_size\n\n    well_colors = np.ravel((self.get_metadata_as_numpy_array(\"rgb_color\")[::-1]))\n\n    # Plot setup\n    plt.style.use(plt_style)\n    fig = plt.figure(facecolor='white', figsize=(fig_width, fig_height), dpi=dpi,)\n    ax = fig.add_subplot(111, facecolor='white')\n    # fig, ax = plt.subplots(figsize=(fig_width, fig_height), dpi=dpi, facecolor=\"white\")\n    # Remove the axis lines\n    ax.spines['top'].set_visible(False)\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n\n    ax.scatter(Xgrid, Ygrid, s=size_grid, c=well_colors, alpha=alpha, edgecolors=edge_color)\n\n    # Annotations\n    if annotation_metadata_key:\n        for well in self:\n            x_i = Xgrid[well.coordinate]\n            y_i = Ygrid[well.coordinate]\n            annotation_label = well.get_attribute_or_metadata(annotation_metadata_key)\n            ax.annotate(annotation_label, (x_i, y_i), ha='center', va='center', rotation=rotation, fontsize=fontsize, bbox=dict(facecolor='white', alpha=0.5, boxstyle=\"round,pad=0.25,rounding_size=0.5\"))\n\n    # Legends\n    if color_metadata_key:\n        # Get unique categories and their corresponding colors\n        legend_marker_size = np.sqrt(well_size) * 0.5\n        unique_categories = set(self.get_metadata(color_metadata_key))\n        legend_handles = [plt.Line2D([0], [0], marker='o', color=self._metadata_color_map.get(category, self._default_well_color), alpha=alpha, label=category, markersize=legend_marker_size, linestyle='None') \n                        for category in unique_categories]\n\n        ax.legend(handles=legend_handles, bbox_to_anchor=legend_bb, loc='lower center', frameon=False, labelspacing=1, ncol=legend_n_columns)\n\n    # Axis settings\n    # Move x-axis ticks to the top\n    ax.xaxis.tick_top()\n    ax.xaxis.set_label_position('top') \n\n    # Adjust the axis limits to fit the plot tightly\n    # Assuming 'step' is the distance between wells\n    ax.set_xlim(minX - step/2, maxX - step/2)\n    ax.set_ylim(minY - step/2, maxY - step/2)\n\n    # Set x and y tick labels\n    ax.set_xticks(x)\n    ax.set_xticklabels([str(i + 1) for i in self._columns])\n    ax.set_yticks(y)\n    ax.set_yticklabels(self.row_labels[::-1])\n\n    # Remove the tick marks but keep the labels\n    ax.tick_params(axis='both', length=0) \n\n    # Grid settings\n    if show_grid:\n        ax.xaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n        ax.yaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n    else:\n        ax.xaxis.grid(color=grid_color, linestyle='none',)\n        ax.yaxis.grid(color=grid_color, linestyle='none',)\n\n\n    # ax.set_xlim(minX - maxX*0.08, maxX - maxX*0.035)\n    ax.set_ylim(minY - maxY*0.07, maxY - maxY*0.07)\n\n    # # Set tick labels inside the plotting box\n    # ax.tick_params(direction='in')\n\n    # # Ugly but works to adjust label padding\n    TICK_PADDING = 5\n    xticks = [*ax.xaxis.get_major_ticks(), *ax.xaxis.get_minor_ticks()]\n    yticks = [*ax.yaxis.get_major_ticks(), *ax.yaxis.get_minor_ticks()]\n\n    for tick in (*xticks, *yticks):\n            tick.set_pad(TICK_PADDING)\n\n    # ax.set_axisbelow(False)\n            # fig.subplots_adjust(left=0.15, right=0.95, top=0.85, bottom=0.15)\n    ax.set_title(title_str+\"\\n\", fontsize=title_fontsize)\n\n\n    if show_frame:\n\n        x = minX- maxX*0.03  # X-coordinate of the lower-left corner\n        y = minY - maxY*0.04 # Y-coordinate of the lower-left corner\n        width = maxX*0.975 # Width of the rectangle\n        height = maxY*0.955  # Height of the rectangle\n        border_radius = 1  # Radius of the rounded corners\n\n        edge_alpha = 0.1\n        line_width = 2  \n\n        # Create a rounded rectangle\n        rounded_rectangle = FancyBboxPatch(\n            (x, y),\n            width,\n            height,\n            boxstyle=f\"round, pad={border_radius}\",\n            lw=line_width,\n            ec=(0, 0, 0,\n            edge_alpha),\n            fc=(0.95,0.95,0.95),\n            zorder=0)\n\n        # Add the rounded rectangle to the axis\n        ax.add_patch(rounded_rectangle)\n\n    return fig\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.as_plotly_figure","title":"<code>as_plotly_figure(annotation_metadata_key=None, color_metadata_key=None, fontsize=14, title_str=None, title_fontsize=14, alpha=0.7, well_size=45, fig_width=1000, fig_height=700, colormap_continuous='Viridis', colormap_discrete='D3', text_rotation=0, show_grid=True, theme='plotly', dark_mode=False, marker_shape='circle')</code>","text":"<p>Generates a Plotly scatter plot representing the data of a biological plate.</p> <p>This function takes various parameters for customization of the plot such as colors,  font sizes, title, and dimensions. It handles both continuous and discrete data types  for coloring and allows annotations on each point in the scatter plot.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_metadata_key</code> <code>str</code> <p>Metadata key for annotations.  Default is None.</p> <code>None</code> <code>color_metadata_key</code> <code>str</code> <p>Metadata key for color mapping. Default is None.</p> <code>None</code> <code>fontsize</code> <code>int</code> <p>Font size for annotations. Default is 14.</p> <code>14</code> <code>title_str</code> <code>str</code> <p>Title of the plot. Default is None.</p> <code>None</code> <code>title_fontsize</code> <code>int</code> <p>Font size for the plot title. Default is 14.</p> <code>14</code> <code>alpha</code> <code>float</code> <p>Opacity level for markers. Default is 0.7.</p> <code>0.7</code> <code>well_size</code> <code>int</code> <p>Marker size. Default is 45.</p> <code>45</code> <code>fig_width</code> <code>int</code> <p>Width of the figure in pixels. Default is 1000.</p> <code>1000</code> <code>fig_height</code> <code>int</code> <p>Height of the figure in pixels. Default is 700.</p> <code>700</code> <code>colormap_continuous</code> <code>str</code> <p>Colormap for continuous data. Default is \"Viridis\".</p> <code>'Viridis'</code> <code>colormap_discrete</code> <code>str</code> <p>Colormap for discrete data. Default is \"D3\".</p> <code>'D3'</code> <code>text_rotation</code> <code>int</code> <p>Rotation angle of text annotations. Default is 0.</p> <code>0</code> <code>show_grid</code> <code>bool</code> <p>Whether to show grid lines. Default is True.</p> <code>True</code> <code>theme</code> <code>str</code> <p>Plotly theme. Default is 'plotly'.</p> <code>'plotly'</code> <p>Returns:</p> Type Description <code>Figure</code> <p>plotly.graph_objs._figure.Figure.Figure: A Plotly scatter plot figure.</p> <p>Example:</p> <pre><code>plate = Plate()\nfig = plate.as_plotly_figure(\n    annotation_metadata_key='gene_name',\n    color_metadata_key='expression_level',\n    fontsize=12,\n    title_str='Gene Expression Levels',\n    title_fontsize=16,\n    alpha=0.8,\n    well_size=50,\n    fig_width=1200,\n    fig_height=800,\n    colormap_continuous=\"Plasma\",\n    text_rotation=45,\n    show_grid=False,\n    theme='plotly_dark'\n)\nfig.show()\n</code></pre> <p>This example generates a scatter plot with gene names as annotations, colors representing expression levels, customized font sizes, and a dark theme.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def as_plotly_figure(\n    self,\n    annotation_metadata_key=None, \n    color_metadata_key=None,\n    fontsize=14,\n    title_str=None,\n    title_fontsize=14,\n    alpha=0.7,\n    well_size=45,  # Adjusted for Plotly marker size\n    fig_width=1000,  # Adjusted for Plotly size in pixels\n    fig_height=700,  # Adjusted for Plotly size in pixels\n    colormap_continuous=\"Viridis\",  # Default colormap in Plotly\n    colormap_discrete=\"D3\",  # Default colormap in Plotly\n    text_rotation=0,\n    show_grid=True,\n    theme='plotly',\n    dark_mode=False,\n    marker_shape='circle'\n) -&gt; 'plotly.graph_objs._figure.Figure':\n    \"\"\"\n    Generates a Plotly scatter plot representing the data of a biological plate.\n\n    This function takes various parameters for customization of the plot such as colors, \n    font sizes, title, and dimensions. It handles both continuous and discrete data types \n    for coloring and allows annotations on each point in the scatter plot.\n\n    Args:\n        annotation_metadata_key (str, optional): Metadata key for annotations. \n            Default is None.\n        color_metadata_key (str, optional): Metadata key for color mapping.\n            Default is None.\n        fontsize (int): Font size for annotations. Default is 14.\n        title_str (str, optional): Title of the plot. Default is None.\n        title_fontsize (int): Font size for the plot title. Default is 14.\n        alpha (float): Opacity level for markers. Default is 0.7.\n        well_size (int): Marker size. Default is 45.\n        fig_width (int): Width of the figure in pixels. Default is 1000.\n        fig_height (int): Height of the figure in pixels. Default is 700.\n        colormap_continuous (str): Colormap for continuous data. Default is \"Viridis\".\n        colormap_discrete (str): Colormap for discrete data. Default is \"D3\".\n        text_rotation (int): Rotation angle of text annotations. Default is 0.\n        show_grid (bool): Whether to show grid lines. Default is True.\n        theme (str): Plotly theme. Default is 'plotly'.\n\n    Returns:\n        plotly.graph_objs._figure.Figure.Figure: A Plotly scatter plot figure.\n\n    Example:\n\n    ```python\n    plate = Plate()\n    fig = plate.as_plotly_figure(\n        annotation_metadata_key='gene_name',\n        color_metadata_key='expression_level',\n        fontsize=12,\n        title_str='Gene Expression Levels',\n        title_fontsize=16,\n        alpha=0.8,\n        well_size=50,\n        fig_width=1200,\n        fig_height=800,\n        colormap_continuous=\"Plasma\",\n        text_rotation=45,\n        show_grid=False,\n        theme='plotly_dark'\n    )\n    fig.show()\n    ```\n\n    This example generates a scatter plot with gene names as annotations, colors representing\n    expression levels, customized font sizes, and a dark theme.\n\n    \"\"\"\n     # Transform the plate data into a DataFrame for easier manipulation\n    df = self.as_dataframe()\n\n    if dark_mode:\n        annotation_bg_color = 'rgba(10, 10, 10, 0.75)'\n        # annotation_font_color = \"black\"\n    else:\n        annotation_bg_color = 'rgba(255, 255, 255, 0.75)'\n\n    # Default values if parameters are not provided\n    if annotation_metadata_key is None:\n        annotation_metadata_key = 'name'\n    if color_metadata_key is None:\n        color_metadata_key = 'white'\n\n    if color_metadata_key == 'white':\n        df[color_metadata_key] = 'white' \n\n\n    # Calculate the maximum size for each well\n    # Assuming margins are set or default\n    margins = dict(l=50, r=50, t=50, b=50, pad=4)  # Default margins, update if changed in your layout\n    available_width = fig_width - margins['l'] - margins['r']\n    available_height = fig_height - margins['t'] - margins['b']\n\n    # Calculate space per well\n    space_per_well_x = available_width / self._n_columns\n    space_per_well_y = available_height / self._n_rows\n\n    # Set well size to be the minimum of the two, with a certain scaling factor\n    scaling_factor = 0.8  # Adjust this factor as needed\n    well_size = min(space_per_well_x, space_per_well_y) * scaling_factor\n\n    # Modify the plot based on marker_shape\n    marker_symbol = 'square' if marker_shape == 'square' else 'circle'\n\n    # Calculate the axis limits\n\n    # # Calculate the grid dimensions\n    step = 1 \n\n     # Calculate the axis limits\n    x_axis_min = -0.5 * step\n    x_axis_max = self._n_columns * step - 0.5 * step\n    y_axis_min = -0.5 * step\n    y_axis_max = self._n_rows * step - 0.5 * step\n\n    # Generate grid data for plotting, assuming equal spacing between wells\n    x = np.arange(0, len(self._columns)*step, step)\n    y = np.arange(0, len(self._rows)*step, step)\n    Xgrid, Ygrid = np.meshgrid(x, y)\n\n    # Convert coordinate tuples to separate columns for x and y\n    df['column'] = df['coordinate'].apply(lambda c: step*c[1])\n    df['row'] = df['coordinate'].apply(lambda c: step*c[0])\n\n    # hover_data = [\"name\"] + list(plate[0].metadata.keys())\n    hover_data = [\"name\"] + list(self[0].metadata.keys())\n\n    # Determine color scale and plot type based on the data type of color_metadata_key\n    if df[color_metadata_key].dtype.kind in 'ifc':  # Numeric data - continuous\n        color_scale = colormap_continuous\n        fig = px.scatter(\n            df,\n            x='column',\n            y='row',\n            hover_data=hover_data,\n            color=color_metadata_key,\n            color_continuous_scale=color_scale,\n            # other parameters...\n        )\n    else:  # Categorical data - discrete\n        discrete_color_sequence = px.colors.qualitative.__getattribute__(colormap_discrete)\n        fig = px.scatter(\n            df,\n            x='column',\n            y='row',\n            hover_data=hover_data,\n            color=color_metadata_key,\n            color_discrete_sequence=discrete_color_sequence,\n            # other parameters...\n        )\n\n    # Add annotations to each well in the plate\n    for well in self:\n        fig.add_annotation(\n            x=Xgrid[well.coordinate],\n            y=Ygrid[well.coordinate],\n            text=str(well.get_attribute_or_metadata(annotation_metadata_key)),\n            textangle= -1*text_rotation,\n            showarrow=False,\n            # font=dict(size=fontsize, color=annotation_font_color),\n            bgcolor=annotation_bg_color\n        )\n\n    fig.update_traces(\n        marker=dict(\n            size=well_size,\n            line=dict(width=2),\n        opacity=alpha,\n        symbol=marker_symbol,\n        ),\n        selector=dict(mode='markers')\n    )\n\n    # Adjust plot layout, axes, and other visual elements\n    fig.update_layout(\n        title=dict(text=title_str, font_size=title_fontsize),\n        width=fig_width,\n        height=fig_height,\n        xaxis=dict(\n            title=\"\",\n            showgrid=show_grid, \n            zeroline=False, \n            showticklabels=True, \n            tickmode=\"array\",\n            tickvals=list(range(0, step*self._n_columns, step)),\n            ticktext=self.column_labels,\n            side=\"top\",\n            tickfont=dict(size=18),\n            range=[x_axis_min, x_axis_max]\n        ),\n        yaxis=dict(\n            title=\"\",\n            showgrid=show_grid, \n            zeroline=False, \n            showticklabels=True, \n            tickmode=\"array\",\n            tickvals=list(range(0, step*step*self._n_rows, step)),\n            ticktext=self.row_labels[::-1],\n            tickfont=dict(size=18),\n            range=[y_axis_min, y_axis_max]\n        ),\n        template=theme,\n        legend=dict(\n            orientation=\"h\",  # Horizontal orientation\n            yanchor=\"bottom\",\n            y=-0.1,  # Adjust this value to move the legend up or down\n            xanchor=\"center\",\n            x=0.5\n        ),\n        margin=margins,\n    )\n\n    # # Make the layout responsive\n    # fig.update_layout(\n    #     autosize=True,\n    #     margin=dict(l=50, r=50, t=50, b=50, pad=4),  # Adjust margins as needed\n    #     # Remove fixed width and height, or set them to None\n    #     width=None,\n    #     height=None\n    # )\n\n    return fig\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.as_records","title":"<code>as_records()</code>","text":"<p>Convert the plate's well data into a list of dictionaries.</p> <p>Each well's attributes are converted into a dictionary, and all these dictionaries are compiled into a list, with one dictionary per well.</p> <p>Returns:</p> Type Description <p>list of dict: A list where each element is a dictionary representing a well's attributes.</p> Example <p>plate = Plate(plate_dim=(1, 2)) plate[0].metadata[\"sample_type\"] = \"plasma\" # set metadata for first well records = plate.as_records() len(records)  # Number of wells in the plate 2 sorted(records[0].keys())  # Show the keys of the first well's dictionary ['coordinate', 'empty', 'index', 'name', 'plate_id', 'rgb_color', 'sample_type']</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def as_records(self):\n    \"\"\"\n    Convert the plate's well data into a list of dictionaries.\n\n    Each well's attributes are converted into a dictionary, and all these dictionaries\n    are compiled into a list, with one dictionary per well.\n\n    Returns:\n        list of dict: A list where each element is a dictionary representing a well's attributes.\n\n    Example:\n        &gt;&gt;&gt; plate = Plate(plate_dim=(1, 2))\n        &gt;&gt;&gt; plate[0].metadata[\"sample_type\"] = \"plasma\" # set metadata for first well\n        &gt;&gt;&gt; records = plate.as_records()\n        &gt;&gt;&gt; len(records)  # Number of wells in the plate\n        2\n        &gt;&gt;&gt; sorted(records[0].keys())  # Show the keys of the first well's dictionary\n        ['coordinate', 'empty', 'index', 'name', 'plate_id', 'rgb_color', 'sample_type']\n    \"\"\"\n    return [well.as_dict() for well in self]\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.create_alphanumerical_coordinates","title":"<code>create_alphanumerical_coordinates(rows, columns)</code>  <code>staticmethod</code>","text":"<p>Static method to create alphanumerical coordinates for the wells.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>list</code> <p>A list of row indices.</p> required <code>columns</code> <code>list</code> <p>A list of column indices.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").</p> Example <p>Plate.create_alphanumerical_coordinates([0, 1], [0, 1, 2]) ['A1', 'A2', 'A3', 'B1', 'B2', 'B3'] Plate.create_alphanumerical_coordinates([0], [0, 1]) ['A1', 'A2']</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>@staticmethod\ndef create_alphanumerical_coordinates(rows, columns):\n    \"\"\"\n    Static method to create alphanumerical coordinates for the wells.\n\n    Args:\n        rows (list): A list of row indices.\n        columns (list): A list of column indices.\n\n    Returns:\n        list: A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").\n\n    Example:\n        &gt;&gt;&gt; Plate.create_alphanumerical_coordinates([0, 1], [0, 1, 2])\n        ['A1', 'A2', 'A3', 'B1', 'B2', 'B3']\n        &gt;&gt;&gt; Plate.create_alphanumerical_coordinates([0], [0, 1])\n        ['A1', 'A2']\n    \"\"\"\n    row_labels = list(string.ascii_uppercase)[:len(rows)]\n    return [f\"{row_labels[row]}{col+1}\" for row, col in itertools.product(rows, columns)]\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.create_index_coordinates","title":"<code>create_index_coordinates(rows, columns)</code>  <code>staticmethod</code>","text":"<p>Static method to create a list of index coordinates for the wells in a plate.</p> <p>The method generates a grid of coordinates, counting from left to right,  starting at the well in the top left. It is used to map the wells to their  respective positions in the plate.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>iterable</code> <p>An iterable representing the rows of the plate.</p> required <code>columns</code> <code>iterable</code> <p>An iterable representing the columns of the plate.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of tuples, each representing the (row, column) index of a well.</p> Example <p>Plate.create_index_coordinates(range(2), range(2)) [(1, 0), (1, 1), (0, 0), (0, 1)]</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>@staticmethod    \ndef create_index_coordinates(rows, columns) -&gt; list:\n    \"\"\"\n    Static method to create a list of index coordinates for the wells in a plate.\n\n    The method generates a grid of coordinates, counting from left to right, \n    starting at the well in the top left. It is used to map the wells to their \n    respective positions in the plate.\n\n    Args:\n        rows (iterable): An iterable representing the rows of the plate.\n        columns (iterable): An iterable representing the columns of the plate.\n\n    Returns:\n        list: A list of tuples, each representing the (row, column) index of a well.\n\n    Example:\n        &gt;&gt;&gt; Plate.create_index_coordinates(range(2), range(2))\n        [(1, 0), (1, 1), (0, 0), (0, 1)]\n    \"\"\"\n    # count from left to right, starting at well in top left\n    return list(itertools.product(\n                                range(len(rows)-1, -1, -1),\n                                range(0, len(columns))\n                                )\n            )\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.get_metadata","title":"<code>get_metadata(metadata_key)</code>","text":"<p>Retrieve metadata values for all wells in the plate based on the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>The metadata key for which values are to be retrieved.  If None, a default value of 'NaN' is returned for each well.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of metadata values for each well in the plate.</p> Example Source code in <code>src/plate_planner/plate.py</code> <pre><code>def get_metadata(self, metadata_key: Optional[str]) -&gt; list:\n    \"\"\"\n    Retrieve metadata values for all wells in the plate based on the specified key.\n\n    Args:\n        metadata_key (str, optional): The metadata key for which values are to be retrieved. \n            If None, a default value of 'NaN' is returned for each well.\n\n    Returns:\n        list: A list of metadata values for each well in the plate.\n\n    Example:\n        # Using a Plate with 4 wells and adding metadata for demonstration\n        &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; for well in plate.wells:\n        ...     well.metadata['sample_type'] = 'RNA'\n        &gt;&gt;&gt; plate.get_metadata('sample_type')\n        ['RNA', 'RNA', 'RNA', 'RNA']\n        &gt;&gt;&gt; plate.get_metadata('non_existing_key')  # Key not present\n        ['NaN', 'NaN', 'NaN', 'NaN']\n    \"\"\"\n    if metadata_key is None:\n        return [\"NaN\" for _ in self.wells]\n\n    metadata_values = []\n    for well in self.wells:\n        value = well.get_attribute_or_metadata(metadata_key)\n        metadata_values.append(value)\n\n    return metadata_values\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.get_metadata--using-a-plate-with-4-wells-and-adding-metadata-for-demonstration","title":"Using a Plate with 4 wells and adding metadata for demonstration","text":"<p>plate = Plate(plate_dim=(2, 2)) for well in plate.wells: ...     well.metadata['sample_type'] = 'RNA' plate.get_metadata('sample_type') ['RNA', 'RNA', 'RNA', 'RNA'] plate.get_metadata('non_existing_key')  # Key not present ['NaN', 'NaN', 'NaN', 'NaN']</p>"},{"location":"plate/#src.plate_planner.plate.Plate.get_metadata_as_numpy_array","title":"<code>get_metadata_as_numpy_array(metadata_key)</code>","text":"<p>Retrieve metadata values for all wells in a numpy array format based on the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>The metadata key for which values are to be retrieved.</p> required <p>Returns:</p> Type Description <code>object</code> <p>numpy.ndarray: A numpy array representing the metadata values for the plate's layout.</p> <p>Example:     # Using a Plate with 4 wells and adding metadata for demonstration     &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))     &gt;&gt;&gt; for well in plate.wells:     ...     well.metadata['concentration'] = 10.0     &gt;&gt;&gt; array = plate.get_metadata_as_numpy_array('concentration')     &gt;&gt;&gt; array.shape     (2, 2)     &gt;&gt;&gt; array[0, 0]  # Value in the first well     10.0</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def get_metadata_as_numpy_array(self, metadata_key : str) -&gt; object:\n    \"\"\"\n    Retrieve metadata values for all wells in a numpy array format based on the specified key.\n\n    Args:\n        metadata_key (str): The metadata key for which values are to be retrieved.\n\n    Returns:\n        numpy.ndarray: A numpy array representing the metadata values for the plate's layout.\n\n     Example:\n        # Using a Plate with 4 wells and adding metadata for demonstration\n        &gt;&gt;&gt; plate = Plate(plate_dim=(2, 2))\n        &gt;&gt;&gt; for well in plate.wells:\n        ...     well.metadata['concentration'] = 10.0\n        &gt;&gt;&gt; array = plate.get_metadata_as_numpy_array('concentration')\n        &gt;&gt;&gt; array.shape\n        (2, 2)\n        &gt;&gt;&gt; array[0, 0]  # Value in the first well\n        10.0\n    \"\"\"\n    metadata = self.get_metadata(metadata_key)\n\n    return self._to_numpy_array(metadata)\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.is_valid_metadata_key","title":"<code>is_valid_metadata_key(key)</code>","text":"<p>Check if the provided key is a valid metadata key for the Well instances in the plate.</p> <p>This method verifies whether the specified key is either a direct attribute of the Well instances or a key within their metadata dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for validity as a metadata key.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key is a valid metadata key, False otherwise.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def is_valid_metadata_key(self, key:str) -&gt; bool:\n    \"\"\"\n    Check if the provided key is a valid metadata key for the Well instances in the plate.\n\n    This method verifies whether the specified key is either a direct attribute of the Well instances\n    or a key within their metadata dictionary.\n\n    Args:\n        key (str): The key to check for validity as a metadata key.\n\n    Returns:\n        bool: True if the key is a valid metadata key, False otherwise.\n    \"\"\"\n    if not key:  # If key is None or empty\n        return False\n\n    # Check if the key is a direct attribute or in the metadata dictionary of any well\n    for well in self.wells:\n        if hasattr(well, key) or key in well.metadata:\n            return True\n\n    return False\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Plate.to_file","title":"<code>to_file(file_path=None, file_format='csv', metadata_keys=[])</code>","text":"<p>Write the plate data to a file in the specified format.</p> <p>The method supports various file formats such as CSV, TSV, and Excel. It allows  selection of specific metadata keys to be included in the output. If no file path  is specified, the file is saved in the current working directory with a default  name based on the plate ID.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path where the file will be saved.  If not specified, the file is saved in the current working directory.</p> <code>None</code> <code>file_format</code> <code>str</code> <p>The format of the file ('csv', 'tsv', 'xls').</p> <code>'csv'</code> <code>metadata_keys</code> <code>list</code> <p>A list of metadata keys to include in the file.  If empty, all metadata except those in _default_exclude_metadata are included.</p> <code>[]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported file format is specified.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def to_file(self, file_path : str = None,\n            file_format : str = \"csv\",\n            metadata_keys : list = []) -&gt; None:\n    \"\"\"\n    Write the plate data to a file in the specified format.\n\n    The method supports various file formats such as CSV, TSV, and Excel. It allows \n    selection of specific metadata keys to be included in the output. If no file path \n    is specified, the file is saved in the current working directory with a default \n    name based on the plate ID.\n\n    Args:\n        file_path (str, optional): The path where the file will be saved. \n            If not specified, the file is saved in the current working directory.\n        file_format (str, optional): The format of the file ('csv', 'tsv', 'xls').\n        metadata_keys (list, optional): A list of metadata keys to include in the file. \n            If empty, all metadata except those in _default_exclude_metadata are included.\n\n    Raises:\n        ValueError: If an unsupported file format is specified.\n    \"\"\"\n\n    if file_path is None:\n        file_name = f\"plate_{self.plate_id}.{file_format}\"\n        file_path = Path.cwd() / file_name\n    else:\n        file_path = Path(file_path)\n        if file_path.is_dir():\n            file_name = f\"plate_{self.plate_id}.{file_format}\"\n            file_path = file_path / file_name\n        else:\n            if file_path.suffix == \"\":\n                file_path = file_path.with_suffix(f\".{file_format}\")\n            else:\n                file_format = file_path.suffix.lstrip('.')\n\n    logger.info(f\"Writing to file:\\n\\t{file_path}\")\n\n    df = self.as_dataframe()\n\n    if len(metadata_keys) &gt; 0:\n        df = df[metadata_keys]\n    else:  # use all metadata except those in default_exclude_metadata\n        df = df.drop(columns=self._default_exclude_metadata)\n\n    match file_format:\n        case \"csv\":\n            df.to_csv(file_path, index=False)\n\n        case \"tsv\":\n            df.to_csv(file_path, sep=\"\\t\", index=False)\n\n        case \"xls\":\n            df.to_excel(file_path, index=False)\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate","title":"<code>QCPlate</code>","text":"<p>             Bases: <code>Plate</code></p> <p>summary Class that represents a multiwell plate where some wells can  contain quality control samples according to the scheme defined  in QC_config; either a  file or a dict following the same structure <p>Parameters:</p> Name Type Description Default <code>Plate</code> <code>_type_</code> <p>description</p> required Source code in <code>src/plate_planner/plate.py</code> <pre><code>class QCPlate(Plate):\n    \"\"\"_summary_\n    Class that represents a multiwell plate where some wells can \n    contain quality control samples according to the scheme defined \n    in QC_config; either a &lt;config_file.toml&gt; file or a dict following the same structure\n\n    Args:\n        Plate (_type_): _description_\n    \"\"\"\n\n    _non_qc_sample_code : str = \"S\"\n    _non_qc_sample_name : str = \"Specimen\"\n\n    def __init__(self, QC_config = None, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if QC_config is not None:\n\n            if isinstance(QC_config, dict):\n                self.config = QC_config\n            else:                                        \n                self.config = self.load_config_file(QC_config)\n\n            if self.config is not None: \n                self.create_QC_plate_layout()\n\n            else:\n                logger.error(f\"No scheme for QC samples provided.\")\n\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(({len(self._rows)},{len(self._columns)}), plate_id={self.plate_id})\"\n\n    def __str__(self):\n        plate_summary = f\"Plate ID: {self.plate_id}\\n\"\n        plate_summary += f\"Dimensions: {self._n_rows} rows x {self._n_columns} columns\\n\"\n        plate_summary += \"Plate Layout (Sample Codes):\\n\"\n        plate_array_str = np.array_str(self.get_metadata_as_numpy_array(\"sample_code\"))\n        plate_summary += plate_array_str\n        return plate_summary\n\n    def define_unique_QC_sequences(self):\n        \"\"\" Sets up the unique QC sequences for each round based on the new config structure. \"\"\"\n        logger.debug(\"Setting up dynamic QC scheme from config file\")\n\n        # Initialize variables\n        total_wells = self.size\n        qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n        max_rounds = total_wells // qc_round_frequency\n\n        # Step 1: Initialize sequence map\n        self.qc_sequence_map = {round_num: [] for round_num in range(1, max_rounds + 1)}\n\n        # Step 2: Apply specific round patterns\n        for key, value in self.config['QC']['patterns'].items():\n            if key.startswith('round_'):\n                round_number = int(key.split('_')[1])\n                self.qc_sequence_map[round_number] = value\n\n        # Step 3: Apply repeat pattern\n        if 'repeat' in self.config['QC']['patterns']:\n            repeat_config = self.config['QC']['patterns']['repeat_pattern']\n            pattern, times = repeat_config['pattern'], repeat_config['times']\n            for i in range(1, times + 1):\n                if not self.qc_sequence_map[i]:\n                    self.qc_sequence_map[i] = pattern\n\n        # Step 4: Apply alternating patterns\n        if 'alternating' in self.config['QC']['patterns']:\n            alternating_patterns = self.config['QC']['patterns']['alternating']\n            alt_index = 0\n            for round_num in range(1, max_rounds + 1):\n                if not self.qc_sequence_map[round_num]: \n                    self.qc_sequence_map[round_num] = alternating_patterns[alt_index % len(alternating_patterns)]\n                    alt_index += 1\n\n\n        # Log the defined sequences\n        for round_number, sequence in self.qc_sequence_map.items():\n            logger.debug(f\"Round {round_number}: {sequence}\")\n\n    def create_QC_plate_layout(self):\n        \"\"\"\n        Creates the plate layout with QC and specimen samples based on the configuration provided.\n\n        This method initializes the QC sample placement according to the unique QC sequences defined for each round.\n        It iterates over all the wells in the plate, placing QC samples at the specified intervals and filling the\n        rest with specimen samples. The method handles the transition between different rounds of QC samples and ensures\n        that each well is assigned the correct sample type metadata.\n\n        The process accounts for special configurations such as starting the plate with a QC round and adjusts the\n        placement of QC and specimen samples accordingly. If the iterator of QC samples for a given round is exhausted,\n        the method transitions to the next round's sequence of QC samples.\n\n        Attributes:\n            None directly used, but utilizes class attributes such as self.config and self.size which are set during initialization.\n\n        Raises:\n            StopIteration: An exception is caught to indicate the end of a QC sample sequence for a round,\n                        triggering the transition to the next round or switching back to specimen sample assignment.\n        \"\"\"\n        logger.info(\"Creating dynamic plate layout with QC samples.\")\n\n        self.define_unique_QC_sequences()\n\n        # Initialize counters for QC sample types and control variables for round and specimen handling\n        counts = {qc_type: 0 for qc_type in self.config[\"QC\"][\"names\"].keys()}\n        round_counter = 1\n        specimen_counter = 0\n        qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n        start_with_qc = self.config['QC']['start_with_QC_round']\n        current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n\n        # Start and End patterns have highest priority\n        # +++++++++++++++++++++++++++++++++++++++++++++++++++\n        # Pre-allocate wells for 'start' pattern\n        start_pattern = self.config['QC']['patterns'].get('start', [])\n        for i, qc_sample in enumerate(start_pattern):\n            self.assign_qc_sample_metadata(i, qc_sample, counts)\n\n        start_well_offset = len(start_pattern)\n        end_pattern = self.config['QC']['patterns'].get('end', [])\n        end_well_offset = len(end_pattern)\n\n        # Pre-allocate wells for 'end' pattern at the end of the plate\n        for i, qc_sample in enumerate(end_pattern):\n            self.assign_qc_sample_metadata(self.size - end_well_offset + i, qc_sample, counts)\n\n        # +++++++++++++++++++++++++++++++++++++++++++++++++++\n\n        current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n        # Adjust the loop to start and end accounting for 'start' and 'end' patterns\n        # for well_index in range(0, self.size - end_well_offset):\n        for well_index in range(start_well_offset, self.size - end_well_offset):\n        # for well_index in range(self.size):\n            # Handle the initial placement of QC samples if the configuration specifies starting with a QC round\n            if start_with_qc and round_counter == 1:\n                try:\n                    # Attempt to place a QC sample for the first round\n                    qc_sample = next(current_round_qc_samples)\n                    self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                    continue # Skip to the next iteration to continue placing QC samples\n                except StopIteration:\n                    # If no more QC samples are available for the current round, transition to the next round\n                    round_counter += 1\n                    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n            # Check if it's time to place a QC sample based on the specified frequency\n            if specimen_counter &gt;= qc_round_frequency:\n                try:\n                    # Place a QC sample and reset the specimen counter for the next sequence\n                    qc_sample = next(current_round_qc_samples)\n                    self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                except StopIteration:\n                    # Transition to the next round of QC samples if available, or continue with specimen placement\n                    round_counter += 1\n                    specimen_counter = 0 # Reset specimen counter as we're starting a new QC round or specimen sequence\n                    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n                    # Place a specimen sample immediately if QC samples for the new round are exhausted or not defined\n                    self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                    specimen_counter += 1\n            else:\n                # Place a specimen sample and increment the counter\n                self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                specimen_counter += 1\n\n        # Log the final layout for debugging\n        for well in self.wells:\n            logger.debug(f\"Well {well.name}: {well.metadata}\")\n\n    def assign_qc_sample_metadata(self, well_index, qc_sample, counts: dict):\n        self.wells[well_index].metadata[\"QC\"] = True\n        sample_code = qc_sample\n        counts[sample_code] += 1\n        self.wells[well_index].metadata[\"sample_code\"] = sample_code\n        self.wells[well_index].metadata[\"sample_type\"] = self.config[\"QC\"][\"names\"][sample_code]\n        self.wells[well_index].metadata[\"sample_name\"] = f\"{sample_code}{counts[sample_code]}\"\n\n    def assign_specimen_sample_metadata(self, well_index, count):\n        self.wells[well_index].metadata[\"QC\"] = False\n        self.wells[well_index].metadata[\"sample_code\"] = self._non_qc_sample_code\n        self.wells[well_index].metadata[\"sample_type\"] = self._non_qc_sample_name\n        self.wells[well_index].metadata[\"sample_name\"] = f\"{self._non_qc_sample_code}{count + 1}\"\n\n    @property\n    def capacity(self):\n        # number of non-QC samples that can be added to the plate - TODO change name?\n        return sum([not well.metadata[\"QC\"] for well in self.wells])\n\n    @staticmethod\n    def load_config_file(config_file: str = None) -&gt; dict:\n\n        # READ CONFIG FILE\n        if config_file is None: \n\n            logger.warning(\"No config file specified. Trying to find a toml file in current folder.\")\n\n            config_file_search = glob.glob(\"*.toml\")      \n\n            if config_file_search:\n                config_file = config_file_search[0]\n                logger.info(f\"Using toml file '{config_file}'\")\n\n        try:\n            with open(config_file, mode=\"rb\") as fp:\n                config = tomli.load(fp)\n\n            logger.info(f\"Successfully loaded config file {config_file}\")\n            logger.debug(f\"{config}\")\n\n            return config\n\n        except FileNotFoundError:\n            logger.error(f\"Could not find/open config file {config_file}\")\n\n            raise FileExistsError(config_file)            \n\n    class PlateFactory:\n        @staticmethod\n        def create_plate(*args, **kwargs) -&gt; Plate:\n            \"\"\"\n            Creates a plate object, deciding on the specific type of plate (SamplePlate or QCPlate)\n            based on the presence of a 'QC_config' argument.\n\n            If 'QC_config' is provided and not None, a QCPlate is created with the given QC configuration.\n            Otherwise, a SamplePlate is created. The method dynamically selects the appropriate constructor\n            based on the provided arguments.\n\n            Args:\n                *args: Positional arguments passed directly to the plate's constructor.\n                **kwargs: Keyword arguments passed directly to the plate's constructor. If 'QC_config' is\n                        among these keyword arguments and is not None, a QCPlate is instantiated. Otherwise,\n                        a SamplePlate is instantiated.\n\n            Returns:\n                Plate: An instance of either SamplePlate or QCPlate, depending on the provided arguments.\n\n            Examples:\n                &gt;&gt;&gt; sample_plate = PlateFactory.create_plate(plate_dim=(8, 12))\n                &gt;&gt;&gt; isinstance(sample_plate, SamplePlate)\n                True\n\n                &gt;&gt;&gt; # Example QC configuration for testing purposes\n                &gt;&gt;&gt; qc_config = {\n                            'QC': {\n                                'start_with_QC_round': False,\n                                'run_QC_after_n_specimens': 11,\n                                'names': {\n                                    'EC': 'EC: External_Control_(matrix)',\n                                    'PB': 'PB: Paper_Blank',\n                                    'PO': 'PO: Pooled_specimens'\n                                },\n                                'patterns': {\n                                    'alternating': [['EC', 'PB'], ['EC', 'PO']],\n                                }\n                            }\n                        }\n                &gt;&gt;&gt; qc_plate = PlateFactory.create_plate(plate_dim=(8, 12), QC_config=qc_config)\n                &gt;&gt;&gt; isinstance(qc_plate, QCPlate)\n                True\n\n                &gt;&gt;&gt; # Creating a plate without specifying 'plate_dim', default dimensions should be used\n                &gt;&gt;&gt; default_plate = PlateFactory.create_plate()\n                &gt;&gt;&gt; isinstance(default_plate, SamplePlate)\n                True\n\n            \"\"\"\n            # Check if QC scheme is provided in kwargs\n            if 'QC_config' in kwargs and kwargs['QC_config'] is not None:\n                # Create and return a QCPlate if QC configuration is provided\n                return QCPlate(*args, **kwargs)\n            else:\n                # Default to creating a SamplePlate if no QC configuration is provided\n                return SamplePlate(*args, **kwargs)\n\n\n        @staticmethod\n        def validate_qc_scheme(scheme: Union[str, Dict]) -&gt; Dict:\n            \"\"\"\n            Validates the QC scheme configuration. If a file path is provided, the method\n            reads and validates the TOML configuration file. If a dictionary is provided,\n            it directly validates the configuration.\n\n            Validation checks include:\n            - Presence of essential sections and fields.\n            - Consistency of QC sample names across sections.\n            - Format and validity of specified patterns.\n\n            Args:\n                scheme (Union[str, Dict]): Path to the QC scheme TOML file or the scheme as a dictionary.\n\n            Returns:\n                Dict: The validated and parsed QC scheme configuration.\n\n            Raises:\n                FileNotFoundError: If the TOML file does not exist.\n                ValueError: If the configuration is invalid.\n            \"\"\"\n            # Load configuration from file or use the provided dict\n            config = scheme\n            if isinstance(scheme, str):\n                scheme_path = Path(scheme)\n                if not scheme_path.exists():\n                    raise FileNotFoundError(f\"The configuration file '{scheme}' does not exist.\")\n                with scheme_path.open('rb') as f:\n                    config = tomli.load(f)\n\n            # Basic structure validation\n            if \"QC\" not in config or \"patterns\" not in config[\"QC\"] or \"names\" not in config[\"QC\"]:\n                raise ValueError(\"Invalid QC scheme configuration: Missing required sections.\")\n\n            # Validate QC names\n            qc_names = config[\"QC\"][\"names\"]\n            if not isinstance(qc_names, dict) or not qc_names:\n                raise ValueError(\"Invalid QC names configuration.\")\n\n            # Validate patterns using QC names\n            patterns = config[\"QC\"].get(\"patterns\", {})\n            for pattern_name, pattern_value in patterns.items():\n                if isinstance(pattern_value, list):\n                    # Validate each sample name in the list\n                    for sample_name in pattern_value:\n                        if sample_name not in qc_names:\n                            raise ValueError(f\"Undefined QC sample name '{sample_name}' in pattern '{pattern_name}'.\")\n                elif isinstance(pattern_value, dict) and 'pattern' in pattern_value and 'times' in pattern_value:\n                    # Validate repeat pattern format\n                    if not isinstance(pattern_value['pattern'], list) or not isinstance(pattern_value['times'], int):\n                        raise ValueError(f\"Invalid format for repeat pattern '{pattern_name}'.\")\n                    for sample_name in pattern_value['pattern']:\n                        if sample_name not in qc_names:\n                            raise ValueError(f\"Undefined QC sample name '{sample_name}' in repeat pattern '{pattern_name}'.\")\n                else:\n                    raise ValueError(f\"Invalid pattern format for '{pattern_name}'.\")\n\n            # Additional checks for 'start_with_QC_round' and 'run_QC_after_n_specimens'\n            if not isinstance(config[\"QC\"].get(\"start_with_QC_round\"), bool):\n                raise ValueError(\"Invalid or missing 'start_with_QC_round' flag.\")\n            if not isinstance(config[\"QC\"].get(\"run_QC_after_n_specimens\"), int):\n                raise ValueError(\"Invalid or missing 'run_QC_after_n_specimens' value.\")\n\n            return config\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate.PlateFactory","title":"<code>PlateFactory</code>","text":"Source code in <code>src/plate_planner/plate.py</code> <pre><code>class PlateFactory:\n    @staticmethod\n    def create_plate(*args, **kwargs) -&gt; Plate:\n        \"\"\"\n        Creates a plate object, deciding on the specific type of plate (SamplePlate or QCPlate)\n        based on the presence of a 'QC_config' argument.\n\n        If 'QC_config' is provided and not None, a QCPlate is created with the given QC configuration.\n        Otherwise, a SamplePlate is created. The method dynamically selects the appropriate constructor\n        based on the provided arguments.\n\n        Args:\n            *args: Positional arguments passed directly to the plate's constructor.\n            **kwargs: Keyword arguments passed directly to the plate's constructor. If 'QC_config' is\n                    among these keyword arguments and is not None, a QCPlate is instantiated. Otherwise,\n                    a SamplePlate is instantiated.\n\n        Returns:\n            Plate: An instance of either SamplePlate or QCPlate, depending on the provided arguments.\n\n        Examples:\n            &gt;&gt;&gt; sample_plate = PlateFactory.create_plate(plate_dim=(8, 12))\n            &gt;&gt;&gt; isinstance(sample_plate, SamplePlate)\n            True\n\n            &gt;&gt;&gt; # Example QC configuration for testing purposes\n            &gt;&gt;&gt; qc_config = {\n                        'QC': {\n                            'start_with_QC_round': False,\n                            'run_QC_after_n_specimens': 11,\n                            'names': {\n                                'EC': 'EC: External_Control_(matrix)',\n                                'PB': 'PB: Paper_Blank',\n                                'PO': 'PO: Pooled_specimens'\n                            },\n                            'patterns': {\n                                'alternating': [['EC', 'PB'], ['EC', 'PO']],\n                            }\n                        }\n                    }\n            &gt;&gt;&gt; qc_plate = PlateFactory.create_plate(plate_dim=(8, 12), QC_config=qc_config)\n            &gt;&gt;&gt; isinstance(qc_plate, QCPlate)\n            True\n\n            &gt;&gt;&gt; # Creating a plate without specifying 'plate_dim', default dimensions should be used\n            &gt;&gt;&gt; default_plate = PlateFactory.create_plate()\n            &gt;&gt;&gt; isinstance(default_plate, SamplePlate)\n            True\n\n        \"\"\"\n        # Check if QC scheme is provided in kwargs\n        if 'QC_config' in kwargs and kwargs['QC_config'] is not None:\n            # Create and return a QCPlate if QC configuration is provided\n            return QCPlate(*args, **kwargs)\n        else:\n            # Default to creating a SamplePlate if no QC configuration is provided\n            return SamplePlate(*args, **kwargs)\n\n\n    @staticmethod\n    def validate_qc_scheme(scheme: Union[str, Dict]) -&gt; Dict:\n        \"\"\"\n        Validates the QC scheme configuration. If a file path is provided, the method\n        reads and validates the TOML configuration file. If a dictionary is provided,\n        it directly validates the configuration.\n\n        Validation checks include:\n        - Presence of essential sections and fields.\n        - Consistency of QC sample names across sections.\n        - Format and validity of specified patterns.\n\n        Args:\n            scheme (Union[str, Dict]): Path to the QC scheme TOML file or the scheme as a dictionary.\n\n        Returns:\n            Dict: The validated and parsed QC scheme configuration.\n\n        Raises:\n            FileNotFoundError: If the TOML file does not exist.\n            ValueError: If the configuration is invalid.\n        \"\"\"\n        # Load configuration from file or use the provided dict\n        config = scheme\n        if isinstance(scheme, str):\n            scheme_path = Path(scheme)\n            if not scheme_path.exists():\n                raise FileNotFoundError(f\"The configuration file '{scheme}' does not exist.\")\n            with scheme_path.open('rb') as f:\n                config = tomli.load(f)\n\n        # Basic structure validation\n        if \"QC\" not in config or \"patterns\" not in config[\"QC\"] or \"names\" not in config[\"QC\"]:\n            raise ValueError(\"Invalid QC scheme configuration: Missing required sections.\")\n\n        # Validate QC names\n        qc_names = config[\"QC\"][\"names\"]\n        if not isinstance(qc_names, dict) or not qc_names:\n            raise ValueError(\"Invalid QC names configuration.\")\n\n        # Validate patterns using QC names\n        patterns = config[\"QC\"].get(\"patterns\", {})\n        for pattern_name, pattern_value in patterns.items():\n            if isinstance(pattern_value, list):\n                # Validate each sample name in the list\n                for sample_name in pattern_value:\n                    if sample_name not in qc_names:\n                        raise ValueError(f\"Undefined QC sample name '{sample_name}' in pattern '{pattern_name}'.\")\n            elif isinstance(pattern_value, dict) and 'pattern' in pattern_value and 'times' in pattern_value:\n                # Validate repeat pattern format\n                if not isinstance(pattern_value['pattern'], list) or not isinstance(pattern_value['times'], int):\n                    raise ValueError(f\"Invalid format for repeat pattern '{pattern_name}'.\")\n                for sample_name in pattern_value['pattern']:\n                    if sample_name not in qc_names:\n                        raise ValueError(f\"Undefined QC sample name '{sample_name}' in repeat pattern '{pattern_name}'.\")\n            else:\n                raise ValueError(f\"Invalid pattern format for '{pattern_name}'.\")\n\n        # Additional checks for 'start_with_QC_round' and 'run_QC_after_n_specimens'\n        if not isinstance(config[\"QC\"].get(\"start_with_QC_round\"), bool):\n            raise ValueError(\"Invalid or missing 'start_with_QC_round' flag.\")\n        if not isinstance(config[\"QC\"].get(\"run_QC_after_n_specimens\"), int):\n            raise ValueError(\"Invalid or missing 'run_QC_after_n_specimens' value.\")\n\n        return config\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate.PlateFactory.create_plate","title":"<code>create_plate(*args, **kwargs)</code>  <code>staticmethod</code>","text":"<p>Creates a plate object, deciding on the specific type of plate (SamplePlate or QCPlate) based on the presence of a 'QC_config' argument.</p> <p>If 'QC_config' is provided and not None, a QCPlate is created with the given QC configuration. Otherwise, a SamplePlate is created. The method dynamically selects the appropriate constructor based on the provided arguments.</p> <p>Parameters:</p> Name Type Description Default <code>*args</code> <p>Positional arguments passed directly to the plate's constructor.</p> <code>()</code> <code>**kwargs</code> <p>Keyword arguments passed directly to the plate's constructor. If 'QC_config' is     among these keyword arguments and is not None, a QCPlate is instantiated. Otherwise,     a SamplePlate is instantiated.</p> <code>{}</code> <p>Returns:</p> Name Type Description <code>Plate</code> <code>Plate</code> <p>An instance of either SamplePlate or QCPlate, depending on the provided arguments.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; sample_plate = PlateFactory.create_plate(plate_dim=(8, 12))\n&gt;&gt;&gt; isinstance(sample_plate, SamplePlate)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; # Example QC configuration for testing purposes\n&gt;&gt;&gt; qc_config = {\n            'QC': {\n                'start_with_QC_round': False,\n                'run_QC_after_n_specimens': 11,\n                'names': {\n                    'EC': 'EC: External_Control_(matrix)',\n                    'PB': 'PB: Paper_Blank',\n                    'PO': 'PO: Pooled_specimens'\n                },\n                'patterns': {\n                    'alternating': [['EC', 'PB'], ['EC', 'PO']],\n                }\n            }\n        }\n&gt;&gt;&gt; qc_plate = PlateFactory.create_plate(plate_dim=(8, 12), QC_config=qc_config)\n&gt;&gt;&gt; isinstance(qc_plate, QCPlate)\nTrue\n</code></pre> <pre><code>&gt;&gt;&gt; # Creating a plate without specifying 'plate_dim', default dimensions should be used\n&gt;&gt;&gt; default_plate = PlateFactory.create_plate()\n&gt;&gt;&gt; isinstance(default_plate, SamplePlate)\nTrue\n</code></pre> Source code in <code>src/plate_planner/plate.py</code> <pre><code>@staticmethod\ndef create_plate(*args, **kwargs) -&gt; Plate:\n    \"\"\"\n    Creates a plate object, deciding on the specific type of plate (SamplePlate or QCPlate)\n    based on the presence of a 'QC_config' argument.\n\n    If 'QC_config' is provided and not None, a QCPlate is created with the given QC configuration.\n    Otherwise, a SamplePlate is created. The method dynamically selects the appropriate constructor\n    based on the provided arguments.\n\n    Args:\n        *args: Positional arguments passed directly to the plate's constructor.\n        **kwargs: Keyword arguments passed directly to the plate's constructor. If 'QC_config' is\n                among these keyword arguments and is not None, a QCPlate is instantiated. Otherwise,\n                a SamplePlate is instantiated.\n\n    Returns:\n        Plate: An instance of either SamplePlate or QCPlate, depending on the provided arguments.\n\n    Examples:\n        &gt;&gt;&gt; sample_plate = PlateFactory.create_plate(plate_dim=(8, 12))\n        &gt;&gt;&gt; isinstance(sample_plate, SamplePlate)\n        True\n\n        &gt;&gt;&gt; # Example QC configuration for testing purposes\n        &gt;&gt;&gt; qc_config = {\n                    'QC': {\n                        'start_with_QC_round': False,\n                        'run_QC_after_n_specimens': 11,\n                        'names': {\n                            'EC': 'EC: External_Control_(matrix)',\n                            'PB': 'PB: Paper_Blank',\n                            'PO': 'PO: Pooled_specimens'\n                        },\n                        'patterns': {\n                            'alternating': [['EC', 'PB'], ['EC', 'PO']],\n                        }\n                    }\n                }\n        &gt;&gt;&gt; qc_plate = PlateFactory.create_plate(plate_dim=(8, 12), QC_config=qc_config)\n        &gt;&gt;&gt; isinstance(qc_plate, QCPlate)\n        True\n\n        &gt;&gt;&gt; # Creating a plate without specifying 'plate_dim', default dimensions should be used\n        &gt;&gt;&gt; default_plate = PlateFactory.create_plate()\n        &gt;&gt;&gt; isinstance(default_plate, SamplePlate)\n        True\n\n    \"\"\"\n    # Check if QC scheme is provided in kwargs\n    if 'QC_config' in kwargs and kwargs['QC_config'] is not None:\n        # Create and return a QCPlate if QC configuration is provided\n        return QCPlate(*args, **kwargs)\n    else:\n        # Default to creating a SamplePlate if no QC configuration is provided\n        return SamplePlate(*args, **kwargs)\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate.PlateFactory.validate_qc_scheme","title":"<code>validate_qc_scheme(scheme)</code>  <code>staticmethod</code>","text":"<p>Validates the QC scheme configuration. If a file path is provided, the method reads and validates the TOML configuration file. If a dictionary is provided, it directly validates the configuration.</p> <p>Validation checks include: - Presence of essential sections and fields. - Consistency of QC sample names across sections. - Format and validity of specified patterns.</p> <p>Parameters:</p> Name Type Description Default <code>scheme</code> <code>Union[str, Dict]</code> <p>Path to the QC scheme TOML file or the scheme as a dictionary.</p> required <p>Returns:</p> Name Type Description <code>Dict</code> <code>Dict</code> <p>The validated and parsed QC scheme configuration.</p> <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the TOML file does not exist.</p> <code>ValueError</code> <p>If the configuration is invalid.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>@staticmethod\ndef validate_qc_scheme(scheme: Union[str, Dict]) -&gt; Dict:\n    \"\"\"\n    Validates the QC scheme configuration. If a file path is provided, the method\n    reads and validates the TOML configuration file. If a dictionary is provided,\n    it directly validates the configuration.\n\n    Validation checks include:\n    - Presence of essential sections and fields.\n    - Consistency of QC sample names across sections.\n    - Format and validity of specified patterns.\n\n    Args:\n        scheme (Union[str, Dict]): Path to the QC scheme TOML file or the scheme as a dictionary.\n\n    Returns:\n        Dict: The validated and parsed QC scheme configuration.\n\n    Raises:\n        FileNotFoundError: If the TOML file does not exist.\n        ValueError: If the configuration is invalid.\n    \"\"\"\n    # Load configuration from file or use the provided dict\n    config = scheme\n    if isinstance(scheme, str):\n        scheme_path = Path(scheme)\n        if not scheme_path.exists():\n            raise FileNotFoundError(f\"The configuration file '{scheme}' does not exist.\")\n        with scheme_path.open('rb') as f:\n            config = tomli.load(f)\n\n    # Basic structure validation\n    if \"QC\" not in config or \"patterns\" not in config[\"QC\"] or \"names\" not in config[\"QC\"]:\n        raise ValueError(\"Invalid QC scheme configuration: Missing required sections.\")\n\n    # Validate QC names\n    qc_names = config[\"QC\"][\"names\"]\n    if not isinstance(qc_names, dict) or not qc_names:\n        raise ValueError(\"Invalid QC names configuration.\")\n\n    # Validate patterns using QC names\n    patterns = config[\"QC\"].get(\"patterns\", {})\n    for pattern_name, pattern_value in patterns.items():\n        if isinstance(pattern_value, list):\n            # Validate each sample name in the list\n            for sample_name in pattern_value:\n                if sample_name not in qc_names:\n                    raise ValueError(f\"Undefined QC sample name '{sample_name}' in pattern '{pattern_name}'.\")\n        elif isinstance(pattern_value, dict) and 'pattern' in pattern_value and 'times' in pattern_value:\n            # Validate repeat pattern format\n            if not isinstance(pattern_value['pattern'], list) or not isinstance(pattern_value['times'], int):\n                raise ValueError(f\"Invalid format for repeat pattern '{pattern_name}'.\")\n            for sample_name in pattern_value['pattern']:\n                if sample_name not in qc_names:\n                    raise ValueError(f\"Undefined QC sample name '{sample_name}' in repeat pattern '{pattern_name}'.\")\n        else:\n            raise ValueError(f\"Invalid pattern format for '{pattern_name}'.\")\n\n    # Additional checks for 'start_with_QC_round' and 'run_QC_after_n_specimens'\n    if not isinstance(config[\"QC\"].get(\"start_with_QC_round\"), bool):\n        raise ValueError(\"Invalid or missing 'start_with_QC_round' flag.\")\n    if not isinstance(config[\"QC\"].get(\"run_QC_after_n_specimens\"), int):\n        raise ValueError(\"Invalid or missing 'run_QC_after_n_specimens' value.\")\n\n    return config\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate.create_QC_plate_layout","title":"<code>create_QC_plate_layout()</code>","text":"<p>Creates the plate layout with QC and specimen samples based on the configuration provided.</p> <p>This method initializes the QC sample placement according to the unique QC sequences defined for each round. It iterates over all the wells in the plate, placing QC samples at the specified intervals and filling the rest with specimen samples. The method handles the transition between different rounds of QC samples and ensures that each well is assigned the correct sample type metadata.</p> <p>The process accounts for special configurations such as starting the plate with a QC round and adjusts the placement of QC and specimen samples accordingly. If the iterator of QC samples for a given round is exhausted, the method transitions to the next round's sequence of QC samples.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>An exception is caught to indicate the end of a QC sample sequence for a round,         triggering the transition to the next round or switching back to specimen sample assignment.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def create_QC_plate_layout(self):\n    \"\"\"\n    Creates the plate layout with QC and specimen samples based on the configuration provided.\n\n    This method initializes the QC sample placement according to the unique QC sequences defined for each round.\n    It iterates over all the wells in the plate, placing QC samples at the specified intervals and filling the\n    rest with specimen samples. The method handles the transition between different rounds of QC samples and ensures\n    that each well is assigned the correct sample type metadata.\n\n    The process accounts for special configurations such as starting the plate with a QC round and adjusts the\n    placement of QC and specimen samples accordingly. If the iterator of QC samples for a given round is exhausted,\n    the method transitions to the next round's sequence of QC samples.\n\n    Attributes:\n        None directly used, but utilizes class attributes such as self.config and self.size which are set during initialization.\n\n    Raises:\n        StopIteration: An exception is caught to indicate the end of a QC sample sequence for a round,\n                    triggering the transition to the next round or switching back to specimen sample assignment.\n    \"\"\"\n    logger.info(\"Creating dynamic plate layout with QC samples.\")\n\n    self.define_unique_QC_sequences()\n\n    # Initialize counters for QC sample types and control variables for round and specimen handling\n    counts = {qc_type: 0 for qc_type in self.config[\"QC\"][\"names\"].keys()}\n    round_counter = 1\n    specimen_counter = 0\n    qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n    start_with_qc = self.config['QC']['start_with_QC_round']\n    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n\n    # Start and End patterns have highest priority\n    # +++++++++++++++++++++++++++++++++++++++++++++++++++\n    # Pre-allocate wells for 'start' pattern\n    start_pattern = self.config['QC']['patterns'].get('start', [])\n    for i, qc_sample in enumerate(start_pattern):\n        self.assign_qc_sample_metadata(i, qc_sample, counts)\n\n    start_well_offset = len(start_pattern)\n    end_pattern = self.config['QC']['patterns'].get('end', [])\n    end_well_offset = len(end_pattern)\n\n    # Pre-allocate wells for 'end' pattern at the end of the plate\n    for i, qc_sample in enumerate(end_pattern):\n        self.assign_qc_sample_metadata(self.size - end_well_offset + i, qc_sample, counts)\n\n    # +++++++++++++++++++++++++++++++++++++++++++++++++++\n\n    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n    # Adjust the loop to start and end accounting for 'start' and 'end' patterns\n    # for well_index in range(0, self.size - end_well_offset):\n    for well_index in range(start_well_offset, self.size - end_well_offset):\n    # for well_index in range(self.size):\n        # Handle the initial placement of QC samples if the configuration specifies starting with a QC round\n        if start_with_qc and round_counter == 1:\n            try:\n                # Attempt to place a QC sample for the first round\n                qc_sample = next(current_round_qc_samples)\n                self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                continue # Skip to the next iteration to continue placing QC samples\n            except StopIteration:\n                # If no more QC samples are available for the current round, transition to the next round\n                round_counter += 1\n                current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n        # Check if it's time to place a QC sample based on the specified frequency\n        if specimen_counter &gt;= qc_round_frequency:\n            try:\n                # Place a QC sample and reset the specimen counter for the next sequence\n                qc_sample = next(current_round_qc_samples)\n                self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n            except StopIteration:\n                # Transition to the next round of QC samples if available, or continue with specimen placement\n                round_counter += 1\n                specimen_counter = 0 # Reset specimen counter as we're starting a new QC round or specimen sequence\n                current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n                # Place a specimen sample immediately if QC samples for the new round are exhausted or not defined\n                self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                specimen_counter += 1\n        else:\n            # Place a specimen sample and increment the counter\n            self.assign_specimen_sample_metadata(well_index, specimen_counter)\n            specimen_counter += 1\n\n    # Log the final layout for debugging\n    for well in self.wells:\n        logger.debug(f\"Well {well.name}: {well.metadata}\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.QCPlate.define_unique_QC_sequences","title":"<code>define_unique_QC_sequences()</code>","text":"<p>Sets up the unique QC sequences for each round based on the new config structure.</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def define_unique_QC_sequences(self):\n    \"\"\" Sets up the unique QC sequences for each round based on the new config structure. \"\"\"\n    logger.debug(\"Setting up dynamic QC scheme from config file\")\n\n    # Initialize variables\n    total_wells = self.size\n    qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n    max_rounds = total_wells // qc_round_frequency\n\n    # Step 1: Initialize sequence map\n    self.qc_sequence_map = {round_num: [] for round_num in range(1, max_rounds + 1)}\n\n    # Step 2: Apply specific round patterns\n    for key, value in self.config['QC']['patterns'].items():\n        if key.startswith('round_'):\n            round_number = int(key.split('_')[1])\n            self.qc_sequence_map[round_number] = value\n\n    # Step 3: Apply repeat pattern\n    if 'repeat' in self.config['QC']['patterns']:\n        repeat_config = self.config['QC']['patterns']['repeat_pattern']\n        pattern, times = repeat_config['pattern'], repeat_config['times']\n        for i in range(1, times + 1):\n            if not self.qc_sequence_map[i]:\n                self.qc_sequence_map[i] = pattern\n\n    # Step 4: Apply alternating patterns\n    if 'alternating' in self.config['QC']['patterns']:\n        alternating_patterns = self.config['QC']['patterns']['alternating']\n        alt_index = 0\n        for round_num in range(1, max_rounds + 1):\n            if not self.qc_sequence_map[round_num]: \n                self.qc_sequence_map[round_num] = alternating_patterns[alt_index % len(alternating_patterns)]\n                alt_index += 1\n\n\n    # Log the defined sequences\n    for round_number, sequence in self.qc_sequence_map.items():\n        logger.debug(f\"Round {round_number}: {sequence}\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well","title":"<code>Well</code>  <code>dataclass</code>","text":"<p>A class to represent a well in a multiwell plate.</p> <p>This class provides functionalities to represent and manipulate the properties  of a well, including its name, plate ID, coordinate, index, color, and metadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the well (default: \"A1\").</p> <code>plate_id</code> <code>int</code> <p>The ID of the plate the well belongs to (default: 1).</p> <code>coordinate</code> <code>Tuple[int, int]</code> <p>The (row, column) coordinate of the well in the plate (default: (0, 0)).</p> <code>index</code> <code>int</code> <p>The index of the well (optional).</p> <code>rgb_color</code> <code>Tuple[float, float, float]</code> <p>The RGB color representation of the well (default: (1, 1, 1)).</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata for the well (default: empty dictionary).</p> Example <p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 6), index=13,) well Well(name='B2', plate_id=2, coordinate=(1, 6), index=13, empty=True, rgb_color=(1, 1, 1), metadata={})</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>@dataclass\nclass Well:\n    \"\"\"\n    A class to represent a well in a multiwell plate.\n\n    This class provides functionalities to represent and manipulate the properties \n    of a well, including its name, plate ID, coordinate, index, color, and metadata.\n\n    Attributes:\n        name (str): The name of the well (default: \"A1\").\n        plate_id (int): The ID of the plate the well belongs to (default: 1).\n        coordinate (Tuple[int, int]): The (row, column) coordinate of the well in the plate (default: (0, 0)).\n        index (int): The index of the well (optional).\n        rgb_color (Tuple[float, float, float]): The RGB color representation of the well (default: (1, 1, 1)).\n        metadata (Dict[str, Any]): Additional metadata for the well (default: empty dictionary).\n\n    Example:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 6), index=13,)\n        &gt;&gt;&gt; well\n        Well(name='B2', plate_id=2, coordinate=(1, 6), index=13, empty=True, rgb_color=(1, 1, 1), metadata={})\n\n    \"\"\"\n    name: str = \"A1\"\n    plate_id: int = 1\n    coordinate: Tuple[int, int] = field(default_factory=lambda: (0, 0))\n    index: int = 0\n    empty: bool = True\n    rgb_color: Tuple[float, float, float] = field(default_factory=lambda: (1, 1, 1))\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    def __repr__(self):\n        \"\"\"\n        Provide an unambiguous string representation of the Well object.\n\n        Returns:\n            str: A string representation of the well.\n\n        Example:\n            &gt;&gt;&gt; well = Well(name=\"B3\", plate_id=2, coordinate=(1, 2), index=3)\n            &gt;&gt;&gt; repr(well)\n            \"Well(name='B3', plate_id=2, coordinate=(1, 2), index=3, empty=True, rgb_color=(1, 1, 1), metadata={})\"\n        \"\"\"\n        return (f\"Well(name='{self.name}', plate_id={self.plate_id}, \"\n                f\"coordinate={self.coordinate}, index={self.index}, \"\n                f\"empty={self.empty}, rgb_color={self.rgb_color}, metadata={self.metadata})\")\n\n    def __eq__(self, other):\n        \"\"\"\n        Compare this Well object with another for equality.\n\n        Args:\n            other (Well): Another Well object to compare with.\n\n        Returns:\n            bool: True if both Well objects are considered equal, False otherwise.\n\n        Example:\n            &gt;&gt;&gt; well1 = Well(name=\"A1\", plate_id=1)\n            &gt;&gt;&gt; well2 = Well(name=\"A1\", plate_id=1)\n            &gt;&gt;&gt; well3 = Well(name=\"B1\", plate_id=1)\n            &gt;&gt;&gt; well4 = Well(name=\"A1\", plate_id=2)\n            &gt;&gt;&gt; well1 == well2\n            True\n            &gt;&gt;&gt; well1 == well3\n            False\n            &gt;&gt;&gt; well4 == well1\n            False\n        \"\"\"\n        if isinstance(other, Well):\n            return (self.name == other.name and self.plate_id == other.plate_id\n                    and self.coordinate == other.coordinate\n                    and self.index == other.index and self.empty == other.empty\n                    and self.rgb_color == other.rgb_color and self.metadata == other.metadata)\n        return False\n\n    def as_dict(self):\n        \"\"\"\n        Converts the well object to a dictionary.\n\n        The method returns a dictionary representation of the well object with the \n        direct attributes of the well and the keys in the metadata attribute.\n\n        Returns:\n            dict: A dictionary representation of the well object.\n\n        Example:\n            Convert a Well instance to a dictionary:\n            &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 6), index=13, rgb_color=(0.5, 0.5, 0.5))\n            &gt;&gt;&gt; well_dict = well.as_dict()\n            &gt;&gt;&gt; print(well_dict)\n            {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 6), 'index': 13, 'empty': True, 'rgb_color': (0.5, 0.5, 0.5)}\n\n        \"\"\"\n        attrib_dict = asdict(self)\n        del attrib_dict[\"metadata\"]\n        attrib_dict.update(self.metadata)\n\n        return attrib_dict\n\n    def get_attribute_or_metadata(self, key: str):\n        \"\"\"\n        Get the value of a direct attribute or a key in the metadata dictionary.\n\n        This method first checks if the provided key corresponds to a direct \n        attribute of the well object. If not, it then checks if the key exists \n        in the metadata dictionary.\n\n        Args:\n            key (str): The attribute name or metadata key.\n\n        Returns:\n            Any: The value of the attribute or metadata key, if found. Returns 'NaN' if not found.\n\n        Example:\n        # Retrieve attribute and metadata values from a Well instance:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n        &gt;&gt;&gt; well.metadata = {\"sample_type\": \"plasma\"}    \n        &gt;&gt;&gt; well.get_attribute_or_metadata(\"plate_id\")\n        2\n        &gt;&gt;&gt; well.get_attribute_or_metadata(\"sample_type\")\n        'plasma'\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key, \"NaN\")\n            # return getattr(self, key, \"\")\n\n        # Check if it's a key in metadata\n        return self.metadata.get(key, \"NaN\")\n        # return self.metadata.get(key, \"\")\n\n    def set_attribute_or_metadata(self, key: str, value: Any):\n        \"\"\"\n        Set the value of a direct attribute or a key in the metadata dictionary.\n\n        This method first checks if the provided key corresponds to a direct \n        attribute of the well object. If so, it sets the value of that attribute. \n        If not, it then updates or adds the key-value pair in the metadata dictionary.\n\n        Args:\n            key (str): The attribute name or metadata key.\n            value (Any): The value to be set for the attribute or metadata key.\n\n        Example:\n        # Set attribute and metadata values for a Well instance:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n        &gt;&gt;&gt; well.set_attribute_or_metadata(\"plate_id\", 3)\n        &gt;&gt;&gt; well.set_attribute_or_metadata(\"sample_type\", \"serum\")\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            setattr(self, key, value)\n        else:\n            # Set/Add a key-value pair in metadata\n            self.metadata[key] = value\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well.__eq__","title":"<code>__eq__(other)</code>","text":"<p>Compare this Well object with another for equality.</p> <p>Parameters:</p> Name Type Description Default <code>other</code> <code>Well</code> <p>Another Well object to compare with.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <p>True if both Well objects are considered equal, False otherwise.</p> Example <p>well1 = Well(name=\"A1\", plate_id=1) well2 = Well(name=\"A1\", plate_id=1) well3 = Well(name=\"B1\", plate_id=1) well4 = Well(name=\"A1\", plate_id=2) well1 == well2 True well1 == well3 False well4 == well1 False</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __eq__(self, other):\n    \"\"\"\n    Compare this Well object with another for equality.\n\n    Args:\n        other (Well): Another Well object to compare with.\n\n    Returns:\n        bool: True if both Well objects are considered equal, False otherwise.\n\n    Example:\n        &gt;&gt;&gt; well1 = Well(name=\"A1\", plate_id=1)\n        &gt;&gt;&gt; well2 = Well(name=\"A1\", plate_id=1)\n        &gt;&gt;&gt; well3 = Well(name=\"B1\", plate_id=1)\n        &gt;&gt;&gt; well4 = Well(name=\"A1\", plate_id=2)\n        &gt;&gt;&gt; well1 == well2\n        True\n        &gt;&gt;&gt; well1 == well3\n        False\n        &gt;&gt;&gt; well4 == well1\n        False\n    \"\"\"\n    if isinstance(other, Well):\n        return (self.name == other.name and self.plate_id == other.plate_id\n                and self.coordinate == other.coordinate\n                and self.index == other.index and self.empty == other.empty\n                and self.rgb_color == other.rgb_color and self.metadata == other.metadata)\n    return False\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well.__repr__","title":"<code>__repr__()</code>","text":"<p>Provide an unambiguous string representation of the Well object.</p> <p>Returns:</p> Name Type Description <code>str</code> <p>A string representation of the well.</p> Example <p>well = Well(name=\"B3\", plate_id=2, coordinate=(1, 2), index=3) repr(well) \"Well(name='B3', plate_id=2, coordinate=(1, 2), index=3, empty=True, rgb_color=(1, 1, 1), metadata={})\"</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def __repr__(self):\n    \"\"\"\n    Provide an unambiguous string representation of the Well object.\n\n    Returns:\n        str: A string representation of the well.\n\n    Example:\n        &gt;&gt;&gt; well = Well(name=\"B3\", plate_id=2, coordinate=(1, 2), index=3)\n        &gt;&gt;&gt; repr(well)\n        \"Well(name='B3', plate_id=2, coordinate=(1, 2), index=3, empty=True, rgb_color=(1, 1, 1), metadata={})\"\n    \"\"\"\n    return (f\"Well(name='{self.name}', plate_id={self.plate_id}, \"\n            f\"coordinate={self.coordinate}, index={self.index}, \"\n            f\"empty={self.empty}, rgb_color={self.rgb_color}, metadata={self.metadata})\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well.as_dict","title":"<code>as_dict()</code>","text":"<p>Converts the well object to a dictionary.</p> <p>The method returns a dictionary representation of the well object with the  direct attributes of the well and the keys in the metadata attribute.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the well object.</p> Example <p>Convert a Well instance to a dictionary:</p> <p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 6), index=13, rgb_color=(0.5, 0.5, 0.5)) well_dict = well.as_dict() print(well_dict) {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 6), 'index': 13, 'empty': True, 'rgb_color': (0.5, 0.5, 0.5)}</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def as_dict(self):\n    \"\"\"\n    Converts the well object to a dictionary.\n\n    The method returns a dictionary representation of the well object with the \n    direct attributes of the well and the keys in the metadata attribute.\n\n    Returns:\n        dict: A dictionary representation of the well object.\n\n    Example:\n        Convert a Well instance to a dictionary:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 6), index=13, rgb_color=(0.5, 0.5, 0.5))\n        &gt;&gt;&gt; well_dict = well.as_dict()\n        &gt;&gt;&gt; print(well_dict)\n        {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 6), 'index': 13, 'empty': True, 'rgb_color': (0.5, 0.5, 0.5)}\n\n    \"\"\"\n    attrib_dict = asdict(self)\n    del attrib_dict[\"metadata\"]\n    attrib_dict.update(self.metadata)\n\n    return attrib_dict\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well.get_attribute_or_metadata","title":"<code>get_attribute_or_metadata(key)</code>","text":"<p>Get the value of a direct attribute or a key in the metadata dictionary.</p> <p>This method first checks if the provided key corresponds to a direct  attribute of the well object. If not, it then checks if the key exists  in the metadata dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute name or metadata key.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the attribute or metadata key, if found. Returns 'NaN' if not found.</p> <p>Example:</p>"},{"location":"plate/#src.plate_planner.plate.Well.get_attribute_or_metadata--retrieve-attribute-and-metadata-values-from-a-well-instance","title":"Retrieve attribute and metadata values from a Well instance:","text":"<p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5)) well.metadata = {\"sample_type\": \"plasma\"}   well.get_attribute_or_metadata(\"plate_id\") 2 well.get_attribute_or_metadata(\"sample_type\") 'plasma'</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def get_attribute_or_metadata(self, key: str):\n    \"\"\"\n    Get the value of a direct attribute or a key in the metadata dictionary.\n\n    This method first checks if the provided key corresponds to a direct \n    attribute of the well object. If not, it then checks if the key exists \n    in the metadata dictionary.\n\n    Args:\n        key (str): The attribute name or metadata key.\n\n    Returns:\n        Any: The value of the attribute or metadata key, if found. Returns 'NaN' if not found.\n\n    Example:\n    # Retrieve attribute and metadata values from a Well instance:\n    &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n    &gt;&gt;&gt; well.metadata = {\"sample_type\": \"plasma\"}    \n    &gt;&gt;&gt; well.get_attribute_or_metadata(\"plate_id\")\n    2\n    &gt;&gt;&gt; well.get_attribute_or_metadata(\"sample_type\")\n    'plasma'\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key, \"NaN\")\n        # return getattr(self, key, \"\")\n\n    # Check if it's a key in metadata\n    return self.metadata.get(key, \"NaN\")\n</code></pre>"},{"location":"plate/#src.plate_planner.plate.Well.set_attribute_or_metadata","title":"<code>set_attribute_or_metadata(key, value)</code>","text":"<p>Set the value of a direct attribute or a key in the metadata dictionary.</p> <p>This method first checks if the provided key corresponds to a direct  attribute of the well object. If so, it sets the value of that attribute.  If not, it then updates or adds the key-value pair in the metadata dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute name or metadata key.</p> required <code>value</code> <code>Any</code> <p>The value to be set for the attribute or metadata key.</p> required <p>Example:</p>"},{"location":"plate/#src.plate_planner.plate.Well.set_attribute_or_metadata--set-attribute-and-metadata-values-for-a-well-instance","title":"Set attribute and metadata values for a Well instance:","text":"<p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5)) well.set_attribute_or_metadata(\"plate_id\", 3) well.set_attribute_or_metadata(\"sample_type\", \"serum\")</p> Source code in <code>src/plate_planner/plate.py</code> <pre><code>def set_attribute_or_metadata(self, key: str, value: Any):\n    \"\"\"\n    Set the value of a direct attribute or a key in the metadata dictionary.\n\n    This method first checks if the provided key corresponds to a direct \n    attribute of the well object. If so, it sets the value of that attribute. \n    If not, it then updates or adds the key-value pair in the metadata dictionary.\n\n    Args:\n        key (str): The attribute name or metadata key.\n        value (Any): The value to be set for the attribute or metadata key.\n\n    Example:\n    # Set attribute and metadata values for a Well instance:\n    &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n    &gt;&gt;&gt; well.set_attribute_or_metadata(\"plate_id\", 3)\n    &gt;&gt;&gt; well.set_attribute_or_metadata(\"sample_type\", \"serum\")\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        setattr(self, key, value)\n    else:\n        # Set/Add a key-value pair in metadata\n        self.metadata[key] = value\n</code></pre>"},{"location":"qc_configfile/","title":"QC Configuration File","text":""},{"location":"qc_configfile/#overview","title":"Overview","text":"<p>The QC configuration file is in the TOML (Tom's Obvious, Minimal Language) format. It defines the distribution of Quality Control (QC) and specimen samples within a multiwell plate. This file is structured into several key sections, each tailored for different aspects of the plate layout.</p>"},{"location":"qc_configfile/#example","title":"Example","text":"<pre><code>[QC]\n# should first well(s) be a QC round?\nstart_with_QC_round = true\n# how many non-QC samples to analyze until we start a round of QC samples? \nrun_QC_after_n_specimens = 11 \n\n[QC.names] \n# Describes the key names and descriptions of the QC samples used.\nEC = \"EC: External_Control_(matrix)\"\nPB = \"PB: Paper_Blank\"\nPO = \"PO: Pooled_specimens\"\n\n[QC.patterns]\n# start = [\"EC\", \"PB\"]\nthen_alternating = [[\"EC\", \"PB\"], [\"EC\", \"PO\"]]\n</code></pre>"},{"location":"qc_configfile/#sections","title":"Sections","text":""},{"location":"qc_configfile/#qc-section","title":"[QC] Section","text":"<p>This section includes general settings for the QC layout.</p> <ul> <li><code>start_with_QC_round</code> (boolean): Determines whether the first wells should contain QC samples. Set to <code>true</code> to start with a QC round; <code>false</code> otherwise.</li> <li><code>run_QC_after_n_specimens</code> (integer): The number of non-QC (specimen) samples to analyze before starting a new round of QC samples.</li> </ul>"},{"location":"qc_configfile/#qcnames-section","title":"[QC.names] Section","text":"<p>Describes the key names and descriptions of the QC samples used. For example:</p> <ul> <li><code>EC</code> = \"EC: External_Control_(matrix)\"</li> <li><code>PB</code> = \"PB: Paper_Blank\"</li> <li><code>PO</code> = \"PO: Pooled_specimens\"</li> </ul>"},{"location":"qc_configfile/#qcpatterns-section","title":"[QC.patterns] Section","text":"<p>Defines the hierarchy and patterns for QC sample placement throughout the plate.</p>"},{"location":"qc_configfile/#hierarchy-of-patterns","title":"Hierarchy of Patterns:","text":"<ul> <li>Specific Round Patterns: Highest priority. Specific instructions for individual rounds (e.g., <code>round_3</code>).</li> <li>Start/End Patterns: Determine patterns for the beginning (<code>start</code>) and end (<code>end</code>) of the plate.</li> <li>Repeat Pattern: Specifies a pattern (<code>repeat_pattern</code>) to be repeated a certain number of times.</li> <li>Alternating Patterns: Defines alternating patterns (<code>then_alternating</code>) that provide a general structure.</li> <li>Every N Rounds Patterns: Lowest priority. General patterns applied every N rounds (e.g., <code>every_4_rounds</code>).</li> </ul>"},{"location":"qc_configfile/#pattern-examples","title":"Pattern Examples:","text":"<ul> <li><code>round_3 = [\"EC\", \"PO\", \"PB\"]</code>: Specific pattern for round 3.</li> <li><code>every_4_rounds = [\"EC\", \"PB\"]</code>: Pattern applied every 4 rounds.</li> <li><code>start = [\"EC\", \"PB\"]</code>: Pattern for the start of the plate.</li> <li><code>then_alternating = [[\"PB\", \"PO\"], [\"EC\", \"PO\"]]</code>: Alternating patterns.</li> <li><code>end = [\"PB\"]</code>: Pattern for the end of the plate.</li> <li><code>repeat_pattern = { pattern = [\"EC\", \"PB\"], times = 3 }</code>: Repeats the specified pattern 3 times.</li> </ul> <p>Note</p> <p>Ensure that the sum of all patterns does not exceed the plate capacity and that each pattern is configured correctly to avoid layout errors.</p>"},{"location":"study/","title":"Study Documentation","text":""},{"location":"study/#src.plate_planner.study.Study","title":"<code>Study</code>","text":"<p>A class to manage and manipulate study-related data, including specimen records, plate layouts,  and sample distributions.</p> <p>This class provides functionalities for loading specimen records, sorting and randomizing  specimen order, distributing specimens across plates, and exporting data to various formats.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the study.</p> <code>plates</code> <code>list</code> <p>List of Plate objects used in the study.</p> <code>total_plates</code> <code>int</code> <p>Total number of plates in the study.</p> <code>specimen_records_df</code> <code>DataFrame</code> <p>Pandas DataFrame holding specimen records.</p> <code>records_file_path</code> <code>str</code> <p>Path to the file containing specimen records.</p> <code>_column_with_group_index</code> <code>str</code> <p>Column name in specimen_records_df that holds group indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Cancer\")\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.randomize_order(case_control=True)\n</code></pre> <pre><code>&gt;&gt;&gt; qc_plate = QCPlate(QC_config=\"./data/plate_config_dynamic.toml\")\n&gt;&gt;&gt; study.randomize_order()\n&gt;&gt;&gt; study.distribute_samples_to_plates()\n&gt;&gt;&gt; study.to_layout_lists()\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>class Study:\n    \"\"\"\n    A class to manage and manipulate study-related data, including specimen records, plate layouts, \n    and sample distributions.\n\n    This class provides functionalities for loading specimen records, sorting and randomizing \n    specimen order, distributing specimens across plates, and exporting data to various formats.\n\n    Attributes:\n        name (str): Name of the study.\n        plates (list): List of Plate objects used in the study.\n        total_plates (int): Total number of plates in the study.\n        specimen_records_df (DataFrame): Pandas DataFrame holding specimen records.\n        records_file_path (str): Path to the file containing specimen records.\n        _column_with_group_index (str): Column name in specimen_records_df that holds group indices.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Cancer\")\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.randomize_order(case_control=True)\n\n        &gt;&gt;&gt; qc_plate = QCPlate(QC_config=\"./data/plate_config_dynamic.toml\")\n        &gt;&gt;&gt; study.randomize_order()\n        &gt;&gt;&gt; study.distribute_samples_to_plates()\n        &gt;&gt;&gt; study.to_layout_lists()\n    \"\"\"\n\n\n    _default_distribute_samples_equally : bool = False\n\n    _batch_count : int = 0\n    _iter_count : int = 0\n    _default_seed = 1234 # seed number for the random number generator in case randomization of specimens should be reproducible\n    _N_permutations : int = 0\n    _column_with_group_index : str = \"\"\n\n    def __init__(self, study_name=None,) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Study class.\n\n        This constructor sets up a study with a specified name. If no name is provided, a default name \n        is generated using the current date.\n\n        Args:\n            study_name (Optional[str]): The name for the study. If None, a default name in the format \n                \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.\n\n        Examples:\n            &gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n            &gt;&gt;&gt; study1.name\n            \"Alzheimer's Research\"\n\n            &gt;&gt;&gt; study2 = Study()\n            &gt;&gt;&gt; study2.name\n            \"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n        \"\"\"\n\n        if study_name is None:\n            study_name = f\"Study_{datetime.date}\"\n\n        self.name = study_name\n        self.plates = []\n\n    def __iter__(self) -&gt; Iterator[Union[Plate, QCPlate]]:\n        \"\"\"\n        Initialize the iterator for the Study class.\n\n        This method sets up the class to iterate over its plates, resetting the internal counter \n        to zero. It allows the Study instance to be used in a loop (e.g., a for loop), \n        facilitating iteration over its plates.\n\n        Returns:\n            Iterator[Union[Plate, QCPlate]]: An iterator that yields either `Plate` or `QCPlate` \n            instances, allowing the Study instance to be used in a loop.\n        \"\"\"\n        self._iter_count = 0\n        return self\n\n    def __next__(self) -&gt; Union[Plate, QCPlate]:\n        \"\"\"\n        Proceed to the next plate in the Study class during iteration.\n\n        This method returns the next plate in the study, which can be either a `Plate` or a `QCPlate` instance.\n        It is automatically called in each iteration of a loop. When all plates have been iterated over,\n        it raises the StopIteration exception.\n\n        Returns:\n            Union[Plate, QCPlate]: The next plate in the study, either a `Plate` or `QCPlate` instance.\n\n        Raises:\n            StopIteration: If all plates have been iterated over.\n        \"\"\"\n        if self._iter_count &lt; self.total_plates:\n            plate_to_return = self.plates[self._iter_count]\n            self._iter_count += 1\n            return plate_to_return\n        else:\n            raise StopIteration\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the total number of plates in the Study.\n\n        This method enables the use of the len() function on the Study instance.\n\n        Returns:\n            int: The number of plates in the study.\n        \"\"\"\n        return len(self.plates)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return an unambiguous string representation of the Study instance.\n\n        This method is useful for debugging and logging purposes, as it represents the Study\n        object in a clear and concise way.\n\n        Returns:\n            str: A string representation of the Study instance.\n        \"\"\"\n        return f\"Study({self.name})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a readable string representation of the Study instance.\n\n        This method provides a user-friendly string representation of the Study, which includes\n        its name, the number of study specimens, and the total number of plates.\n\n        Returns:\n            str: A string describing the Study instance.\n        \"\"\"\n        return f\"{self.name}\\n {self.study_specimens} on {self.total_plates}\"\n\n    def __getitem__(self, index) -&gt; Union[Plate, QCPlate]:\n        \"\"\"\n        Retrieve a specific plate from the study by its index.\n\n        This method allows for direct access to a plate in the study using the indexing syntax.\n\n        Args:\n            index (int): The index of the plate to retrieve.\n\n        Returns:\n            Union[Plate, QCPlate]: The plate at the specified index.\n\n        Raises:\n            IndexError: If the index is out of range of the plates list.\n        \"\"\"\n        return self.plates[index]\n\n    def load_sample_file(self, records_file: str, sample_group_id_column=None, sample_id_column=None) -&gt; None:\n        \"\"\"\n        Loads specimen records from a specified file into the study.\n\n        This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame.\n        It also identifies or sets the column used for grouping specimens.\n\n        Args:\n            records_file (str): The path to the file containing specimen records.\n            sample_group_id_column (Optional[str]): The column name in the file that represents the group ID of samples. \n                If None, the method attempts to find a suitable column automatically.\n\n        Raises:\n            FileExistsError: If the specified records_file does not exist.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n            &gt;&gt;&gt; study.specimen_records_df.shape\n            (200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n        \"\"\"\n        self.records_file_path = records_file\n        records_path = Path(records_file)\n\n        logger.debug(f\"Loading records file: {records_file}\")\n        extension = records_path.suffix\n\n        if not records_path.exists():\n            logger.error(f\"Could not find file {records_file}\")\n            raise FileExistsError(records_file)\n\n        if extension in [\".xlsx\", \".xls\"]:\n            logger.debug(\"Importing Excel file.\")\n            records = pd.read_excel(records_file)\n        elif extension == \".csv\":\n            logger.debug(\"Importing csv file.\")\n            records = pd.read_csv(records_file)\n        else:\n            logger.error(\"File extension not recognized\")\n            records = pd.DataFrame()\n\n        if sample_group_id_column is None:\n            self._column_with_group_index = Study._find_column_with_group_index(records)\n        else:\n            self._column_with_group_index = sample_group_id_column\n\n        logger.debug(f\"{records.shape[0]} specimens in file\")\n        logger.info(\"Metadata in file:\")\n        for col in records.columns:\n            logger.info(f\"\\t{col}\")\n\n        if sample_id_column:\n            logger.debug(f\"Sorting records in ascending order based on column '{sample_id_column}'\")\n            records = records.sort_values(by=[sample_id_column])\n\n        # if self._column_with_group_index:\n        #     logger.debug(f\"Sorting records in ascending order based on column '{self._column_with_group_index}'\")\n            # records = records.sort_values(by=[self._column_with_group_index])\n\n        self.specimen_records_df = records\n\n    def sort_records_within_groups(self, sortby_column: str) -&gt; None:\n        \"\"\"\n        Sorts specimen records within each group based on a specified column.\n\n        This method groups the specimen records by a predefined group index column and then sorts each group's records\n        based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame.\n        This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.\n\n        Args:\n            sortby_column (str): The column name in the specimen records DataFrame to sort by within each group.\n\n        Raises:\n            ValueError: If no group column is defined in the Study instance.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n            # This will sort the specimen records within each group based on the \"Age\" column.\n        \"\"\"\n        if self._column_with_group_index:\n            logger.info(f\"Sorting samples within {self._column_with_group_index} by {sortby_column}\")\n            # Step 1: Group the DataFrame by 'group_ID'\n            grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n            # Step 2: Sort each group by the 'sortby_column' column\n            sorted_groups = [group.sort_values(sortby_column) for _, group in grouped]\n\n            # Step 3: Concatenate the sorted groups back into a single DataFrame\n            self.specimen_records_df = pd.concat(sorted_groups)\n\n        else:\n            raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n\n    def position_sample_within_groups(self, sortby_column: str, sample_value: Any, position_index: int) -&gt; None:\n        \"\"\"\n        Repositions a specific sample within each group based on a specified value and index.\n\n        This method allows altering the position of a sample within each group in the specimen records DataFrame.\n        It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group\n        to the specified 'position_index'. The method is useful for customizing the order of samples within groups\n        based on specific criteria or requirements.\n\n        Args:\n            sortby_column (str): The column name in the specimen records DataFrame to identify the sample.\n            sample_value (Any): The value in the 'sortby_column' that identifies the sample to reposition.\n            position_index (int): The new index within the group where the sample should be positioned.\n\n        Raises:\n            ValueError: If no group column is defined in the Study instance.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n            # This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n        \"\"\"\n        if self._column_with_group_index:\n            logger.info(f\"Positioning sample within {self._column_with_group_index} based on {sortby_column} value {sample_value} at index {position_index}\")\n            # Step 1: Group the DataFrame by 'group_ID'\n            grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n            # Step 2: Modify each group\n            modified_groups = []\n            for _, group in grouped:\n                # Find the row to reposition\n                sample_row = group[group[sortby_column] == sample_value]\n\n                # Remove this row from the group\n                group = group[group[sortby_column] != sample_value]\n\n                # Split the group at the specified position index\n                first_part = group.iloc[:position_index]\n                second_part = group.iloc[position_index:]\n\n                # Concatenate first part, sample row, and second part\n                modified_group = pd.concat([first_part, sample_row, second_part])\n\n                modified_groups.append(modified_group)\n\n            # Step 3: Concatenate the modified groups back into a single DataFrame\n            self.specimen_records_df = pd.concat(modified_groups).reset_index(drop=True)\n\n        else:\n            raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n\n    def _add_specimens_to_plate(self, study_plate: object, specimen_samples_df: object) -&gt; None:\n        \"\"\"\n        Adds specimens from a DataFrame to a specified plate based on well metadata.\n\n        This method iterates through each well of the given plate and, if the well's metadata indicates \n        it should contain a specimen (as marked by \"sample_code\" == \"S\"), adds specimen data from the \n        DataFrame to the well's metadata. The method stops adding specimens once all have been placed \n        or the plate is filled.\n\n        Args:\n            study_plate (Plate): The plate object to which specimens will be added.\n            specimen_samples_df (pd.DataFrame): DataFrame containing specimen data to be added to the plate.\n\n        Notes:\n            - This is a private method intended for internal use within the class.\n            - The method assumes that 'study_plate' is an instance of 'Plate' or a compatible type, and\n            'specimen_samples_df' is a Pandas DataFrame with columns corresponding to metadata fields.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study_plate = Plate(...)  # Assume Plate is properly initialized\n            &gt;&gt;&gt; specimens_df = pd.DataFrame(...)  # DataFrame with specimen data\n            &gt;&gt;&gt; study._add_specimens_to_plate(study_plate, specimens_df)\n            # Specimens from specimens_df are now added to the study_plate based on its well metadata\n        \"\"\"\n\n        logger.debug(f\"Adding {len(specimen_samples_df)} samples to plate {study_plate.plate_id}\")\n        columns = specimen_samples_df.columns\n\n        # keep track on how many wells we should use per batch\n        N_specimens_left = len(specimen_samples_df)\n        plate_specimen_count = 0\n\n        for i, well in enumerate(study_plate):\n\n            if well.metadata[\"sample_code\"] == \"S\": \n                # add metadata key (and values) for each column in dataframe\n                for col in columns:\n                    well.metadata[col] = specimen_samples_df[col][plate_specimen_count]\n\n                plate_specimen_count += 1\n\n            else:\n                # add metadata key and nan value for each column in dataframe\n                for col in columns:\n                    well.metadata[col] = \"NaN\"\n\n                well.empty = False\n\n            study_plate[i] = well\n\n            if plate_specimen_count &gt;= N_specimens_left:\n                    logger.debug(f\"\\t -&gt; Done. Last specimen placed in {well.name}\")\n                    break\n\n        return study_plate\n\n        # --- END OF FOOR LOOP ---\n\n    def to_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Converts the data from all plates in the study into a single Pandas DataFrame.\n\n        This method iterates over each plate in the study and converts its data to a DataFrame. \n        These DataFrames are then concatenated into a single DataFrame representing the entire study.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing data from all plates in the study.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study_df = study.to_dataframe()\n            &gt;&gt;&gt; study_df.head()\n            # Displays the first few rows of the combined DataFrame for the study.\n        \"\"\"\n        dfs = []\n        for plate in self:\n            dfs.append(plate.as_dataframe())\n        return pd.concat(dfs).reset_index(drop=True)\n\n    def to_layout_lists(self, metadata_keys: list = [], \n                    file_format: str = \"csv\",\n                    folder_path: str = None,\n                    plate_name: str = \"plate\") -&gt; None:\n        \"\"\"\n        Exports the layout of each plate in the study to files in the specified format.\n\n        This method iterates over each plate in the study and exports its layout to a file. \n        The files are saved in a specified format (CSV by default) and stored in a designated folder.\n\n        Args:\n            metadata_keys (list, optional): A list of metadata keys to include in the exported files.\n            file_format (str, optional): The file format for the exported layouts (e.g., 'csv').\n            folder_path (str, optional): The path to the folder where the layout files will be saved. \n                If None, the current working directory is used.\n            plate_name (str, optional): A base name for the layout files.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                                    file_format=\"csv\", \n                                    folder_path=\"/path/to/layouts\", \n                                    plate_name=\"experiment_plate\")\n            # This will save layout files for each plate in the '/path/to/layouts' directory.\n        \"\"\"\n\n        if folder_path is None:\n            folder_path = Path.cwd()\n        else:\n            folder_path = Path(folder_path)\n\n        # New folder path for \"layout_lists\"\n        new_folder_path = folder_path / \"layout_lists\"\n\n        # Create the \"layout_lists\" folder if it does not exist\n        new_folder_path.mkdir(parents=True, exist_ok=True)\n\n        for plate in self:\n            file_name = f\"{self.name}_{plate_name}_{plate.plate_id}\"\n            # Update file path to include the new folder\n            file_path = new_folder_path / file_name\n\n            plate.to_file(file_path=str(file_path),\n                        file_format=file_format,\n                        metadata_keys=metadata_keys)\n\n    def to_layout_figures(self,\n                          annotation_metadata_key : str,\n                          color_metadata_key : str,\n                        file_format : str = None,\n                        folder_path : str = None,\n                        plate_name : str = \"Plate\", **kwargs) -&gt; None:\n        \"\"\"\n        Creates and visual representations of each plate in the study as figures.\n\n        This method iterates over each plate in the study, generating a figure based on specified metadata keys\n        for annotation and coloring. If the file format is specified, the figures are saved in the specified file format in a designated folder.\n\n        Args:\n            annotation_metadata_key (str): The metadata key used for annotating elements in the figure.\n            color_metadata_key (str): The metadata key used for coloring elements in the figure.\n            file_format (str, optional): The format in which to save the figures (default is 'pdf').\n            folder_path (Optional[str]): The path to the folder where the figures will be saved. \n                If None, the current working directory is used.\n            plate_name (str, optional): A base name for the figure files.\n            **kwargs: Additional keyword arguments passed to the `as_figure` method of each plate.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                                    color_metadata_key=\"status\",\n                                    file_format=\"png\",\n                                    folder_path=\"/path/to/figures\",\n                                    plate_name=\"study_plate\")\n            # This will create and save figures for each plate in the '/path/to/figures' directory,\n            # with annotations and colorings based on 'sample_id' and 'status'.\n        \"\"\"\n\n        if file_format is not None:\n            if folder_path is None:\n                folder_path = Path.cwd()\n            else:\n                folder_path = Path(folder_path)\n\n            # New folder path for \"layout_lists\"\n            new_folder_path = folder_path / \"layout_figures\"\n\n            # Create the \"layout_lists\" folder if it does not exist\n            new_folder_path.mkdir(parents=True, exist_ok=True)\n\n        for plate in self:\n            file_name = f\"{self.name}_{plate_name}_{plate.plate_id}_{annotation_metadata_key}_{color_metadata_key}.{file_format}\"\n            file_path = new_folder_path / file_name\n\n            # Define title        \n            title_str = f\"{self.name}: Plate {plate.plate_id}, showing {annotation_metadata_key} colored by {color_metadata_key}\"\n\n            fig = plate.as_figure(annotation_metadata_key, color_metadata_key, title_str=title_str, **kwargs)\n\n            logger.info(f\"Saving plate figure to {file_path}\")\n\n            if file_format:\n                fig.savefig(file_path)\n\n    def distribute_samples_to_plates(self, plate_layout: Union[Plate, QCPlate], allow_group_split=False, N_samples_desired_plate=None) -&gt; None:\n        \"\"\"\n        Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.\n\n        This method iterates through the study's specimen records and distributes them across multiple plates \n        according to the provided plate layout. It supports options to either keep specimen groups together or \n        allow splitting them across different plates. The method can also handle a specified number of samples \n        per plate if desired.\n\n        Args:\n            plate_layout (Union[Plate, QCPlate]): The layout template for the plates. This can be an instance of \n                'Plate' or 'QCPlate'.\n            allow_group_split (bool, optional): If False (default), keeps specimens within the same group on the \n                same plate. If True, allows splitting groups across plates.\n            N_samples_desired_plate (Optional[int], optional): The desired number of samples per plate. If not \n                specified, fills each plate to its capacity.\n\n        Raises:\n            ValueError: If the group column is not defined in the specimen records.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n            &gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n            # This will distribute the specimens across plates, keeping groups together.\n        \"\"\"\n\n        plate_number = 1\n        plates = []\n\n        # Copy the specimen data to work on\n        remaining_specimens = self.specimen_records_df.copy()\n\n        N_specimens = self.specimen_records_df.shape[0]\n\n        if N_samples_desired_plate is None:\n            N_samples_desired_plate = plate_layout.capacity\n\n        # N_QCsample_in_plate = plate_layout.get_metadata_as_numpy_array(\"QC\").sum()\n        # N_plates_estimate = N_specimens / (plate_layout._specimen_capacity)\n\n        while not remaining_specimens.empty:\n            current_plate = copy.deepcopy(plate_layout)\n            current_plate.plate_id = plate_number\n\n            # Select specimens for the current plate\n            N_remaining = remaining_specimens.shape[0]\n\n            # if the remaining samples can fit on a whole place we put them there,\n            # otherwise we place the desired number of samples on the plate.\n            # if not we \n            if N_remaining &lt; current_plate.capacity:\n                selected_specimens = remaining_specimens.head(current_plate.capacity)\n            else:\n                selected_specimens = remaining_specimens.head(N_samples_desired_plate)\n\n            if not allow_group_split:\n                # Extract unique group IDs from the selected specimens. This step identifies the distinct groups\n                # that are represented within the specimens currently being considered for this plate.\n                group_ids = selected_specimens[self._column_with_group_index].unique()\n\n                # Find all specimens in the remaining pool that belong to the same groups as the selected specimens.\n                specimens_in_groups = remaining_specimens[remaining_specimens[self._column_with_group_index].isin(group_ids)]\n\n                if len(specimens_in_groups) &gt; len(selected_specimens):\n                    # If there are more specimens in the remaining pool belonging to the same groups,\n                    # it indicates that the last group in 'selected_specimens' is split between this plate and the remaining pool.\n                    # To avoid splitting the group, we modify 'selected_specimens' to exclude this last group.\n\n                    # Determine the groups to keep on the current plate. This is done by excluding the last group ID\n                    # from the list of unique group IDs in the selected specimens. This way, we ensure that an entire group \n                    # is not split across plates.\n                    groups_to_keep = group_ids[:-1]\n\n                    # Update 'selected_specimens' to only include specimens from the groups that are not split.\n                    selected_specimens = selected_specimens[selected_specimens[self._column_with_group_index].isin(groups_to_keep)]\n\n            # Remove selected specimens from the pool\n            remaining_specimens.drop(index=selected_specimens.index, inplace=True)\n            selected_specimens.reset_index(drop=True, inplace=True)\n            remaining_specimens.reset_index(drop=True, inplace=True)\n\n            # Add specimens to the current plate\n            current_plate = self._add_specimens_to_plate(current_plate, selected_specimens)\n            plates.append(current_plate)\n\n            plate_number += 1\n\n        self.plates = plates\n        self.total_plates = plate_number - 1\n\n        logger.info(f\"Distributed samples across {self.total_plates} plates.\")\n\n    @staticmethod\n    def _find_column_with_group_index(specimen_records_df: pd.DataFrame) -&gt; str:\n        \"\"\"\n        Identifies the column in a DataFrame that likely represents group indices based on integer pairs.\n\n        This static method analyzes a provided DataFrame to determine which column could represent group indices.\n        It looks for columns with integer values where pairs of consecutive numbers are common, indicating a\n        potential grouping pattern. The method is specifically designed to identify groups based on pair numbers.\n\n        Args:\n            specimen_records_df (pd.DataFrame): The DataFrame containing specimen records.\n\n        Returns:\n            str: The name of the column that likely represents group indices. Returns an empty string if no suitable\n                column is found.\n\n        Examples:\n            &gt;&gt;&gt; specimen_records_df = pd.DataFrame({'GroupID': [1, 1, 2, 2, 3, 3], 'Data': [100, 101, 102, 103, 104, 105]})\n            &gt;&gt;&gt; Study._find_column_with_group_index(specimen_records_df)\n            'GroupID'\n        \"\"\"\n        int_cols = specimen_records_df.select_dtypes(\"int\")\n\n        logger.debug(f\"Looking for group index of study pairs in the following table columns:\")\n\n        for col_name in int_cols.columns:\n\n            logger.debug(f\"\\t\\t{col_name}\")\n\n            # sort in ascending order\n            int_col = int_cols[col_name].sort_values()\n            # compute difference: n_1 - n_2, n_2 - n_3, ...\n            int_diffs = np.diff(int_col)\n            # count instances were numbers were the same, i.e. diff == 0\n            n_zeros = np.sum(list(map(lambda x: x==0, int_diffs)))\n            # we assume column contains pairs if #pairs == #samples / 2\n            column_have_pairs = n_zeros == (int_col.shape[0]//2)\n\n            if column_have_pairs:# we found a column so let's assume it is the correct one\n                logger.info(f\"Found group index in column {col_name}\")\n                return col_name\n\n        return \"\" \n\n    def randomize_order(self, case_control : bool = None, reproducible=True) -&gt; None:\n        \"\"\"\n        Randomizes the order of specimen records in the study, optionally maintaining group integrity.\n\n        This method either randomizes the entire order of specimens or maintains the order within groups,\n        depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.\n\n        Args:\n            case_control (Optional[bool]): If True, maintains group order (samples within a group are not shuffled).\n                If False, shuffles all samples regardless of group. If None, the behavior is determined based on \n                the presence of a group index column.\n            reproducible (bool): If True, uses a fixed seed for randomization to ensure reproducibility.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n            &gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.randomize_order(case_control=True)\n            &gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n        \"\"\"\n\n        if not len(self.specimen_records_df) &gt; 0:\n            logger.error(\"There are no study records loaded. Use 'load_specimen_records' method to import study records.\")\n            return\n\n        if case_control is None:\n            if self._column_with_group_index:\n                case_control = True\n            else:\n                case_control = False\n\n        specimen_records_df_copy = self.specimen_records_df.copy()\n\n        if case_control:\n            column_with_group_index = self._column_with_group_index\n\n            logger.debug(f\"Randomly permuting group order (samples within group unchanged) using variable '{column_with_group_index}'\")\n            logger.debug(\"Creating multiindex dataframe\")\n            specimen_records_df_copy = specimen_records_df_copy.set_index([column_with_group_index, specimen_records_df_copy.index])\n            drop = False\n        else:\n            logger.debug(f\"Randomly permuting sample order.\")\n            specimen_records_df_copy = specimen_records_df_copy.set_index([specimen_records_df_copy.index, specimen_records_df_copy.index])\n            column_with_group_index = 0\n            drop = True\n\n\n        group_IDs = np.unique(specimen_records_df_copy.index.get_level_values(0))\n\n        # Permute order in table\n        if reproducible:\n            logger.info(f\"Using a fixed seed to random number generator for reproducibility; \\\n                running this method will always give the same result.\")\n            logger.debug(f\"Using class-determined seed {self._default_seed} for random number generator\")\n            np.random.seed(self._default_seed)\n\n        permutation_order = np.random.permutation(group_IDs)\n\n        prev_index_str = \"index_before_permutation\"\n\n        # if multiple randomization rounds, remove old column = prev_index_str \n        if prev_index_str in specimen_records_df_copy.columns:\n            specimen_records_df_copy = specimen_records_df_copy.drop(columns=prev_index_str)\n\n        specimen_records_df_copy = specimen_records_df_copy \\\n                                    .loc[permutation_order]\\\n                                    .reset_index(level=column_with_group_index, drop=drop)\\\n                                    .reset_index(drop=False)\n\n        specimen_records_df_copy = specimen_records_df_copy.rename(columns = {\"index\": \"index_before_permutation\"})\n\n        self._N_permutations += 1\n        self.specimen_records_df = specimen_records_df_copy.copy()\n\n    @staticmethod\n    def _get_attribute_distribution(df: pd.DataFrame, attribute, ignore_nans=True, normalize=True):\n        if ignore_nans:\n            df = df.replace(\"NaN\", pd.NA)\n            df = df.dropna()\n\n        distribution = df[attribute].value_counts(normalize=normalize)\n        return distribution\n\n    def randomize_with_uniformity_check(self, case_control, attribute, samples_per_plate, uniformity_criterion, max_attempts = 10, reproducible=False):\n        attempt = 0\n        while attempt &lt; max_attempts:\n            self.randomize_order(case_control, reproducible)\n            if self._uniformity_within_tolerance(attribute, samples_per_plate, uniformity_criterion):\n                return\n            attempt += 1\n        raise Exception(f\"Unable to achieve uniform distribution after {max_attempts} attempts\")\n\n    def _uniformity_within_tolerance(self, attribute, block_size, tolerance):\n        overall_distribution = self._get_attribute_distribution(self.specimen_records_df, attribute)\n        for start_idx in range(0, len(self.specimen_records_df), block_size):\n            end_idx = start_idx + block_size\n            block = self.specimen_records_df.iloc[start_idx:end_idx]\n            block_distribution = block[attribute].value_counts(normalize=True)\n\n            if not self._meets_criterion(block_distribution, overall_distribution, tolerance):\n                return False\n        return True\n\n    def _meets_criterion(self, block_distribution, overall_distribution, tolerance):\n        for category in overall_distribution.index:\n            overall_percent = overall_distribution[category] * 100\n            block_percent = block_distribution.get(category, 0) * 100  # Default to 0 if category not in block\n            if abs(block_percent - overall_percent) &gt; tolerance:\n                return False\n        return True\n\n    def get_attribute_plate_distributions(self, attribute, ignore_nans=True, normalize=True) -&gt; dict:\n        plate_distributions = {}\n\n        for plate in self.plates:\n            df = plate.as_dataframe()\n            distribution = self._get_attribute_distribution(df, attribute, ignore_nans, normalize)\n            plate_distributions[plate.plate_id] = distribution\n\n        return plate_distributions\n\n    def plot_attribute_plate_distributions(self, attribute, normalize=False, colormap='tab20b', plt_style=\"ggplot\"):\n        \"\"\"\n        Plots a stacked bar chart for a specified attribute across different plates.\n\n        This method retrieves distribution data for the given attribute and plots it \n        as a stacked bar chart. Each bar in the chart represents a different category \n        of the attribute, with segments in the bar showing the count or proportion \n        from each plate. The method supports normalization of the data and allows for \n        customization of the plot's colormap.\n\n        Args:\n            attribute (str): The attribute for which the distributions are plotted.\n            normalize (bool, optional): If True, normalizes the counts within each \n                category to proportions that sum to 100%. Defaults to False.\n            colormap (str, optional): The name of the matplotlib colormap to use for \n                the plot. Defaults to 'tab20b'.\n\n        Returns:\n            matplotlib.figure.Figure: The figure object containing the bar chart.\n        \"\"\"\n\n        distributions = self.get_attribute_plate_distributions(attribute=attribute, normalize=False)\n\n        # Convert the dictionary to a DataFrame and rename columns\n        df = pd.DataFrame(distributions)\n        df.columns = [f\"plate_{key}\" for key in distributions.keys()]\n\n        if normalize:\n            # Normalize each column to sum to 100%\n            df = df.div(df.sum(axis=1), axis=0) * 100\n\n        # Plotting the stacked bar chart\n        plt.style.use(plt_style)\n        fig, ax = plt.subplots()\n\n        # Apply the chosen colormap\n        df.plot(kind='bar', stacked=True, ax=ax, colormap=colormap)\n\n        # Set titles and labels\n        ax.set_title(f\"Counts of {attribute} across plates\" + (\" (Normalized)\" if normalize else \"\"))\n        ax.set_xlabel(f\"{attribute}\")\n        ax.set_ylabel('Proportion (%)' if normalize else 'Counts')\n\n        # Place the legend outside of the plotting area\n        ax.legend(title=\"Plates\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\n        # Rotate and align x-axis labels\n        plt.xticks(rotation=45, ha='right')\n\n        return fig\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Retrieve a specific plate from the study by its index.</p> <p>This method allows for direct access to a plate in the study using the indexing syntax.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the plate to retrieve.</p> required <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Union[Plate, QCPlate]: The plate at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range of the plates list.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __getitem__(self, index) -&gt; Union[Plate, QCPlate]:\n    \"\"\"\n    Retrieve a specific plate from the study by its index.\n\n    This method allows for direct access to a plate in the study using the indexing syntax.\n\n    Args:\n        index (int): The index of the plate to retrieve.\n\n    Returns:\n        Union[Plate, QCPlate]: The plate at the specified index.\n\n    Raises:\n        IndexError: If the index is out of range of the plates list.\n    \"\"\"\n    return self.plates[index]\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__init__","title":"<code>__init__(study_name=None)</code>","text":"<p>Initializes a new instance of the Study class.</p> <p>This constructor sets up a study with a specified name. If no name is provided, a default name  is generated using the current date.</p> <p>Parameters:</p> Name Type Description Default <code>study_name</code> <code>Optional[str]</code> <p>The name for the study. If None, a default name in the format  \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n&gt;&gt;&gt; study1.name\n\"Alzheimer's Research\"\n</code></pre> <pre><code>&gt;&gt;&gt; study2 = Study()\n&gt;&gt;&gt; study2.name\n\"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __init__(self, study_name=None,) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Study class.\n\n    This constructor sets up a study with a specified name. If no name is provided, a default name \n    is generated using the current date.\n\n    Args:\n        study_name (Optional[str]): The name for the study. If None, a default name in the format \n            \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.\n\n    Examples:\n        &gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n        &gt;&gt;&gt; study1.name\n        \"Alzheimer's Research\"\n\n        &gt;&gt;&gt; study2 = Study()\n        &gt;&gt;&gt; study2.name\n        \"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n    \"\"\"\n\n    if study_name is None:\n        study_name = f\"Study_{datetime.date}\"\n\n    self.name = study_name\n    self.plates = []\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__iter__","title":"<code>__iter__()</code>","text":"<p>Initialize the iterator for the Study class.</p> <p>This method sets up the class to iterate over its plates, resetting the internal counter  to zero. It allows the Study instance to be used in a loop (e.g., a for loop),  facilitating iteration over its plates.</p> <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Iterator[Union[Plate, QCPlate]]: An iterator that yields either <code>Plate</code> or <code>QCPlate</code> </p> <code>Union[Plate, QCPlate]</code> <p>instances, allowing the Study instance to be used in a loop.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Union[Plate, QCPlate]]:\n    \"\"\"\n    Initialize the iterator for the Study class.\n\n    This method sets up the class to iterate over its plates, resetting the internal counter \n    to zero. It allows the Study instance to be used in a loop (e.g., a for loop), \n    facilitating iteration over its plates.\n\n    Returns:\n        Iterator[Union[Plate, QCPlate]]: An iterator that yields either `Plate` or `QCPlate` \n        instances, allowing the Study instance to be used in a loop.\n    \"\"\"\n    self._iter_count = 0\n    return self\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__len__","title":"<code>__len__()</code>","text":"<p>Return the total number of plates in the Study.</p> <p>This method enables the use of the len() function on the Study instance.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of plates in the study.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the total number of plates in the Study.\n\n    This method enables the use of the len() function on the Study instance.\n\n    Returns:\n        int: The number of plates in the study.\n    \"\"\"\n    return len(self.plates)\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__next__","title":"<code>__next__()</code>","text":"<p>Proceed to the next plate in the Study class during iteration.</p> <p>This method returns the next plate in the study, which can be either a <code>Plate</code> or a <code>QCPlate</code> instance. It is automatically called in each iteration of a loop. When all plates have been iterated over, it raises the StopIteration exception.</p> <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Union[Plate, QCPlate]: The next plate in the study, either a <code>Plate</code> or <code>QCPlate</code> instance.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If all plates have been iterated over.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __next__(self) -&gt; Union[Plate, QCPlate]:\n    \"\"\"\n    Proceed to the next plate in the Study class during iteration.\n\n    This method returns the next plate in the study, which can be either a `Plate` or a `QCPlate` instance.\n    It is automatically called in each iteration of a loop. When all plates have been iterated over,\n    it raises the StopIteration exception.\n\n    Returns:\n        Union[Plate, QCPlate]: The next plate in the study, either a `Plate` or `QCPlate` instance.\n\n    Raises:\n        StopIteration: If all plates have been iterated over.\n    \"\"\"\n    if self._iter_count &lt; self.total_plates:\n        plate_to_return = self.plates[self._iter_count]\n        self._iter_count += 1\n        return plate_to_return\n    else:\n        raise StopIteration\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__repr__","title":"<code>__repr__()</code>","text":"<p>Return an unambiguous string representation of the Study instance.</p> <p>This method is useful for debugging and logging purposes, as it represents the Study object in a clear and concise way.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the Study instance.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return an unambiguous string representation of the Study instance.\n\n    This method is useful for debugging and logging purposes, as it represents the Study\n    object in a clear and concise way.\n\n    Returns:\n        str: A string representation of the Study instance.\n    \"\"\"\n    return f\"Study({self.name})\"\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.__str__","title":"<code>__str__()</code>","text":"<p>Return a readable string representation of the Study instance.</p> <p>This method provides a user-friendly string representation of the Study, which includes its name, the number of study specimens, and the total number of plates.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string describing the Study instance.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a readable string representation of the Study instance.\n\n    This method provides a user-friendly string representation of the Study, which includes\n    its name, the number of study specimens, and the total number of plates.\n\n    Returns:\n        str: A string describing the Study instance.\n    \"\"\"\n    return f\"{self.name}\\n {self.study_specimens} on {self.total_plates}\"\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.distribute_samples_to_plates","title":"<code>distribute_samples_to_plates(plate_layout, allow_group_split=False, N_samples_desired_plate=None)</code>","text":"<p>Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.</p> <p>This method iterates through the study's specimen records and distributes them across multiple plates  according to the provided plate layout. It supports options to either keep specimen groups together or  allow splitting them across different plates. The method can also handle a specified number of samples  per plate if desired.</p> <p>Parameters:</p> Name Type Description Default <code>plate_layout</code> <code>Union[Plate, QCPlate]</code> <p>The layout template for the plates. This can be an instance of  'Plate' or 'QCPlate'.</p> required <code>allow_group_split</code> <code>bool</code> <p>If False (default), keeps specimens within the same group on the  same plate. If True, allows splitting groups across plates.</p> <code>False</code> <code>N_samples_desired_plate</code> <code>Optional[int]</code> <p>The desired number of samples per plate. If not  specified, fills each plate to its capacity.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the group column is not defined in the specimen records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n&gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n# This will distribute the specimens across plates, keeping groups together.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def distribute_samples_to_plates(self, plate_layout: Union[Plate, QCPlate], allow_group_split=False, N_samples_desired_plate=None) -&gt; None:\n    \"\"\"\n    Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.\n\n    This method iterates through the study's specimen records and distributes them across multiple plates \n    according to the provided plate layout. It supports options to either keep specimen groups together or \n    allow splitting them across different plates. The method can also handle a specified number of samples \n    per plate if desired.\n\n    Args:\n        plate_layout (Union[Plate, QCPlate]): The layout template for the plates. This can be an instance of \n            'Plate' or 'QCPlate'.\n        allow_group_split (bool, optional): If False (default), keeps specimens within the same group on the \n            same plate. If True, allows splitting groups across plates.\n        N_samples_desired_plate (Optional[int], optional): The desired number of samples per plate. If not \n            specified, fills each plate to its capacity.\n\n    Raises:\n        ValueError: If the group column is not defined in the specimen records.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n        &gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n        # This will distribute the specimens across plates, keeping groups together.\n    \"\"\"\n\n    plate_number = 1\n    plates = []\n\n    # Copy the specimen data to work on\n    remaining_specimens = self.specimen_records_df.copy()\n\n    N_specimens = self.specimen_records_df.shape[0]\n\n    if N_samples_desired_plate is None:\n        N_samples_desired_plate = plate_layout.capacity\n\n    # N_QCsample_in_plate = plate_layout.get_metadata_as_numpy_array(\"QC\").sum()\n    # N_plates_estimate = N_specimens / (plate_layout._specimen_capacity)\n\n    while not remaining_specimens.empty:\n        current_plate = copy.deepcopy(plate_layout)\n        current_plate.plate_id = plate_number\n\n        # Select specimens for the current plate\n        N_remaining = remaining_specimens.shape[0]\n\n        # if the remaining samples can fit on a whole place we put them there,\n        # otherwise we place the desired number of samples on the plate.\n        # if not we \n        if N_remaining &lt; current_plate.capacity:\n            selected_specimens = remaining_specimens.head(current_plate.capacity)\n        else:\n            selected_specimens = remaining_specimens.head(N_samples_desired_plate)\n\n        if not allow_group_split:\n            # Extract unique group IDs from the selected specimens. This step identifies the distinct groups\n            # that are represented within the specimens currently being considered for this plate.\n            group_ids = selected_specimens[self._column_with_group_index].unique()\n\n            # Find all specimens in the remaining pool that belong to the same groups as the selected specimens.\n            specimens_in_groups = remaining_specimens[remaining_specimens[self._column_with_group_index].isin(group_ids)]\n\n            if len(specimens_in_groups) &gt; len(selected_specimens):\n                # If there are more specimens in the remaining pool belonging to the same groups,\n                # it indicates that the last group in 'selected_specimens' is split between this plate and the remaining pool.\n                # To avoid splitting the group, we modify 'selected_specimens' to exclude this last group.\n\n                # Determine the groups to keep on the current plate. This is done by excluding the last group ID\n                # from the list of unique group IDs in the selected specimens. This way, we ensure that an entire group \n                # is not split across plates.\n                groups_to_keep = group_ids[:-1]\n\n                # Update 'selected_specimens' to only include specimens from the groups that are not split.\n                selected_specimens = selected_specimens[selected_specimens[self._column_with_group_index].isin(groups_to_keep)]\n\n        # Remove selected specimens from the pool\n        remaining_specimens.drop(index=selected_specimens.index, inplace=True)\n        selected_specimens.reset_index(drop=True, inplace=True)\n        remaining_specimens.reset_index(drop=True, inplace=True)\n\n        # Add specimens to the current plate\n        current_plate = self._add_specimens_to_plate(current_plate, selected_specimens)\n        plates.append(current_plate)\n\n        plate_number += 1\n\n    self.plates = plates\n    self.total_plates = plate_number - 1\n\n    logger.info(f\"Distributed samples across {self.total_plates} plates.\")\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.load_sample_file","title":"<code>load_sample_file(records_file, sample_group_id_column=None, sample_id_column=None)</code>","text":"<p>Loads specimen records from a specified file into the study.</p> <p>This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame. It also identifies or sets the column used for grouping specimens.</p> <p>Parameters:</p> Name Type Description Default <code>records_file</code> <code>str</code> <p>The path to the file containing specimen records.</p> required <code>sample_group_id_column</code> <code>Optional[str]</code> <p>The column name in the file that represents the group ID of samples.  If None, the method attempts to find a suitable column automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the specified records_file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n&gt;&gt;&gt; study.specimen_records_df.shape\n(200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def load_sample_file(self, records_file: str, sample_group_id_column=None, sample_id_column=None) -&gt; None:\n    \"\"\"\n    Loads specimen records from a specified file into the study.\n\n    This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame.\n    It also identifies or sets the column used for grouping specimens.\n\n    Args:\n        records_file (str): The path to the file containing specimen records.\n        sample_group_id_column (Optional[str]): The column name in the file that represents the group ID of samples. \n            If None, the method attempts to find a suitable column automatically.\n\n    Raises:\n        FileExistsError: If the specified records_file does not exist.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n        &gt;&gt;&gt; study.specimen_records_df.shape\n        (200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n    \"\"\"\n    self.records_file_path = records_file\n    records_path = Path(records_file)\n\n    logger.debug(f\"Loading records file: {records_file}\")\n    extension = records_path.suffix\n\n    if not records_path.exists():\n        logger.error(f\"Could not find file {records_file}\")\n        raise FileExistsError(records_file)\n\n    if extension in [\".xlsx\", \".xls\"]:\n        logger.debug(\"Importing Excel file.\")\n        records = pd.read_excel(records_file)\n    elif extension == \".csv\":\n        logger.debug(\"Importing csv file.\")\n        records = pd.read_csv(records_file)\n    else:\n        logger.error(\"File extension not recognized\")\n        records = pd.DataFrame()\n\n    if sample_group_id_column is None:\n        self._column_with_group_index = Study._find_column_with_group_index(records)\n    else:\n        self._column_with_group_index = sample_group_id_column\n\n    logger.debug(f\"{records.shape[0]} specimens in file\")\n    logger.info(\"Metadata in file:\")\n    for col in records.columns:\n        logger.info(f\"\\t{col}\")\n\n    if sample_id_column:\n        logger.debug(f\"Sorting records in ascending order based on column '{sample_id_column}'\")\n        records = records.sort_values(by=[sample_id_column])\n\n    # if self._column_with_group_index:\n    #     logger.debug(f\"Sorting records in ascending order based on column '{self._column_with_group_index}'\")\n        # records = records.sort_values(by=[self._column_with_group_index])\n\n    self.specimen_records_df = records\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.plot_attribute_plate_distributions","title":"<code>plot_attribute_plate_distributions(attribute, normalize=False, colormap='tab20b', plt_style='ggplot')</code>","text":"<p>Plots a stacked bar chart for a specified attribute across different plates.</p> <p>This method retrieves distribution data for the given attribute and plots it  as a stacked bar chart. Each bar in the chart represents a different category  of the attribute, with segments in the bar showing the count or proportion  from each plate. The method supports normalization of the data and allows for  customization of the plot's colormap.</p> <p>Parameters:</p> Name Type Description Default <code>attribute</code> <code>str</code> <p>The attribute for which the distributions are plotted.</p> required <code>normalize</code> <code>bool</code> <p>If True, normalizes the counts within each  category to proportions that sum to 100%. Defaults to False.</p> <code>False</code> <code>colormap</code> <code>str</code> <p>The name of the matplotlib colormap to use for  the plot. Defaults to 'tab20b'.</p> <code>'tab20b'</code> <p>Returns:</p> Type Description <p>matplotlib.figure.Figure: The figure object containing the bar chart.</p> Source code in <code>src/plate_planner/study.py</code> <pre><code>def plot_attribute_plate_distributions(self, attribute, normalize=False, colormap='tab20b', plt_style=\"ggplot\"):\n    \"\"\"\n    Plots a stacked bar chart for a specified attribute across different plates.\n\n    This method retrieves distribution data for the given attribute and plots it \n    as a stacked bar chart. Each bar in the chart represents a different category \n    of the attribute, with segments in the bar showing the count or proportion \n    from each plate. The method supports normalization of the data and allows for \n    customization of the plot's colormap.\n\n    Args:\n        attribute (str): The attribute for which the distributions are plotted.\n        normalize (bool, optional): If True, normalizes the counts within each \n            category to proportions that sum to 100%. Defaults to False.\n        colormap (str, optional): The name of the matplotlib colormap to use for \n            the plot. Defaults to 'tab20b'.\n\n    Returns:\n        matplotlib.figure.Figure: The figure object containing the bar chart.\n    \"\"\"\n\n    distributions = self.get_attribute_plate_distributions(attribute=attribute, normalize=False)\n\n    # Convert the dictionary to a DataFrame and rename columns\n    df = pd.DataFrame(distributions)\n    df.columns = [f\"plate_{key}\" for key in distributions.keys()]\n\n    if normalize:\n        # Normalize each column to sum to 100%\n        df = df.div(df.sum(axis=1), axis=0) * 100\n\n    # Plotting the stacked bar chart\n    plt.style.use(plt_style)\n    fig, ax = plt.subplots()\n\n    # Apply the chosen colormap\n    df.plot(kind='bar', stacked=True, ax=ax, colormap=colormap)\n\n    # Set titles and labels\n    ax.set_title(f\"Counts of {attribute} across plates\" + (\" (Normalized)\" if normalize else \"\"))\n    ax.set_xlabel(f\"{attribute}\")\n    ax.set_ylabel('Proportion (%)' if normalize else 'Counts')\n\n    # Place the legend outside of the plotting area\n    ax.legend(title=\"Plates\", bbox_to_anchor=(1.05, 1), loc='upper left')\n\n    # Rotate and align x-axis labels\n    plt.xticks(rotation=45, ha='right')\n\n    return fig\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.position_sample_within_groups","title":"<code>position_sample_within_groups(sortby_column, sample_value, position_index)</code>","text":"<p>Repositions a specific sample within each group based on a specified value and index.</p> <p>This method allows altering the position of a sample within each group in the specimen records DataFrame. It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group to the specified 'position_index'. The method is useful for customizing the order of samples within groups based on specific criteria or requirements.</p> <p>Parameters:</p> Name Type Description Default <code>sortby_column</code> <code>str</code> <p>The column name in the specimen records DataFrame to identify the sample.</p> required <code>sample_value</code> <code>Any</code> <p>The value in the 'sortby_column' that identifies the sample to reposition.</p> required <code>position_index</code> <code>int</code> <p>The new index within the group where the sample should be positioned.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no group column is defined in the Study instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n# This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def position_sample_within_groups(self, sortby_column: str, sample_value: Any, position_index: int) -&gt; None:\n    \"\"\"\n    Repositions a specific sample within each group based on a specified value and index.\n\n    This method allows altering the position of a sample within each group in the specimen records DataFrame.\n    It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group\n    to the specified 'position_index'. The method is useful for customizing the order of samples within groups\n    based on specific criteria or requirements.\n\n    Args:\n        sortby_column (str): The column name in the specimen records DataFrame to identify the sample.\n        sample_value (Any): The value in the 'sortby_column' that identifies the sample to reposition.\n        position_index (int): The new index within the group where the sample should be positioned.\n\n    Raises:\n        ValueError: If no group column is defined in the Study instance.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n        # This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n    \"\"\"\n    if self._column_with_group_index:\n        logger.info(f\"Positioning sample within {self._column_with_group_index} based on {sortby_column} value {sample_value} at index {position_index}\")\n        # Step 1: Group the DataFrame by 'group_ID'\n        grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n        # Step 2: Modify each group\n        modified_groups = []\n        for _, group in grouped:\n            # Find the row to reposition\n            sample_row = group[group[sortby_column] == sample_value]\n\n            # Remove this row from the group\n            group = group[group[sortby_column] != sample_value]\n\n            # Split the group at the specified position index\n            first_part = group.iloc[:position_index]\n            second_part = group.iloc[position_index:]\n\n            # Concatenate first part, sample row, and second part\n            modified_group = pd.concat([first_part, sample_row, second_part])\n\n            modified_groups.append(modified_group)\n\n        # Step 3: Concatenate the modified groups back into a single DataFrame\n        self.specimen_records_df = pd.concat(modified_groups).reset_index(drop=True)\n\n    else:\n        raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.randomize_order","title":"<code>randomize_order(case_control=None, reproducible=True)</code>","text":"<p>Randomizes the order of specimen records in the study, optionally maintaining group integrity.</p> <p>This method either randomizes the entire order of specimens or maintains the order within groups, depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.</p> <p>Parameters:</p> Name Type Description Default <code>case_control</code> <code>Optional[bool]</code> <p>If True, maintains group order (samples within a group are not shuffled). If False, shuffles all samples regardless of group. If None, the behavior is determined based on  the presence of a group index column.</p> <code>None</code> <code>reproducible</code> <code>bool</code> <p>If True, uses a fixed seed for randomization to ensure reproducibility.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n&gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.randomize_order(case_control=True)\n&gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def randomize_order(self, case_control : bool = None, reproducible=True) -&gt; None:\n    \"\"\"\n    Randomizes the order of specimen records in the study, optionally maintaining group integrity.\n\n    This method either randomizes the entire order of specimens or maintains the order within groups,\n    depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.\n\n    Args:\n        case_control (Optional[bool]): If True, maintains group order (samples within a group are not shuffled).\n            If False, shuffles all samples regardless of group. If None, the behavior is determined based on \n            the presence of a group index column.\n        reproducible (bool): If True, uses a fixed seed for randomization to ensure reproducibility.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n        &gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.randomize_order(case_control=True)\n        &gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n    \"\"\"\n\n    if not len(self.specimen_records_df) &gt; 0:\n        logger.error(\"There are no study records loaded. Use 'load_specimen_records' method to import study records.\")\n        return\n\n    if case_control is None:\n        if self._column_with_group_index:\n            case_control = True\n        else:\n            case_control = False\n\n    specimen_records_df_copy = self.specimen_records_df.copy()\n\n    if case_control:\n        column_with_group_index = self._column_with_group_index\n\n        logger.debug(f\"Randomly permuting group order (samples within group unchanged) using variable '{column_with_group_index}'\")\n        logger.debug(\"Creating multiindex dataframe\")\n        specimen_records_df_copy = specimen_records_df_copy.set_index([column_with_group_index, specimen_records_df_copy.index])\n        drop = False\n    else:\n        logger.debug(f\"Randomly permuting sample order.\")\n        specimen_records_df_copy = specimen_records_df_copy.set_index([specimen_records_df_copy.index, specimen_records_df_copy.index])\n        column_with_group_index = 0\n        drop = True\n\n\n    group_IDs = np.unique(specimen_records_df_copy.index.get_level_values(0))\n\n    # Permute order in table\n    if reproducible:\n        logger.info(f\"Using a fixed seed to random number generator for reproducibility; \\\n            running this method will always give the same result.\")\n        logger.debug(f\"Using class-determined seed {self._default_seed} for random number generator\")\n        np.random.seed(self._default_seed)\n\n    permutation_order = np.random.permutation(group_IDs)\n\n    prev_index_str = \"index_before_permutation\"\n\n    # if multiple randomization rounds, remove old column = prev_index_str \n    if prev_index_str in specimen_records_df_copy.columns:\n        specimen_records_df_copy = specimen_records_df_copy.drop(columns=prev_index_str)\n\n    specimen_records_df_copy = specimen_records_df_copy \\\n                                .loc[permutation_order]\\\n                                .reset_index(level=column_with_group_index, drop=drop)\\\n                                .reset_index(drop=False)\n\n    specimen_records_df_copy = specimen_records_df_copy.rename(columns = {\"index\": \"index_before_permutation\"})\n\n    self._N_permutations += 1\n    self.specimen_records_df = specimen_records_df_copy.copy()\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.sort_records_within_groups","title":"<code>sort_records_within_groups(sortby_column)</code>","text":"<p>Sorts specimen records within each group based on a specified column.</p> <p>This method groups the specimen records by a predefined group index column and then sorts each group's records based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame. This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.</p> <p>Parameters:</p> Name Type Description Default <code>sortby_column</code> <code>str</code> <p>The column name in the specimen records DataFrame to sort by within each group.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no group column is defined in the Study instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n# This will sort the specimen records within each group based on the \"Age\" column.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def sort_records_within_groups(self, sortby_column: str) -&gt; None:\n    \"\"\"\n    Sorts specimen records within each group based on a specified column.\n\n    This method groups the specimen records by a predefined group index column and then sorts each group's records\n    based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame.\n    This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.\n\n    Args:\n        sortby_column (str): The column name in the specimen records DataFrame to sort by within each group.\n\n    Raises:\n        ValueError: If no group column is defined in the Study instance.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n        # This will sort the specimen records within each group based on the \"Age\" column.\n    \"\"\"\n    if self._column_with_group_index:\n        logger.info(f\"Sorting samples within {self._column_with_group_index} by {sortby_column}\")\n        # Step 1: Group the DataFrame by 'group_ID'\n        grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n        # Step 2: Sort each group by the 'sortby_column' column\n        sorted_groups = [group.sort_values(sortby_column) for _, group in grouped]\n\n        # Step 3: Concatenate the sorted groups back into a single DataFrame\n        self.specimen_records_df = pd.concat(sorted_groups)\n\n    else:\n        raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Converts the data from all plates in the study into a single Pandas DataFrame.</p> <p>This method iterates over each plate in the study and converts its data to a DataFrame.  These DataFrames are then concatenated into a single DataFrame representing the entire study.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing data from all plates in the study.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study_df = study.to_dataframe()\n&gt;&gt;&gt; study_df.head()\n# Displays the first few rows of the combined DataFrame for the study.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Converts the data from all plates in the study into a single Pandas DataFrame.\n\n    This method iterates over each plate in the study and converts its data to a DataFrame. \n    These DataFrames are then concatenated into a single DataFrame representing the entire study.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing data from all plates in the study.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study_df = study.to_dataframe()\n        &gt;&gt;&gt; study_df.head()\n        # Displays the first few rows of the combined DataFrame for the study.\n    \"\"\"\n    dfs = []\n    for plate in self:\n        dfs.append(plate.as_dataframe())\n    return pd.concat(dfs).reset_index(drop=True)\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.to_layout_figures","title":"<code>to_layout_figures(annotation_metadata_key, color_metadata_key, file_format=None, folder_path=None, plate_name='Plate', **kwargs)</code>","text":"<p>Creates and visual representations of each plate in the study as figures.</p> <p>This method iterates over each plate in the study, generating a figure based on specified metadata keys for annotation and coloring. If the file format is specified, the figures are saved in the specified file format in a designated folder.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_metadata_key</code> <code>str</code> <p>The metadata key used for annotating elements in the figure.</p> required <code>color_metadata_key</code> <code>str</code> <p>The metadata key used for coloring elements in the figure.</p> required <code>file_format</code> <code>str</code> <p>The format in which to save the figures (default is 'pdf').</p> <code>None</code> <code>folder_path</code> <code>Optional[str]</code> <p>The path to the folder where the figures will be saved.  If None, the current working directory is used.</p> <code>None</code> <code>plate_name</code> <code>str</code> <p>A base name for the figure files.</p> <code>'Plate'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the <code>as_figure</code> method of each plate.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                        color_metadata_key=\"status\",\n                        file_format=\"png\",\n                        folder_path=\"/path/to/figures\",\n                        plate_name=\"study_plate\")\n# This will create and save figures for each plate in the '/path/to/figures' directory,\n# with annotations and colorings based on 'sample_id' and 'status'.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def to_layout_figures(self,\n                      annotation_metadata_key : str,\n                      color_metadata_key : str,\n                    file_format : str = None,\n                    folder_path : str = None,\n                    plate_name : str = \"Plate\", **kwargs) -&gt; None:\n    \"\"\"\n    Creates and visual representations of each plate in the study as figures.\n\n    This method iterates over each plate in the study, generating a figure based on specified metadata keys\n    for annotation and coloring. If the file format is specified, the figures are saved in the specified file format in a designated folder.\n\n    Args:\n        annotation_metadata_key (str): The metadata key used for annotating elements in the figure.\n        color_metadata_key (str): The metadata key used for coloring elements in the figure.\n        file_format (str, optional): The format in which to save the figures (default is 'pdf').\n        folder_path (Optional[str]): The path to the folder where the figures will be saved. \n            If None, the current working directory is used.\n        plate_name (str, optional): A base name for the figure files.\n        **kwargs: Additional keyword arguments passed to the `as_figure` method of each plate.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                                color_metadata_key=\"status\",\n                                file_format=\"png\",\n                                folder_path=\"/path/to/figures\",\n                                plate_name=\"study_plate\")\n        # This will create and save figures for each plate in the '/path/to/figures' directory,\n        # with annotations and colorings based on 'sample_id' and 'status'.\n    \"\"\"\n\n    if file_format is not None:\n        if folder_path is None:\n            folder_path = Path.cwd()\n        else:\n            folder_path = Path(folder_path)\n\n        # New folder path for \"layout_lists\"\n        new_folder_path = folder_path / \"layout_figures\"\n\n        # Create the \"layout_lists\" folder if it does not exist\n        new_folder_path.mkdir(parents=True, exist_ok=True)\n\n    for plate in self:\n        file_name = f\"{self.name}_{plate_name}_{plate.plate_id}_{annotation_metadata_key}_{color_metadata_key}.{file_format}\"\n        file_path = new_folder_path / file_name\n\n        # Define title        \n        title_str = f\"{self.name}: Plate {plate.plate_id}, showing {annotation_metadata_key} colored by {color_metadata_key}\"\n\n        fig = plate.as_figure(annotation_metadata_key, color_metadata_key, title_str=title_str, **kwargs)\n\n        logger.info(f\"Saving plate figure to {file_path}\")\n\n        if file_format:\n            fig.savefig(file_path)\n</code></pre>"},{"location":"study/#src.plate_planner.study.Study.to_layout_lists","title":"<code>to_layout_lists(metadata_keys=[], file_format='csv', folder_path=None, plate_name='plate')</code>","text":"<p>Exports the layout of each plate in the study to files in the specified format.</p> <p>This method iterates over each plate in the study and exports its layout to a file.  The files are saved in a specified format (CSV by default) and stored in a designated folder.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_keys</code> <code>list</code> <p>A list of metadata keys to include in the exported files.</p> <code>[]</code> <code>file_format</code> <code>str</code> <p>The file format for the exported layouts (e.g., 'csv').</p> <code>'csv'</code> <code>folder_path</code> <code>str</code> <p>The path to the folder where the layout files will be saved.  If None, the current working directory is used.</p> <code>None</code> <code>plate_name</code> <code>str</code> <p>A base name for the layout files.</p> <code>'plate'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                        file_format=\"csv\", \n                        folder_path=\"/path/to/layouts\", \n                        plate_name=\"experiment_plate\")\n# This will save layout files for each plate in the '/path/to/layouts' directory.\n</code></pre> Source code in <code>src/plate_planner/study.py</code> <pre><code>def to_layout_lists(self, metadata_keys: list = [], \n                file_format: str = \"csv\",\n                folder_path: str = None,\n                plate_name: str = \"plate\") -&gt; None:\n    \"\"\"\n    Exports the layout of each plate in the study to files in the specified format.\n\n    This method iterates over each plate in the study and exports its layout to a file. \n    The files are saved in a specified format (CSV by default) and stored in a designated folder.\n\n    Args:\n        metadata_keys (list, optional): A list of metadata keys to include in the exported files.\n        file_format (str, optional): The file format for the exported layouts (e.g., 'csv').\n        folder_path (str, optional): The path to the folder where the layout files will be saved. \n            If None, the current working directory is used.\n        plate_name (str, optional): A base name for the layout files.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                                file_format=\"csv\", \n                                folder_path=\"/path/to/layouts\", \n                                plate_name=\"experiment_plate\")\n        # This will save layout files for each plate in the '/path/to/layouts' directory.\n    \"\"\"\n\n    if folder_path is None:\n        folder_path = Path.cwd()\n    else:\n        folder_path = Path(folder_path)\n\n    # New folder path for \"layout_lists\"\n    new_folder_path = folder_path / \"layout_lists\"\n\n    # Create the \"layout_lists\" folder if it does not exist\n    new_folder_path.mkdir(parents=True, exist_ok=True)\n\n    for plate in self:\n        file_name = f\"{self.name}_{plate_name}_{plate.plate_id}\"\n        # Update file path to include the new folder\n        file_path = new_folder_path / file_name\n\n        plate.to_file(file_path=str(file_path),\n                    file_format=file_format,\n                    metadata_keys=metadata_keys)\n</code></pre>"}]}