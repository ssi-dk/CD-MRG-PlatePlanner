{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Easy Plate Layouts for LC-MS Studies and Beyond","text":"<p>PlatePlanner is a Python package designed to simplify plate layout creation for LC-MS studies, and is also applicable for various laboratory applications where sample distribution to plates is required, with or without QC sample patterns. Its user-friendly API supports dynamic QC sample patterns, easy creation of run lists, and plate visualizations.</p>"},{"location":"#key-features","title":"Key features","text":"<ul> <li>Dynamic QC Sample Patterns: Effortlessly create plate layouts with customizable QC sample patterns.</li> <li>Flexible Sample Distribution: Distribute samples within groups across plates, accommodating variable numbers of samples per group. This feature is ideal for studies with uneven sample time points or group sizes.</li> <li>Non-Split/ Split Group Handling: Choose to distribute samples within groups without splitting them over plates, or opt for splitting when necessary, offering you complete control over your sample layout.</li> <li>Customizable Run Lists &amp; Plate Visualizations: Generate detailed run lists and visualize plate assignments seamlessly.</li> <li>Block Randomization: Prevent run order bias by using the block randomization feature. </li> <li>NOT IMPLEMENTED: Stratified Randomization for Sample Balance: Prevent bias in sample group characteristics. This feature ensures an even distribution of important group attributes (like gender, age, disease status, etc.) across all LC-MS plates or batches. </li> </ul>"},{"location":"#installation","title":"Installation","text":"<pre><code>pip install plate-planner\n</code></pre>"},{"location":"#example","title":"Example","text":"<p>Here's a quick guide to using PlatePlanner:</p> <pre><code>from plate_layout import Study, QCPlate\n\n# create a study and load your sfile with sample records (csv, xls/xlsx)\nstudy = Study.(name=\"cancer\")\nstudy.load_specimen_records(\n        records_file = \"./data/study_samples.csv\",\n        sample_group_id_column = \"pair_ID\",\n        sample_id_column = \"specimen_ID\"\n)\n\n# block randomize groups\nstudy.randomize_order(case_control=True, reproducible=False)\n\n# distribute samples to a 96-well plate with QC samples as defined in the toml file\nqc_plate = QCPlate(plate_dim=(8,12), QC_config=\"./data/plate_config_dynamic.toml\")\nstudy.distribute_samples_to_plates(plate_layout=qc_plate)\n\n\n# create visualization for plate 3\nfig = study[3].as_figure(color_metadata_key=\"organ\", annotation_metadata_key=\"object\", rotation=45, fontsize=8)\n\nfig = study[3].to_layout_figures(annotation_metadata_key=\"sample_name\", color_metadata_key=\"sample_code\", file_format=\"png\")\n</code></pre> <p></p> <p></p>"},{"location":"plate/","title":"Plate Documentation","text":""},{"location":"plate/#src.plate.Plate","title":"<code>Plate</code>","text":"<p>A class to represent a multiwell plate.</p> <p>This class manages a multiwell plate, with functionalities to access, modify, and visualize the wells, along with their metadata.</p> <p>Attributes:</p> Name Type Description <code>_default_n_rows</code> <code>int</code> <p>Default number of rows in the plate.</p> <code>_default_n_columns</code> <code>int</code> <p>Default number of columns in the plate.</p> <code>_default_well_color</code> <code>Tuple[float, float, float]</code> <p>Default RGB color of the wells.</p> <code>_default_exclude_metadata</code> <code>list</code> <p>Default metadata keys to exclude.</p> <code>_default_colormap</code> <code>str</code> <p>Default colormap for visualizations.</p> <p>Parameters:</p> Name Type Description Default <code>plate_dim</code> <code>Tuple[int, int]</code> <p>The dimensions of the plate as (rows, columns).</p> <code>None</code> <code>plate_id</code> <code>int</code> <p>A unique identifier for the plate.</p> <code>1</code> Source code in <code>src/plate.py</code> <pre><code>class Plate:\n    \"\"\"\n    A class to represent a multiwell plate.\n\n    This class manages a multiwell plate, with functionalities to access, modify, and visualize\n    the wells, along with their metadata.\n\n    Attributes:\n        _default_n_rows (int): Default number of rows in the plate.\n        _default_n_columns (int): Default number of columns in the plate.\n        _default_well_color (Tuple[float, float, float]): Default RGB color of the wells.\n        _default_exclude_metadata (list): Default metadata keys to exclude.\n        _default_colormap (str): Default colormap for visualizations.\n\n    Parameters:\n        plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n        plate_id (int, optional): A unique identifier for the plate.\n    \"\"\"\n\n    _default_n_rows: int = 8\n    _default_n_columns: int = 12\n    _default_well_color: Tuple[float, float, float] = (1, 1, 1)\n    _default_exclude_metadata = [\"rgb_color\", \"coordinate\"]\n    _default_colormap: str = \"tab20\"\n\n    def __init__(self, plate_dim: Union[Tuple[int, int], List[int], Dict[str, int], int] = None, plate_id: int = 1):\n        \"\"\"\n        Initialize a new Plate instance.\n\n        Parameters:\n            plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n                If None, default dimensions are used.\n            plate_id (int, optional): A unique identifier for the plate.\n\n        The constructor initializes the plate with the specified dimensions, generating wells \n        with default properties and assigning them unique coordinates and identifiers.\n\n        Examples:\n            Creating a Plate instance with default dimensions and a specific plate ID:\n\n            &gt;&gt;&gt; plate = Plate(plate_id=1)\n            &gt;&gt;&gt; plate.size  # This will depend on the default number of rows and columns\n            96  # Example output, assuming 8 rows x 12 columns\n\n        \"\"\"\n\n        self._n_rows, self._n_columns = self._parse_plate_dimensions(plate_dim)\n\n        self._rows = list(range(self._n_rows))\n        self._columns = list(range(self._n_columns))\n\n        self._alphanumerical_coordinates = self.create_alphanumerical_coordinates(self._rows, self._columns)\n        self._coordinates = self.create_index_coordinates(self._rows, self._columns)\n\n        self.size = self._n_rows * self._n_columns\n\n        self.wells = [Well(name=self._alphanumerical_coordinates[index], \n                           coordinate=(row, col), \n                           index=index, \n                           plate_id=plate_id, \n                           rgb_color=self._default_well_color)\n                      for index, (row, col) in enumerate(itertools.product(self._rows, self._columns))]\n\n        self.plate_id = plate_id\n\n        # dictionary to map well names to indices\n        self._name_to_index_map = {well.name: well.index for well in self.wells}\n        self._index_to_coordinates_map = {well.index: well.coordinate for well in self.wells}\n        self._index_to_name_map = {well.index: well.name for well in self.wells}\n\n        logger.info(f\"Created a {self._n_rows}x{self._n_columns} plate with {self.size} wells.\")\n\n    def __iter__(self):\n        return iter(self.wells)\n\n    def __len__(self):\n        \"\"\"\n        Returns the number of wells in the plate.\n\n        Returns:\n            int: The number of wells.\n        \"\"\"\n        return len(self.wells)\n\n    def __str__(self):\n        plate_summary = f\"Plate ID: {self.plate_id}\\n\"\n        plate_summary += f\"Dimensions: {self._n_rows} rows x {self._n_columns} columns\\n\"\n        plate_summary += \"Plate Layout (Well Names):\\n\"\n        plate_array_str = np.array_str(self.get_metadata_as_numpy_array(\"name\"))\n        plate_summary += plate_array_str\n        return plate_summary\n\n    def __getitem__(self, key: Union[int, Tuple[int,int], str]):\n        \"\"\"\n        Retrieve a well from the plate based on its index, coordinate, or name.\n\n        Parameters:\n            key (int, tuple, or str): The identifier for the well. Can be an integer index, \n            a tuple indicating row and column coordinates, or a string specifying the well's name.\n\n        Returns:\n            Well: The well object corresponding to the given key.\n\n        Raises:\n            TypeError: If the key is not an integer, tuple, or string.\n        \"\"\"\n        if isinstance(key, int):\n            # Access by index\n            return self.wells[key]\n        elif isinstance(key, tuple):\n            # Access by coordinate\n            index = self._coordinates_to_index(key)\n            return self.wells[index]\n        elif isinstance(key, str):\n            # Access by name\n            index = self._name_to_index_map[key]\n            return self.wells[index]\n        else:\n            raise TypeError(\"Key must be an integer, tuple, or string\")\n\n    def __setitem__(self, key, well_object: Well):\n        \"\"\"\n        Set or replace a well in the plate based on its index, coordinate, or name.\n\n        Parameters:\n            key (int, tuple, or str): The identifier for the well to be set or replaced. \n                Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.\n        well_object (Well): The well object to set at the specified key.\n\n        Raises:\n            ValueError: If the well_object is not an instance of Well.\n            IndexError: If the well index is out of range.\n            TypeError: If the key is not a string, integer, or tuple.\n        \"\"\"\n        if not isinstance(well_object, Well):\n            raise ValueError(\"Value must be an instance of Well\")\n\n        if isinstance(key, str):\n            index = self._name_to_index_map[key]\n            coordinate = self._index_to_coordinates_map[index]\n            name = key\n        elif isinstance(key, int):\n            if key &lt; 0 or key &gt;= len(self.wells):\n                raise IndexError(\"Well index out of range\")\n            index = key\n            coordinate = self._index_to_coordinates_map[index]\n            name = self.wells[index].name\n        elif isinstance(key, tuple):\n            index = self._coordinates_to_index(key)\n            coordinate = key\n            name = self._index_to_name_map(index)\n        else:\n            raise TypeError(\"Key must be a string, integer, or tuple\")\n\n        # Update the well object's attributes\n        well_object.name = name\n        well_object.coordinate = coordinate\n        well_object.index = index\n        well_object.plate_id = self.plate_id\n\n        # Update the well at the specified index on the plate\n        self.wells[index] = well_object\n        # Update the name-to-index mapping\n        self._name_to_index_map[name] = index\n\n    def _parse_plate_dimensions(self, plate_dim : Union[Tuple[int, int], List[int], Dict[str, int], int]):\n        \"\"\"\n        Parse the dimensions of the plate and return the number of rows and columns.\n\n        Parameters:\n            plate_dim (tuple, list, dict, or int): The dimensions of the plate. This can be a tuple or list \n                specifying (rows, columns), a dictionary with 'rows' and 'columns' keys, or an integer specifying \n                the total number of wells in a 2:3 format (e.g., 96 wells as 8x12).\n\n        Returns:\n            tuple: A tuple containing the number of rows and columns (rows, columns).\n\n        Raises:\n            ValueError: If the plate_dim format is unsupported or incorrect.\n        \"\"\"\n        if plate_dim is None:\n            return self._default_n_rows, self._default_n_columns\n\n        if isinstance(plate_dim, (tuple, list)):\n            if len(plate_dim) == 2:\n                return plate_dim\n            else:\n                raise ValueError(\"Plate dimension must be a tuple or list with two elements (rows, columns).\")\n\n        if isinstance(plate_dim, dict):\n            return plate_dim.get(\"rows\", self._default_n_rows), plate_dim.get(\"columns\", self._default_n_columns)\n\n        if isinstance(plate_dim, int):\n            # design a plate in format 2 : 3 as in \n            # 6, 12, 24, 48, 96, 384 or 1536 plates  \n            x = np.sqrt(plate_dim * 25 / 6)\n            return int(np.round(2/5*x)), int(np.round(3/5*x))\n\n        raise ValueError(\"Unsupported plate format: Must be a tuple, list, dict, or integer.\")\n\n    def _coordinates_to_index(self, coordinate: tuple):\n        \"\"\"\n        Convert a well coordinate to its corresponding index in the plate's well list.\n\n        Parameters:\n            coordinate (tuple): The row and column coordinate of the well (row, col).\n\n        Returns:\n            int: The index of the well corresponding to the given coordinate.\n\n        Raises:\n            IndexError: If the coordinate is out of range of the plate's dimensions.\n        \"\"\"\n        row, col = coordinate\n        if row &lt; 0 or row &gt;= self._n_rows or col &lt; 0 or col &gt;= self._n_columns:\n            raise IndexError(\"Coordinate out of range\")\n        return row * self._n_columns + col\n\n    def _to_numpy_array(self, data: list) -&gt; np.ndarray:\n        \"\"\"\n        Convert a list of data corresponding to each well into a numpy array matching the plate's layout.\n\n        Parameters:\n            data (list): A list of data values corresponding to each well in the plate.\n\n        Returns:\n            numpy.ndarray: A numpy array representing the plate's layout with the provided data.\n\n        Raises:\n            Warning: If the number of data elements does not match the plate's size.\n        \"\"\"\n        # Create an empty array of the right shape\n        plate_array = np.empty((self._n_rows, self._n_columns), dtype=object)\n\n        # Check if the data list matches the number of wells\n        if len(data) != self.size:\n            raise Warning(f\"Number of data elements ({len(data)}) does not match the plate's size ({self.size}).\")\n\n        # Populate the array with data\n        for i, (row, col) in enumerate(self._coordinates):\n            plate_array[row, col] = data[i]\n\n        return np.flipud(plate_array)  # Flip to match the physical layout\n\n    def get_metadata(self, metadata_key: Optional[str]) -&gt; list:\n        \"\"\"\n        Retrieve metadata values for all wells in the plate based on the specified key.\n\n        Parameters:\n            metadata_key (str, optional): The metadata key for which values are to be retrieved. \n                If None, a default value of 'NaN' is returned for each well.\n\n        Returns:\n            list: A list of metadata values for each well in the plate.\n        \"\"\"\n        if metadata_key is None:\n            return [\"NaN\" for _ in self.wells]\n\n        metadata_values = []\n        for well in self.wells:\n            value = well.get_attribute_or_metadata(metadata_key)\n            metadata_values.append(value)\n\n        return metadata_values\n\n    def get_metadata_as_numpy_array(self, metadata_key : str) -&gt; object:\n        \"\"\"\n        Retrieve metadata values for all wells in a numpy array format based on the specified key.\n\n        Parameters:\n            metadata_key (str): The metadata key for which values are to be retrieved.\n\n        Returns:\n            numpy.ndarray: A numpy array representing the metadata values for the plate's layout.\n        \"\"\"\n        metadata = self.get_metadata(metadata_key)\n        return self._to_numpy_array(metadata)\n\n    def assign_well_color(self, metadata_key: Optional[str], colormap: str) -&gt; None:\n        \"\"\"\n        Assign colors to each well in the plate based on the specified metadata key and colormap.\n\n        Parameters:\n            metadata_key (str, optional): The metadata key to use for coloring the wells. \n                If None, a default color is assigned to each well.\n        colormap (str): The name of the colormap to use for coloring the wells.\n\n        Raises:\n            ValueError: If the metadata_key is invalid or not found.\n        \"\"\"\n        if colormap is None:\n            colormap = self._default_colormap\n\n        self._metadata_color_map = {}\n\n        if metadata_key is not None:\n\n            metadata_values = self.get_metadata(metadata_key)\n            unique_values = set(metadata_values)\n\n            cmap = plt.get_cmap(colormap)\n            color_norm = mcolors.Normalize(vmin=0, vmax=len(unique_values) - 1)\n            scalar_map = cm.ScalarMappable(norm=color_norm, cmap=cmap)\n\n            for i, value in enumerate(unique_values):\n                if value is None or value == \"NaN\":\n                    self._metadata_color_map[value] = self._default_well_color\n                else:\n                    self._metadata_color_map[value] = scalar_map.to_rgba(i)[0:3]  # RGB color\n\n            for well in self.wells:\n                metadata_value = well.get_attribute_or_metadata(metadata_key)\n                well.rgb_color = self._metadata_color_map.get(metadata_value, self._default_well_color)\n        else:\n            # Assign default color when metadata_key is None\n            for well in self.wells:\n                well.rgb_color = self._default_well_color\n\n    def as_records(self):\n        \"\"\"\n        Convert the plate's well data into a list of dictionaries.\n\n        Each well's attributes are converted into a dictionary, and all these dictionaries\n        are compiled into a list, with one dictionary per well.\n\n        Returns:\n            list of dict: A list where each element is a dictionary representing a well's attributes.\n        \"\"\"\n        return [well.as_dict() for well in self]\n\n    def as_dataframe(self):\n        \"\"\"\n        Converts the plate data into a Pandas DataFrame.\n\n        Each well and its attributes are represented as a row in the DataFrame.\n\n        Returns:\n            pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.\n        \"\"\"\n        return pd.DataFrame(self.as_records())\n\n    def is_valid_metadata_key(self, key:str) -&gt; bool:\n        \"\"\"\n        Check if the provided key is a valid metadata key for the Well instances in the plate.\n\n        This method verifies whether the specified key is either a direct attribute of the Well instances\n        or a key within their metadata dictionary.\n\n        Parameters:\n            key (str): The key to check for validity as a metadata key.\n\n        Returns:\n            bool: True if the key is a valid metadata key, False otherwise.\n        \"\"\"\n        if not key:  # If key is None or empty\n            return False\n\n        # Check if the key is a direct attribute or in the metadata dictionary of any well\n        for well in self.wells:\n            if hasattr(well, key) or key in well.metadata:\n                return True\n\n        return False\n\n    def as_figure(self, annotation_metadata_key=None, \n                  color_metadata_key=None,\n                  fontsize=8,\n                  rotation=0,\n                  step=10,\n                  title_str=None,\n                  alpha=0.7,\n                  well_size=1200,\n                  fig_width=11.69,\n                  fig_height=8.27,\n                  dpi=100,\n                  plt_style=\"bmh\",\n                  grid_color=(1, 1, 1),\n                  edge_color=(0.5, 0.5, 0.5),\n                  legend_bb=(0.15, -0.15, 0.7, 1.3),\n                  legend_n_columns=6,\n                  colormap=None):\n        \"\"\"\n        Create a visual representation of the plate using matplotlib.\n\n        This method generates a figure representing the plate, with options for annotations,\n        coloring based on metadata, and various styling adjustments.\n\n        Parameters:\n            annotation_metadata_key (str, optional): Metadata key to use for annotating wells.\n            color_metadata_key (str, optional): Metadata key to determine the color of wells.\n            fontsize (int, optional): Font size for annotations. Default is 8.\n            rotation (int, optional): Rotation angle for annotations. Default is 0.\n            step (int, optional): Step size between wells in the grid. Default is 10.\n            title_str (str, optional): Title of the figure. If None, a default title is used.\n            alpha (float, optional): Alpha value for well colors. Default is 0.7.\n            well_size (int, optional): Size of the wells in the figure. Default is 1200.\n            fig_width (float, optional): Width of the figure. Default is 11.69.\n            fig_height (float, optional): Height of the figure. Default is 8.27.\n            dpi (int, optional): Dots per inch for the figure. Default is 100.\n            plt_style (str, optional): Matplotlib style to use. Default is 'bmh'.\n            grid_color (tuple, optional): Color for the grid. Default is (1, 1, 1).\n            edge_color (tuple, optional): Color for the edges of wells. Default is (0.5, 0.5, 0.5).\n            legend_bb (tuple, optional): Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).\n            legend_n_columns (int, optional): Number of columns in the legend. Default is 6.\n            colormap (str, optional): Colormap name for coloring wells. Uses default colormap if None.\n\n        Returns:\n            matplotlib.figure.Figure: A figure object representing the plate.\n\n        Raises:\n            ValueError: If provided metadata keys are not valid.\n        \"\"\"\n        colormap = colormap if colormap else self._default_colormap\n\n        # Validate metadata keys\n        if color_metadata_key and not self.is_valid_metadata_key(color_metadata_key):\n            raise ValueError(f\"Invalid color_metadata_key: {color_metadata_key}\")\n        if annotation_metadata_key and not self.is_valid_metadata_key(annotation_metadata_key):\n            raise ValueError(f\"Invalid annotation_metadata_key: {annotation_metadata_key}\")\n\n\n        # Define title\n        if not title_str:\n            title_str = f\"Plate {self.plate_id}\"\n            if annotation_metadata_key or color_metadata_key:\n                title_str += f\", showing {annotation_metadata_key or ''} colored by {color_metadata_key or ''}\"\n\n        # Assign colors to wells\n        self.assign_well_color(color_metadata_key, colormap)\n\n\n        # Prepare grid and data for plotting\n        minX, maxX, minY, maxY = 0, len(self._columns)*step, 0, len(self._rows)*step\n        x = np.arange(minX, maxX, step)\n        y = np.arange(minY, maxY, step)\n\n        # Generate grid with columns first (column-major format)\n        Xgrid, Ygrid = np.meshgrid(x, y[::-1])\n\n        size_grid = np.ones_like(Xgrid) * well_size\n\n        well_colors = np.ravel((self.get_metadata_as_numpy_array(\"rgb_color\")))\n\n        # Plot setup\n        plt.style.use(plt_style)\n        fig, ax = plt.subplots(figsize=(fig_width, fig_height), dpi=dpi)\n        ax.scatter(Xgrid, Ygrid, s=size_grid, c=well_colors, alpha=alpha, edgecolors=edge_color)\n\n        # Annotations\n        if annotation_metadata_key:\n            for well in self:\n                x_i = Xgrid[well.coordinate]\n                y_i = Ygrid[well.coordinate]\n                annotation_label = well.get_attribute_or_metadata(annotation_metadata_key)\n                ax.annotate(annotation_label, (x_i, y_i), ha='center', va='center', rotation=rotation, fontsize=fontsize)\n\n        # Legends\n        if color_metadata_key:\n            # Get unique categories and their corresponding colors\n            unique_categories = set(self.get_metadata(color_metadata_key))\n            legend_handles = [plt.Line2D([0], [0], marker='o', color=self._metadata_color_map.get(category, self._default_well_color), label=category, markersize=10, linestyle='None') \n                            for category in unique_categories]\n\n            ax.legend(handles=legend_handles, bbox_to_anchor=legend_bb, loc='lower center', frameon=False, labelspacing=1, ncol=legend_n_columns)\n\n        # Axis settings\n        # Move x-axis ticks to the top\n        ax.xaxis.tick_top()\n        ax.xaxis.set_label_position('top') \n\n        # Adjust the axis limits to fit the plot tightly\n        # Assuming 'step' is the distance between wells\n        ax.set_xlim(minX - step/2, maxX - step/2)\n        ax.set_ylim(minY - step/2, maxY - step/2)\n\n        # Set x and y tick labels\n        ax.set_xticks(x)\n        ax.set_xticklabels([str(i + 1) for i in self._columns])\n        ax.set_yticks(y)\n        ax.set_yticklabels(self.row_labels[::-1])\n\n        # Grid settings\n        ax.xaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n        ax.yaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n\n        ax.set_xlim(minX - maxX*0.08, maxX - maxX*0.035)\n        ax.set_ylim(minY - maxY*0.07, maxY - maxY*0.02)\n\n        # Set tick labels inside the plotting box\n        ax.tick_params(direction='in')\n\n        # Ugly but works to adjust label padding\n        TICK_PADDING = -20\n        xticks = [*ax.xaxis.get_major_ticks(), *ax.xaxis.get_minor_ticks()]\n        yticks = [*ax.yaxis.get_major_ticks(), *ax.yaxis.get_minor_ticks()]\n\n        for tick in (*xticks, *yticks):\n                tick.set_pad(TICK_PADDING)\n\n        ax.set_axisbelow(True)\n        ax.set_title(title_str)\n\n        # Set the position and size of the rounded rectangle\n        x = minX- maxX*0.03  # X-coordinate of the lower-left corner\n        y = minY - maxY*0.04 # Y-coordinate of the lower-left corner\n        width = maxX*0.975 # Width of the rectangle\n        height = maxY*0.955  # Height of the rectangle\n        border_radius = 1  # Radius of the rounded corners\n\n        edge_alpha = 0.1\n        line_width = 2  \n\n        # Create a rounded rectangle\n        rounded_rectangle = FancyBboxPatch((x, y), width, height, boxstyle=f\"round, pad={border_radius}\", lw=line_width,ec=(0, 0, 0, edge_alpha), fc=\"none\")\n\n        # Add the rounded rectangle to the axis\n        ax.add_patch(rounded_rectangle)\n\n        return fig\n\n    def to_file(self, file_path : str = None,\n                file_format : str = \"csv\",\n                metadata_keys : list = []) -&gt; None:\n        \"\"\"\n        Write the plate data to a file in the specified format.\n\n        The method supports various file formats such as CSV, TSV, and Excel. It allows \n        selection of specific metadata keys to be included in the output. If no file path \n        is specified, the file is saved in the current working directory with a default \n        name based on the plate ID.\n\n        Parameters:\n            file_path (str, optional): The path where the file will be saved. \n                If not specified, the file is saved in the current working directory.\n            file_format (str, optional): The format of the file ('csv', 'tsv', 'xls').\n            metadata_keys (list, optional): A list of metadata keys to include in the file. \n                If empty, all metadata except those in _default_exclude_metadata are included.\n\n        Raises:\n            ValueError: If an unsupported file format is specified.\n        \"\"\"\n\n        if file_path is None:\n            file_name = f\"plate_{self.plate_id}.{file_format}\"\n            file_path = Path.cwd() / file_name\n        else:\n            file_path = Path(file_path)\n            if file_path.is_dir():\n                file_name = f\"plate_{self.plate_id}.{file_format}\"\n                file_path = file_path / file_name\n            else:\n                if file_path.suffix == \"\":\n                    file_path = file_path.with_suffix(f\".{file_format}\")\n                else:\n                    file_format = file_path.suffix.lstrip('.')\n\n        logger.info(f\"Writing to file:\\n\\t{file_path}\")\n\n        df = self.as_dataframe()\n\n        if len(metadata_keys) &gt; 0:\n            df = df[metadata_keys]\n        else:  # use all metadata except those in default_exclude_metadata\n            df = df.drop(columns=self._default_exclude_metadata)\n\n        match file_format:\n            case \"csv\":\n                df.to_csv(file_path, index=False)\n\n            case \"tsv\":\n                df.to_csv(file_path, sep=\"\\t\", index=False)\n\n            case \"xls\":\n                df.to_excel(file_path, index=False)\n\n    def add_metadata(self, key, values):\n        \"\"\"\n        Add or update metadata for all wells in the plate. If a list of values is provided,\n        assign each value to the corresponding well. If a single value is provided, assign it to all wells.\n\n        Parameters:\n            key (str): The metadata key to add or update.\n            values: A single value or a list of values to set for the given metadata key. \n        \"\"\"\n        if isinstance(values, list):\n            # Case when values is a list\n            if len(values) != len(self.wells):\n                raise ValueError(\"The length of values list does not match the number of wells\")\n\n            for well, value in zip(self.wells, values):\n                well.metadata[key] = value\n        else:\n            # Case when a single value is provided\n            for well in self.wells:\n                well.metadata[key] = values\n\n    @property\n    def row_labels(self):\n        \"\"\"\n        Get the row labels for the plate.\n\n        This property generates a list of alphabetical characters representing the row labels\n        of the plate, based on the number of rows in the plate.\n\n        Returns:\n            list: A list of strings, each representing a row label.\n        \"\"\"\n        return list(string.ascii_uppercase)[:len(self._rows)]\n\n    @property\n    def column_labels(self):\n        \"\"\"\n        Get the column labels for the plate.\n\n        This property generates a list of numerical strings representing the column labels\n        of the plate, based on the number of columns in the plate.\n\n        Returns:\n            list: A list of strings, each representing a column label.\n        \"\"\"\n        return [str(row_id+1) for row_id in self._columns]\n\n    @property\n    def capacity(self):\n        \"\"\"\n        Get the number of samples that can be added to the plate, which is the same as the number of wells in this class\n        \"\"\"\n        return self.size\n\n    @property\n    def plate_id(self):\n        \"\"\"\n        Get the plate ID.\n\n        This property returns the unique identifier of the plate.\n\n        Returns:\n            int: The plate ID.\n        \"\"\"\n        return self._plate_id\n\n    @plate_id.setter\n    def plate_id(self, new_id):\n        \"\"\"\n        Set a new plate ID.\n\n        This method updates the plate ID and propagates the change to all the wells \n        within the plate.\n\n        Parameters:\n            new_id (int): The new plate ID to be set.\n        \"\"\"\n        self._plate_id = new_id\n        for well in self.wells:\n            well.plate_id = new_id\n\n    @staticmethod    \n    def create_index_coordinates(rows, columns) -&gt; list:\n        \"\"\"\n        Static method to create a list of index coordinates for the wells in a plate.\n\n        The method generates a grid of coordinates, counting from left to right, \n        starting at the well in the top left. It is used to map the wells to their \n        respective positions in the plate.\n\n        Parameters:\n            rows (iterable): An iterable representing the rows of the plate.\n            columns (iterable): An iterable representing the columns of the plate.\n\n        Returns:\n            list: A list of tuples, each representing the (row, column) index of a well.\n        \"\"\"\n        # count from left to right, starting at well in top left\n        return list(itertools.product(\n                                    range(len(rows)-1, -1, -1),\n                                    range(0, len(columns))\n                                    )\n                )\n\n    @staticmethod\n    def create_alphanumerical_coordinates(rows, columns):\n        \"\"\"\n        Static method to create alphanumerical coordinates for the wells.\n\n        Parameters:\n            rows (list): A list of row indices.\n            columns (list): A list of column indices.\n\n        Returns:\n            list: A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").\n        \"\"\"\n        row_labels = list(string.ascii_uppercase)[:len(rows)]\n        return [f\"{row_labels[row]}{col+1}\" for row, col in itertools.product(rows, columns)]\n</code></pre>"},{"location":"plate/#src.plate.Plate.capacity","title":"<code>capacity</code>  <code>property</code>","text":"<p>Get the number of samples that can be added to the plate, which is the same as the number of wells in this class</p>"},{"location":"plate/#src.plate.Plate.column_labels","title":"<code>column_labels</code>  <code>property</code>","text":"<p>Get the column labels for the plate.</p> <p>This property generates a list of numerical strings representing the column labels of the plate, based on the number of columns in the plate.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of strings, each representing a column label.</p>"},{"location":"plate/#src.plate.Plate.plate_id","title":"<code>plate_id</code>  <code>property</code> <code>writable</code>","text":"<p>Get the plate ID.</p> <p>This property returns the unique identifier of the plate.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The plate ID.</p>"},{"location":"plate/#src.plate.Plate.row_labels","title":"<code>row_labels</code>  <code>property</code>","text":"<p>Get the row labels for the plate.</p> <p>This property generates a list of alphabetical characters representing the row labels of the plate, based on the number of rows in the plate.</p> <p>Returns:</p> Name Type Description <code>list</code> <p>A list of strings, each representing a row label.</p>"},{"location":"plate/#src.plate.Plate.__getitem__","title":"<code>__getitem__(key)</code>","text":"<p>Retrieve a well from the plate based on its index, coordinate, or name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int, tuple, or str</code> <p>The identifier for the well. Can be an integer index, </p> required <p>Returns:</p> Name Type Description <code>Well</code> <p>The well object corresponding to the given key.</p> <p>Raises:</p> Type Description <code>TypeError</code> <p>If the key is not an integer, tuple, or string.</p> Source code in <code>src/plate.py</code> <pre><code>def __getitem__(self, key: Union[int, Tuple[int,int], str]):\n    \"\"\"\n    Retrieve a well from the plate based on its index, coordinate, or name.\n\n    Parameters:\n        key (int, tuple, or str): The identifier for the well. Can be an integer index, \n        a tuple indicating row and column coordinates, or a string specifying the well's name.\n\n    Returns:\n        Well: The well object corresponding to the given key.\n\n    Raises:\n        TypeError: If the key is not an integer, tuple, or string.\n    \"\"\"\n    if isinstance(key, int):\n        # Access by index\n        return self.wells[key]\n    elif isinstance(key, tuple):\n        # Access by coordinate\n        index = self._coordinates_to_index(key)\n        return self.wells[index]\n    elif isinstance(key, str):\n        # Access by name\n        index = self._name_to_index_map[key]\n        return self.wells[index]\n    else:\n        raise TypeError(\"Key must be an integer, tuple, or string\")\n</code></pre>"},{"location":"plate/#src.plate.Plate.__init__","title":"<code>__init__(plate_dim=None, plate_id=1)</code>","text":"<p>Initialize a new Plate instance.</p> <p>Parameters:</p> Name Type Description Default <code>plate_dim</code> <code>Tuple[int, int]</code> <p>The dimensions of the plate as (rows, columns). If None, default dimensions are used.</p> <code>None</code> <code>plate_id</code> <code>int</code> <p>A unique identifier for the plate.</p> <code>1</code> <p>The constructor initializes the plate with the specified dimensions, generating wells  with default properties and assigning them unique coordinates and identifiers.</p> <p>Examples:</p> <p>Creating a Plate instance with default dimensions and a specific plate ID:</p> <pre><code>&gt;&gt;&gt; plate = Plate(plate_id=1)\n&gt;&gt;&gt; plate.size  # This will depend on the default number of rows and columns\n96  # Example output, assuming 8 rows x 12 columns\n</code></pre> Source code in <code>src/plate.py</code> <pre><code>def __init__(self, plate_dim: Union[Tuple[int, int], List[int], Dict[str, int], int] = None, plate_id: int = 1):\n    \"\"\"\n    Initialize a new Plate instance.\n\n    Parameters:\n        plate_dim (Tuple[int, int], optional): The dimensions of the plate as (rows, columns).\n            If None, default dimensions are used.\n        plate_id (int, optional): A unique identifier for the plate.\n\n    The constructor initializes the plate with the specified dimensions, generating wells \n    with default properties and assigning them unique coordinates and identifiers.\n\n    Examples:\n        Creating a Plate instance with default dimensions and a specific plate ID:\n\n        &gt;&gt;&gt; plate = Plate(plate_id=1)\n        &gt;&gt;&gt; plate.size  # This will depend on the default number of rows and columns\n        96  # Example output, assuming 8 rows x 12 columns\n\n    \"\"\"\n\n    self._n_rows, self._n_columns = self._parse_plate_dimensions(plate_dim)\n\n    self._rows = list(range(self._n_rows))\n    self._columns = list(range(self._n_columns))\n\n    self._alphanumerical_coordinates = self.create_alphanumerical_coordinates(self._rows, self._columns)\n    self._coordinates = self.create_index_coordinates(self._rows, self._columns)\n\n    self.size = self._n_rows * self._n_columns\n\n    self.wells = [Well(name=self._alphanumerical_coordinates[index], \n                       coordinate=(row, col), \n                       index=index, \n                       plate_id=plate_id, \n                       rgb_color=self._default_well_color)\n                  for index, (row, col) in enumerate(itertools.product(self._rows, self._columns))]\n\n    self.plate_id = plate_id\n\n    # dictionary to map well names to indices\n    self._name_to_index_map = {well.name: well.index for well in self.wells}\n    self._index_to_coordinates_map = {well.index: well.coordinate for well in self.wells}\n    self._index_to_name_map = {well.index: well.name for well in self.wells}\n\n    logger.info(f\"Created a {self._n_rows}x{self._n_columns} plate with {self.size} wells.\")\n</code></pre>"},{"location":"plate/#src.plate.Plate.__len__","title":"<code>__len__()</code>","text":"<p>Returns the number of wells in the plate.</p> <p>Returns:</p> Name Type Description <code>int</code> <p>The number of wells.</p> Source code in <code>src/plate.py</code> <pre><code>def __len__(self):\n    \"\"\"\n    Returns the number of wells in the plate.\n\n    Returns:\n        int: The number of wells.\n    \"\"\"\n    return len(self.wells)\n</code></pre>"},{"location":"plate/#src.plate.Plate.__setitem__","title":"<code>__setitem__(key, well_object)</code>","text":"<p>Set or replace a well in the plate based on its index, coordinate, or name.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>int, tuple, or str</code> <p>The identifier for the well to be set or replaced.  Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.</p> required <p>well_object (Well): The well object to set at the specified key.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the well_object is not an instance of Well.</p> <code>IndexError</code> <p>If the well index is out of range.</p> <code>TypeError</code> <p>If the key is not a string, integer, or tuple.</p> Source code in <code>src/plate.py</code> <pre><code>def __setitem__(self, key, well_object: Well):\n    \"\"\"\n    Set or replace a well in the plate based on its index, coordinate, or name.\n\n    Parameters:\n        key (int, tuple, or str): The identifier for the well to be set or replaced. \n            Can be an integer index, a tuple indicating row and column coordinates, or a string specifying the well's name.\n    well_object (Well): The well object to set at the specified key.\n\n    Raises:\n        ValueError: If the well_object is not an instance of Well.\n        IndexError: If the well index is out of range.\n        TypeError: If the key is not a string, integer, or tuple.\n    \"\"\"\n    if not isinstance(well_object, Well):\n        raise ValueError(\"Value must be an instance of Well\")\n\n    if isinstance(key, str):\n        index = self._name_to_index_map[key]\n        coordinate = self._index_to_coordinates_map[index]\n        name = key\n    elif isinstance(key, int):\n        if key &lt; 0 or key &gt;= len(self.wells):\n            raise IndexError(\"Well index out of range\")\n        index = key\n        coordinate = self._index_to_coordinates_map[index]\n        name = self.wells[index].name\n    elif isinstance(key, tuple):\n        index = self._coordinates_to_index(key)\n        coordinate = key\n        name = self._index_to_name_map(index)\n    else:\n        raise TypeError(\"Key must be a string, integer, or tuple\")\n\n    # Update the well object's attributes\n    well_object.name = name\n    well_object.coordinate = coordinate\n    well_object.index = index\n    well_object.plate_id = self.plate_id\n\n    # Update the well at the specified index on the plate\n    self.wells[index] = well_object\n    # Update the name-to-index mapping\n    self._name_to_index_map[name] = index\n</code></pre>"},{"location":"plate/#src.plate.Plate.add_metadata","title":"<code>add_metadata(key, values)</code>","text":"<p>Add or update metadata for all wells in the plate. If a list of values is provided, assign each value to the corresponding well. If a single value is provided, assign it to all wells.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The metadata key to add or update.</p> required <code>values</code> <p>A single value or a list of values to set for the given metadata key.</p> required Source code in <code>src/plate.py</code> <pre><code>def add_metadata(self, key, values):\n    \"\"\"\n    Add or update metadata for all wells in the plate. If a list of values is provided,\n    assign each value to the corresponding well. If a single value is provided, assign it to all wells.\n\n    Parameters:\n        key (str): The metadata key to add or update.\n        values: A single value or a list of values to set for the given metadata key. \n    \"\"\"\n    if isinstance(values, list):\n        # Case when values is a list\n        if len(values) != len(self.wells):\n            raise ValueError(\"The length of values list does not match the number of wells\")\n\n        for well, value in zip(self.wells, values):\n            well.metadata[key] = value\n    else:\n        # Case when a single value is provided\n        for well in self.wells:\n            well.metadata[key] = values\n</code></pre>"},{"location":"plate/#src.plate.Plate.as_dataframe","title":"<code>as_dataframe()</code>","text":"<p>Converts the plate data into a Pandas DataFrame.</p> <p>Each well and its attributes are represented as a row in the DataFrame.</p> <p>Returns:</p> Type Description <p>pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.</p> Source code in <code>src/plate.py</code> <pre><code>def as_dataframe(self):\n    \"\"\"\n    Converts the plate data into a Pandas DataFrame.\n\n    Each well and its attributes are represented as a row in the DataFrame.\n\n    Returns:\n        pandas.DataFrame: A DataFrame representing the plate's wells and their attributes.\n    \"\"\"\n    return pd.DataFrame(self.as_records())\n</code></pre>"},{"location":"plate/#src.plate.Plate.as_figure","title":"<code>as_figure(annotation_metadata_key=None, color_metadata_key=None, fontsize=8, rotation=0, step=10, title_str=None, alpha=0.7, well_size=1200, fig_width=11.69, fig_height=8.27, dpi=100, plt_style='bmh', grid_color=(1, 1, 1), edge_color=(0.5, 0.5, 0.5), legend_bb=(0.15, -0.15, 0.7, 1.3), legend_n_columns=6, colormap=None)</code>","text":"<p>Create a visual representation of the plate using matplotlib.</p> <p>This method generates a figure representing the plate, with options for annotations, coloring based on metadata, and various styling adjustments.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_metadata_key</code> <code>str</code> <p>Metadata key to use for annotating wells.</p> <code>None</code> <code>color_metadata_key</code> <code>str</code> <p>Metadata key to determine the color of wells.</p> <code>None</code> <code>fontsize</code> <code>int</code> <p>Font size for annotations. Default is 8.</p> <code>8</code> <code>rotation</code> <code>int</code> <p>Rotation angle for annotations. Default is 0.</p> <code>0</code> <code>step</code> <code>int</code> <p>Step size between wells in the grid. Default is 10.</p> <code>10</code> <code>title_str</code> <code>str</code> <p>Title of the figure. If None, a default title is used.</p> <code>None</code> <code>alpha</code> <code>float</code> <p>Alpha value for well colors. Default is 0.7.</p> <code>0.7</code> <code>well_size</code> <code>int</code> <p>Size of the wells in the figure. Default is 1200.</p> <code>1200</code> <code>fig_width</code> <code>float</code> <p>Width of the figure. Default is 11.69.</p> <code>11.69</code> <code>fig_height</code> <code>float</code> <p>Height of the figure. Default is 8.27.</p> <code>8.27</code> <code>dpi</code> <code>int</code> <p>Dots per inch for the figure. Default is 100.</p> <code>100</code> <code>plt_style</code> <code>str</code> <p>Matplotlib style to use. Default is 'bmh'.</p> <code>'bmh'</code> <code>grid_color</code> <code>tuple</code> <p>Color for the grid. Default is (1, 1, 1).</p> <code>(1, 1, 1)</code> <code>edge_color</code> <code>tuple</code> <p>Color for the edges of wells. Default is (0.5, 0.5, 0.5).</p> <code>(0.5, 0.5, 0.5)</code> <code>legend_bb</code> <code>tuple</code> <p>Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).</p> <code>(0.15, -0.15, 0.7, 1.3)</code> <code>legend_n_columns</code> <code>int</code> <p>Number of columns in the legend. Default is 6.</p> <code>6</code> <code>colormap</code> <code>str</code> <p>Colormap name for coloring wells. Uses default colormap if None.</p> <code>None</code> <p>Returns:</p> Type Description <p>matplotlib.figure.Figure: A figure object representing the plate.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If provided metadata keys are not valid.</p> Source code in <code>src/plate.py</code> <pre><code>def as_figure(self, annotation_metadata_key=None, \n              color_metadata_key=None,\n              fontsize=8,\n              rotation=0,\n              step=10,\n              title_str=None,\n              alpha=0.7,\n              well_size=1200,\n              fig_width=11.69,\n              fig_height=8.27,\n              dpi=100,\n              plt_style=\"bmh\",\n              grid_color=(1, 1, 1),\n              edge_color=(0.5, 0.5, 0.5),\n              legend_bb=(0.15, -0.15, 0.7, 1.3),\n              legend_n_columns=6,\n              colormap=None):\n    \"\"\"\n    Create a visual representation of the plate using matplotlib.\n\n    This method generates a figure representing the plate, with options for annotations,\n    coloring based on metadata, and various styling adjustments.\n\n    Parameters:\n        annotation_metadata_key (str, optional): Metadata key to use for annotating wells.\n        color_metadata_key (str, optional): Metadata key to determine the color of wells.\n        fontsize (int, optional): Font size for annotations. Default is 8.\n        rotation (int, optional): Rotation angle for annotations. Default is 0.\n        step (int, optional): Step size between wells in the grid. Default is 10.\n        title_str (str, optional): Title of the figure. If None, a default title is used.\n        alpha (float, optional): Alpha value for well colors. Default is 0.7.\n        well_size (int, optional): Size of the wells in the figure. Default is 1200.\n        fig_width (float, optional): Width of the figure. Default is 11.69.\n        fig_height (float, optional): Height of the figure. Default is 8.27.\n        dpi (int, optional): Dots per inch for the figure. Default is 100.\n        plt_style (str, optional): Matplotlib style to use. Default is 'bmh'.\n        grid_color (tuple, optional): Color for the grid. Default is (1, 1, 1).\n        edge_color (tuple, optional): Color for the edges of wells. Default is (0.5, 0.5, 0.5).\n        legend_bb (tuple, optional): Bounding box for the legend. Default is (0.15, -0.15, 0.7, 1.3).\n        legend_n_columns (int, optional): Number of columns in the legend. Default is 6.\n        colormap (str, optional): Colormap name for coloring wells. Uses default colormap if None.\n\n    Returns:\n        matplotlib.figure.Figure: A figure object representing the plate.\n\n    Raises:\n        ValueError: If provided metadata keys are not valid.\n    \"\"\"\n    colormap = colormap if colormap else self._default_colormap\n\n    # Validate metadata keys\n    if color_metadata_key and not self.is_valid_metadata_key(color_metadata_key):\n        raise ValueError(f\"Invalid color_metadata_key: {color_metadata_key}\")\n    if annotation_metadata_key and not self.is_valid_metadata_key(annotation_metadata_key):\n        raise ValueError(f\"Invalid annotation_metadata_key: {annotation_metadata_key}\")\n\n\n    # Define title\n    if not title_str:\n        title_str = f\"Plate {self.plate_id}\"\n        if annotation_metadata_key or color_metadata_key:\n            title_str += f\", showing {annotation_metadata_key or ''} colored by {color_metadata_key or ''}\"\n\n    # Assign colors to wells\n    self.assign_well_color(color_metadata_key, colormap)\n\n\n    # Prepare grid and data for plotting\n    minX, maxX, minY, maxY = 0, len(self._columns)*step, 0, len(self._rows)*step\n    x = np.arange(minX, maxX, step)\n    y = np.arange(minY, maxY, step)\n\n    # Generate grid with columns first (column-major format)\n    Xgrid, Ygrid = np.meshgrid(x, y[::-1])\n\n    size_grid = np.ones_like(Xgrid) * well_size\n\n    well_colors = np.ravel((self.get_metadata_as_numpy_array(\"rgb_color\")))\n\n    # Plot setup\n    plt.style.use(plt_style)\n    fig, ax = plt.subplots(figsize=(fig_width, fig_height), dpi=dpi)\n    ax.scatter(Xgrid, Ygrid, s=size_grid, c=well_colors, alpha=alpha, edgecolors=edge_color)\n\n    # Annotations\n    if annotation_metadata_key:\n        for well in self:\n            x_i = Xgrid[well.coordinate]\n            y_i = Ygrid[well.coordinate]\n            annotation_label = well.get_attribute_or_metadata(annotation_metadata_key)\n            ax.annotate(annotation_label, (x_i, y_i), ha='center', va='center', rotation=rotation, fontsize=fontsize)\n\n    # Legends\n    if color_metadata_key:\n        # Get unique categories and their corresponding colors\n        unique_categories = set(self.get_metadata(color_metadata_key))\n        legend_handles = [plt.Line2D([0], [0], marker='o', color=self._metadata_color_map.get(category, self._default_well_color), label=category, markersize=10, linestyle='None') \n                        for category in unique_categories]\n\n        ax.legend(handles=legend_handles, bbox_to_anchor=legend_bb, loc='lower center', frameon=False, labelspacing=1, ncol=legend_n_columns)\n\n    # Axis settings\n    # Move x-axis ticks to the top\n    ax.xaxis.tick_top()\n    ax.xaxis.set_label_position('top') \n\n    # Adjust the axis limits to fit the plot tightly\n    # Assuming 'step' is the distance between wells\n    ax.set_xlim(minX - step/2, maxX - step/2)\n    ax.set_ylim(minY - step/2, maxY - step/2)\n\n    # Set x and y tick labels\n    ax.set_xticks(x)\n    ax.set_xticklabels([str(i + 1) for i in self._columns])\n    ax.set_yticks(y)\n    ax.set_yticklabels(self.row_labels[::-1])\n\n    # Grid settings\n    ax.xaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n    ax.yaxis.grid(color=grid_color, linestyle='dashed', linewidth=1)\n\n    ax.set_xlim(minX - maxX*0.08, maxX - maxX*0.035)\n    ax.set_ylim(minY - maxY*0.07, maxY - maxY*0.02)\n\n    # Set tick labels inside the plotting box\n    ax.tick_params(direction='in')\n\n    # Ugly but works to adjust label padding\n    TICK_PADDING = -20\n    xticks = [*ax.xaxis.get_major_ticks(), *ax.xaxis.get_minor_ticks()]\n    yticks = [*ax.yaxis.get_major_ticks(), *ax.yaxis.get_minor_ticks()]\n\n    for tick in (*xticks, *yticks):\n            tick.set_pad(TICK_PADDING)\n\n    ax.set_axisbelow(True)\n    ax.set_title(title_str)\n\n    # Set the position and size of the rounded rectangle\n    x = minX- maxX*0.03  # X-coordinate of the lower-left corner\n    y = minY - maxY*0.04 # Y-coordinate of the lower-left corner\n    width = maxX*0.975 # Width of the rectangle\n    height = maxY*0.955  # Height of the rectangle\n    border_radius = 1  # Radius of the rounded corners\n\n    edge_alpha = 0.1\n    line_width = 2  \n\n    # Create a rounded rectangle\n    rounded_rectangle = FancyBboxPatch((x, y), width, height, boxstyle=f\"round, pad={border_radius}\", lw=line_width,ec=(0, 0, 0, edge_alpha), fc=\"none\")\n\n    # Add the rounded rectangle to the axis\n    ax.add_patch(rounded_rectangle)\n\n    return fig\n</code></pre>"},{"location":"plate/#src.plate.Plate.as_records","title":"<code>as_records()</code>","text":"<p>Convert the plate's well data into a list of dictionaries.</p> <p>Each well's attributes are converted into a dictionary, and all these dictionaries are compiled into a list, with one dictionary per well.</p> <p>Returns:</p> Type Description <p>list of dict: A list where each element is a dictionary representing a well's attributes.</p> Source code in <code>src/plate.py</code> <pre><code>def as_records(self):\n    \"\"\"\n    Convert the plate's well data into a list of dictionaries.\n\n    Each well's attributes are converted into a dictionary, and all these dictionaries\n    are compiled into a list, with one dictionary per well.\n\n    Returns:\n        list of dict: A list where each element is a dictionary representing a well's attributes.\n    \"\"\"\n    return [well.as_dict() for well in self]\n</code></pre>"},{"location":"plate/#src.plate.Plate.assign_well_color","title":"<code>assign_well_color(metadata_key, colormap)</code>","text":"<p>Assign colors to each well in the plate based on the specified metadata key and colormap.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>The metadata key to use for coloring the wells.  If None, a default color is assigned to each well.</p> required <p>colormap (str): The name of the colormap to use for coloring the wells.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the metadata_key is invalid or not found.</p> Source code in <code>src/plate.py</code> <pre><code>def assign_well_color(self, metadata_key: Optional[str], colormap: str) -&gt; None:\n    \"\"\"\n    Assign colors to each well in the plate based on the specified metadata key and colormap.\n\n    Parameters:\n        metadata_key (str, optional): The metadata key to use for coloring the wells. \n            If None, a default color is assigned to each well.\n    colormap (str): The name of the colormap to use for coloring the wells.\n\n    Raises:\n        ValueError: If the metadata_key is invalid or not found.\n    \"\"\"\n    if colormap is None:\n        colormap = self._default_colormap\n\n    self._metadata_color_map = {}\n\n    if metadata_key is not None:\n\n        metadata_values = self.get_metadata(metadata_key)\n        unique_values = set(metadata_values)\n\n        cmap = plt.get_cmap(colormap)\n        color_norm = mcolors.Normalize(vmin=0, vmax=len(unique_values) - 1)\n        scalar_map = cm.ScalarMappable(norm=color_norm, cmap=cmap)\n\n        for i, value in enumerate(unique_values):\n            if value is None or value == \"NaN\":\n                self._metadata_color_map[value] = self._default_well_color\n            else:\n                self._metadata_color_map[value] = scalar_map.to_rgba(i)[0:3]  # RGB color\n\n        for well in self.wells:\n            metadata_value = well.get_attribute_or_metadata(metadata_key)\n            well.rgb_color = self._metadata_color_map.get(metadata_value, self._default_well_color)\n    else:\n        # Assign default color when metadata_key is None\n        for well in self.wells:\n            well.rgb_color = self._default_well_color\n</code></pre>"},{"location":"plate/#src.plate.Plate.create_alphanumerical_coordinates","title":"<code>create_alphanumerical_coordinates(rows, columns)</code>  <code>staticmethod</code>","text":"<p>Static method to create alphanumerical coordinates for the wells.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>list</code> <p>A list of row indices.</p> required <code>columns</code> <code>list</code> <p>A list of column indices.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").</p> Source code in <code>src/plate.py</code> <pre><code>@staticmethod\ndef create_alphanumerical_coordinates(rows, columns):\n    \"\"\"\n    Static method to create alphanumerical coordinates for the wells.\n\n    Parameters:\n        rows (list): A list of row indices.\n        columns (list): A list of column indices.\n\n    Returns:\n        list: A list of alphanumerical coordinates (e.g., \"A1\", \"B2\").\n    \"\"\"\n    row_labels = list(string.ascii_uppercase)[:len(rows)]\n    return [f\"{row_labels[row]}{col+1}\" for row, col in itertools.product(rows, columns)]\n</code></pre>"},{"location":"plate/#src.plate.Plate.create_index_coordinates","title":"<code>create_index_coordinates(rows, columns)</code>  <code>staticmethod</code>","text":"<p>Static method to create a list of index coordinates for the wells in a plate.</p> <p>The method generates a grid of coordinates, counting from left to right,  starting at the well in the top left. It is used to map the wells to their  respective positions in the plate.</p> <p>Parameters:</p> Name Type Description Default <code>rows</code> <code>iterable</code> <p>An iterable representing the rows of the plate.</p> required <code>columns</code> <code>iterable</code> <p>An iterable representing the columns of the plate.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of tuples, each representing the (row, column) index of a well.</p> Source code in <code>src/plate.py</code> <pre><code>@staticmethod    \ndef create_index_coordinates(rows, columns) -&gt; list:\n    \"\"\"\n    Static method to create a list of index coordinates for the wells in a plate.\n\n    The method generates a grid of coordinates, counting from left to right, \n    starting at the well in the top left. It is used to map the wells to their \n    respective positions in the plate.\n\n    Parameters:\n        rows (iterable): An iterable representing the rows of the plate.\n        columns (iterable): An iterable representing the columns of the plate.\n\n    Returns:\n        list: A list of tuples, each representing the (row, column) index of a well.\n    \"\"\"\n    # count from left to right, starting at well in top left\n    return list(itertools.product(\n                                range(len(rows)-1, -1, -1),\n                                range(0, len(columns))\n                                )\n            )\n</code></pre>"},{"location":"plate/#src.plate.Plate.get_metadata","title":"<code>get_metadata(metadata_key)</code>","text":"<p>Retrieve metadata values for all wells in the plate based on the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>The metadata key for which values are to be retrieved.  If None, a default value of 'NaN' is returned for each well.</p> required <p>Returns:</p> Name Type Description <code>list</code> <code>list</code> <p>A list of metadata values for each well in the plate.</p> Source code in <code>src/plate.py</code> <pre><code>def get_metadata(self, metadata_key: Optional[str]) -&gt; list:\n    \"\"\"\n    Retrieve metadata values for all wells in the plate based on the specified key.\n\n    Parameters:\n        metadata_key (str, optional): The metadata key for which values are to be retrieved. \n            If None, a default value of 'NaN' is returned for each well.\n\n    Returns:\n        list: A list of metadata values for each well in the plate.\n    \"\"\"\n    if metadata_key is None:\n        return [\"NaN\" for _ in self.wells]\n\n    metadata_values = []\n    for well in self.wells:\n        value = well.get_attribute_or_metadata(metadata_key)\n        metadata_values.append(value)\n\n    return metadata_values\n</code></pre>"},{"location":"plate/#src.plate.Plate.get_metadata_as_numpy_array","title":"<code>get_metadata_as_numpy_array(metadata_key)</code>","text":"<p>Retrieve metadata values for all wells in a numpy array format based on the specified key.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_key</code> <code>str</code> <p>The metadata key for which values are to be retrieved.</p> required <p>Returns:</p> Type Description <code>object</code> <p>numpy.ndarray: A numpy array representing the metadata values for the plate's layout.</p> Source code in <code>src/plate.py</code> <pre><code>def get_metadata_as_numpy_array(self, metadata_key : str) -&gt; object:\n    \"\"\"\n    Retrieve metadata values for all wells in a numpy array format based on the specified key.\n\n    Parameters:\n        metadata_key (str): The metadata key for which values are to be retrieved.\n\n    Returns:\n        numpy.ndarray: A numpy array representing the metadata values for the plate's layout.\n    \"\"\"\n    metadata = self.get_metadata(metadata_key)\n    return self._to_numpy_array(metadata)\n</code></pre>"},{"location":"plate/#src.plate.Plate.is_valid_metadata_key","title":"<code>is_valid_metadata_key(key)</code>","text":"<p>Check if the provided key is a valid metadata key for the Well instances in the plate.</p> <p>This method verifies whether the specified key is either a direct attribute of the Well instances or a key within their metadata dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The key to check for validity as a metadata key.</p> required <p>Returns:</p> Name Type Description <code>bool</code> <code>bool</code> <p>True if the key is a valid metadata key, False otherwise.</p> Source code in <code>src/plate.py</code> <pre><code>def is_valid_metadata_key(self, key:str) -&gt; bool:\n    \"\"\"\n    Check if the provided key is a valid metadata key for the Well instances in the plate.\n\n    This method verifies whether the specified key is either a direct attribute of the Well instances\n    or a key within their metadata dictionary.\n\n    Parameters:\n        key (str): The key to check for validity as a metadata key.\n\n    Returns:\n        bool: True if the key is a valid metadata key, False otherwise.\n    \"\"\"\n    if not key:  # If key is None or empty\n        return False\n\n    # Check if the key is a direct attribute or in the metadata dictionary of any well\n    for well in self.wells:\n        if hasattr(well, key) or key in well.metadata:\n            return True\n\n    return False\n</code></pre>"},{"location":"plate/#src.plate.Plate.to_file","title":"<code>to_file(file_path=None, file_format='csv', metadata_keys=[])</code>","text":"<p>Write the plate data to a file in the specified format.</p> <p>The method supports various file formats such as CSV, TSV, and Excel. It allows  selection of specific metadata keys to be included in the output. If no file path  is specified, the file is saved in the current working directory with a default  name based on the plate ID.</p> <p>Parameters:</p> Name Type Description Default <code>file_path</code> <code>str</code> <p>The path where the file will be saved.  If not specified, the file is saved in the current working directory.</p> <code>None</code> <code>file_format</code> <code>str</code> <p>The format of the file ('csv', 'tsv', 'xls').</p> <code>'csv'</code> <code>metadata_keys</code> <code>list</code> <p>A list of metadata keys to include in the file.  If empty, all metadata except those in _default_exclude_metadata are included.</p> <code>[]</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If an unsupported file format is specified.</p> Source code in <code>src/plate.py</code> <pre><code>def to_file(self, file_path : str = None,\n            file_format : str = \"csv\",\n            metadata_keys : list = []) -&gt; None:\n    \"\"\"\n    Write the plate data to a file in the specified format.\n\n    The method supports various file formats such as CSV, TSV, and Excel. It allows \n    selection of specific metadata keys to be included in the output. If no file path \n    is specified, the file is saved in the current working directory with a default \n    name based on the plate ID.\n\n    Parameters:\n        file_path (str, optional): The path where the file will be saved. \n            If not specified, the file is saved in the current working directory.\n        file_format (str, optional): The format of the file ('csv', 'tsv', 'xls').\n        metadata_keys (list, optional): A list of metadata keys to include in the file. \n            If empty, all metadata except those in _default_exclude_metadata are included.\n\n    Raises:\n        ValueError: If an unsupported file format is specified.\n    \"\"\"\n\n    if file_path is None:\n        file_name = f\"plate_{self.plate_id}.{file_format}\"\n        file_path = Path.cwd() / file_name\n    else:\n        file_path = Path(file_path)\n        if file_path.is_dir():\n            file_name = f\"plate_{self.plate_id}.{file_format}\"\n            file_path = file_path / file_name\n        else:\n            if file_path.suffix == \"\":\n                file_path = file_path.with_suffix(f\".{file_format}\")\n            else:\n                file_format = file_path.suffix.lstrip('.')\n\n    logger.info(f\"Writing to file:\\n\\t{file_path}\")\n\n    df = self.as_dataframe()\n\n    if len(metadata_keys) &gt; 0:\n        df = df[metadata_keys]\n    else:  # use all metadata except those in default_exclude_metadata\n        df = df.drop(columns=self._default_exclude_metadata)\n\n    match file_format:\n        case \"csv\":\n            df.to_csv(file_path, index=False)\n\n        case \"tsv\":\n            df.to_csv(file_path, sep=\"\\t\", index=False)\n\n        case \"xls\":\n            df.to_excel(file_path, index=False)\n</code></pre>"},{"location":"plate/#src.plate.QCPlate","title":"<code>QCPlate</code>","text":"<p>             Bases: <code>Plate</code></p> <p>summary Class that represents a multiwell plate where some wells can  contain quality control samples according to the scheme defined  in QC_config; either a  file or a dict following the same structure <p>Parameters:</p> Name Type Description Default <code>Plate</code> <code>_type_</code> <p>description</p> required Source code in <code>src/plate.py</code> <pre><code>class QCPlate(Plate):\n    \"\"\"_summary_\n    Class that represents a multiwell plate where some wells can \n    contain quality control samples according to the scheme defined \n    in QC_config; either a &lt;config_file.toml&gt; file or a dict following the same structure\n\n    Args:\n        Plate (_type_): _description_\n    \"\"\"\n\n    _non_qc_sample_code : str = \"S\"\n    _non_qc_sample_name : str = \"Specimen\"\n\n    def __init__(self, QC_config = None, *args, **kwargs):\n        super().__init__(*args, **kwargs)\n\n        if QC_config is not None:\n\n            if isinstance(QC_config, dict):\n                self.config = QC_config\n            else:                                        \n                self.config = self.load_config_file(QC_config)\n\n            if self.config is not None: \n                self.create_QC_plate_layout()\n\n            else:\n                logger.error(f\"No scheme for QC samples provided.\")\n\n\n    def __repr__(self):\n        return f\"{self.__class__.__name__}(({len(self._rows)},{len(self._columns)}), plate_id={self.plate_id})\"\n\n    def __str__(self):\n        plate_summary = f\"Plate ID: {self.plate_id}\\n\"\n        plate_summary += f\"Dimensions: {self._n_rows} rows x {self._n_columns} columns\\n\"\n        plate_summary += \"Plate Layout (Sample Codes):\\n\"\n        plate_array_str = np.array_str(self.get_metadata_as_numpy_array(\"sample_code\"))\n        plate_summary += plate_array_str\n        return plate_summary\n\n    def define_unique_QC_sequences(self):\n        \"\"\" Sets up the unique QC sequences for each round based on the new config structure. \"\"\"\n        logger.debug(\"Setting up dynamic QC scheme from config file\")\n\n        # Initialize variables\n        total_wells = self.size\n        qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n        max_rounds = total_wells // qc_round_frequency\n\n        # Step 1: Initialize sequence map\n        self.qc_sequence_map = {round_num: None for round_num in range(1, max_rounds + 1)}\n\n        # Step 2: Apply specific round patterns\n        for key, value in self.config['QC']['patterns'].items():\n            if key.startswith('round_'):\n                round_number = int(key.split('_')[1])\n                self.qc_sequence_map[round_number] = value\n\n        # Step 3: Apply start/end patterns\n        if 'start' in self.config['QC']['patterns']:\n            self.qc_sequence_map[1] = self.config['QC']['patterns']['start']\n        if 'end' in self.config['QC']['patterns']:\n            self.qc_sequence_map[max_rounds] = self.config['QC']['patterns']['end']\n\n        # Step 4: Apply repeat pattern\n        if 'repeat_pattern' in self.config['QC']['patterns']:\n            repeat_config = self.config['QC']['patterns']['repeat_pattern']\n            pattern, times = repeat_config['pattern'], repeat_config['times']\n            for i in range(1, times + 1):\n                if self.qc_sequence_map[i] is None:\n                    self.qc_sequence_map[i] = pattern\n\n        # Step 5: Apply alternating patterns\n        if 'then_alternating' in self.config['QC']['patterns']:\n            alternating_patterns = self.config['QC']['patterns']['then_alternating']\n            alt_index = 0\n            for round_num in range(1, max_rounds + 1):\n                if self.qc_sequence_map[round_num] is None:\n                    self.qc_sequence_map[round_num] = alternating_patterns[alt_index % len(alternating_patterns)]\n                    alt_index += 1\n\n        # Step 6: Apply every N rounds patterns\n        every_n_patterns = {key: value for key, value in self.config['QC']['patterns'].items() if key.startswith('every_')}\n\n        for key, pattern in every_n_patterns.items():\n            # Correctly extract the frequency (e.g., 4 in 'every_4_rounds')\n            try:\n                frequency = int(''.join(filter(str.isdigit, key)))\n            except ValueError:\n                logger.error(f\"Invalid frequency format in pattern key: {key}\")\n                continue\n\n            for round_num in range(1, max_rounds + 1):\n                if round_num % frequency == 0 and self.qc_sequence_map[round_num] is None:\n                    self.qc_sequence_map[round_num] = pattern\n\n        # Log the defined sequences\n        for round_number, sequence in self.qc_sequence_map.items():\n            logger.debug(f\"Round {round_number}: {sequence}\")\n\n    def create_QC_plate_layout(self):\n        \"\"\" Creates the plate layout with QC and specimen samples. \"\"\"\n        logger.info(\"Creating dynamic plate layout with QC samples.\")\n\n        self.define_unique_QC_sequences()\n\n        # Initialize counters for QC sample types\n        counts = {qc_type: 0 for qc_type in self.config[\"QC\"][\"names\"].keys()}\n\n        round_counter = 1\n        specimen_counter = 0\n        qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n        start_with_qc = self.config['QC']['start_with_QC_round']\n        current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n        for well_index in range(self.size):\n            if start_with_qc and round_counter == 1:\n                try:\n                    # Place QC samples for the first round\n                    qc_sample = next(current_round_qc_samples)\n                    self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                    continue\n                except StopIteration:\n                    round_counter += 1\n                    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n            if specimen_counter &gt;= qc_round_frequency:\n                try:\n                    qc_sample = next(current_round_qc_samples)\n                    self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                except StopIteration:\n                    round_counter += 1\n                    specimen_counter = 0\n                    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n                    self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                    specimen_counter += 1\n            else:\n                self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                specimen_counter += 1\n\n        # Log the final layout\n        for well in self.wells:\n            logger.debug(f\"Well {well.name}: {well.metadata}\")\n\n    def assign_qc_sample_metadata(self, well_index, qc_sample, counts: dict):\n        self.wells[well_index].metadata[\"QC\"] = True\n        sample_code = qc_sample\n        counts[sample_code] += 1\n        self.wells[well_index].metadata[\"sample_code\"] = sample_code\n        self.wells[well_index].metadata[\"sample_type\"] = self.config[\"QC\"][\"names\"][sample_code]\n        self.wells[well_index].metadata[\"sample_name\"] = f\"{sample_code}{counts[sample_code]}\"\n\n    def assign_specimen_sample_metadata(self, well_index, count):\n        self.wells[well_index].metadata[\"QC\"] = False\n        self.wells[well_index].metadata[\"sample_code\"] = self._non_qc_sample_code\n        self.wells[well_index].metadata[\"sample_type\"] = self._non_qc_sample_name\n        self.wells[well_index].metadata[\"sample_name\"] = f\"{self._non_qc_sample_code}{count + 1}\"\n\n    @property\n    def capacity(self):\n        # number of non-QC samples that can be added to the plate - TODO change name?\n        return sum([not well.metadata[\"QC\"] for well in self.wells])\n\n    @staticmethod\n    def load_config_file(config_file: str = None) -&gt; dict:\n\n        # READ CONFIG FILE\n        if config_file is None: \n\n            logger.warning(\"No config file specified. Trying to find a toml file in current folder.\")\n\n            config_file_search = glob.glob(\"*.toml\")      \n\n            if config_file_search:\n                config_file = config_file_search[0]\n                logger.info(f\"Using toml file '{config_file}'\")\n\n        try:\n            with open(config_file, mode=\"rb\") as fp:\n                config = tomli.load(fp)\n\n            logger.info(f\"Successfully loaded config file {config_file}\")\n            logger.debug(f\"{config}\")\n\n            return config\n\n        except FileNotFoundError:\n            logger.error(f\"Could not find/open config file {config_file}\")\n\n            raise FileExistsError(config_file)            \n</code></pre>"},{"location":"plate/#src.plate.QCPlate.create_QC_plate_layout","title":"<code>create_QC_plate_layout()</code>","text":"<p>Creates the plate layout with QC and specimen samples.</p> Source code in <code>src/plate.py</code> <pre><code>def create_QC_plate_layout(self):\n    \"\"\" Creates the plate layout with QC and specimen samples. \"\"\"\n    logger.info(\"Creating dynamic plate layout with QC samples.\")\n\n    self.define_unique_QC_sequences()\n\n    # Initialize counters for QC sample types\n    counts = {qc_type: 0 for qc_type in self.config[\"QC\"][\"names\"].keys()}\n\n    round_counter = 1\n    specimen_counter = 0\n    qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n    start_with_qc = self.config['QC']['start_with_QC_round']\n    current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n    for well_index in range(self.size):\n        if start_with_qc and round_counter == 1:\n            try:\n                # Place QC samples for the first round\n                qc_sample = next(current_round_qc_samples)\n                self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n                continue\n            except StopIteration:\n                round_counter += 1\n                current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n\n        if specimen_counter &gt;= qc_round_frequency:\n            try:\n                qc_sample = next(current_round_qc_samples)\n                self.assign_qc_sample_metadata(well_index, qc_sample, counts)\n            except StopIteration:\n                round_counter += 1\n                specimen_counter = 0\n                current_round_qc_samples = iter(self.qc_sequence_map.get(round_counter, []))\n                self.assign_specimen_sample_metadata(well_index, specimen_counter)\n                specimen_counter += 1\n        else:\n            self.assign_specimen_sample_metadata(well_index, specimen_counter)\n            specimen_counter += 1\n\n    # Log the final layout\n    for well in self.wells:\n        logger.debug(f\"Well {well.name}: {well.metadata}\")\n</code></pre>"},{"location":"plate/#src.plate.QCPlate.define_unique_QC_sequences","title":"<code>define_unique_QC_sequences()</code>","text":"<p>Sets up the unique QC sequences for each round based on the new config structure.</p> Source code in <code>src/plate.py</code> <pre><code>def define_unique_QC_sequences(self):\n    \"\"\" Sets up the unique QC sequences for each round based on the new config structure. \"\"\"\n    logger.debug(\"Setting up dynamic QC scheme from config file\")\n\n    # Initialize variables\n    total_wells = self.size\n    qc_round_frequency = self.config['QC']['run_QC_after_n_specimens']\n    max_rounds = total_wells // qc_round_frequency\n\n    # Step 1: Initialize sequence map\n    self.qc_sequence_map = {round_num: None for round_num in range(1, max_rounds + 1)}\n\n    # Step 2: Apply specific round patterns\n    for key, value in self.config['QC']['patterns'].items():\n        if key.startswith('round_'):\n            round_number = int(key.split('_')[1])\n            self.qc_sequence_map[round_number] = value\n\n    # Step 3: Apply start/end patterns\n    if 'start' in self.config['QC']['patterns']:\n        self.qc_sequence_map[1] = self.config['QC']['patterns']['start']\n    if 'end' in self.config['QC']['patterns']:\n        self.qc_sequence_map[max_rounds] = self.config['QC']['patterns']['end']\n\n    # Step 4: Apply repeat pattern\n    if 'repeat_pattern' in self.config['QC']['patterns']:\n        repeat_config = self.config['QC']['patterns']['repeat_pattern']\n        pattern, times = repeat_config['pattern'], repeat_config['times']\n        for i in range(1, times + 1):\n            if self.qc_sequence_map[i] is None:\n                self.qc_sequence_map[i] = pattern\n\n    # Step 5: Apply alternating patterns\n    if 'then_alternating' in self.config['QC']['patterns']:\n        alternating_patterns = self.config['QC']['patterns']['then_alternating']\n        alt_index = 0\n        for round_num in range(1, max_rounds + 1):\n            if self.qc_sequence_map[round_num] is None:\n                self.qc_sequence_map[round_num] = alternating_patterns[alt_index % len(alternating_patterns)]\n                alt_index += 1\n\n    # Step 6: Apply every N rounds patterns\n    every_n_patterns = {key: value for key, value in self.config['QC']['patterns'].items() if key.startswith('every_')}\n\n    for key, pattern in every_n_patterns.items():\n        # Correctly extract the frequency (e.g., 4 in 'every_4_rounds')\n        try:\n            frequency = int(''.join(filter(str.isdigit, key)))\n        except ValueError:\n            logger.error(f\"Invalid frequency format in pattern key: {key}\")\n            continue\n\n        for round_num in range(1, max_rounds + 1):\n            if round_num % frequency == 0 and self.qc_sequence_map[round_num] is None:\n                self.qc_sequence_map[round_num] = pattern\n\n    # Log the defined sequences\n    for round_number, sequence in self.qc_sequence_map.items():\n        logger.debug(f\"Round {round_number}: {sequence}\")\n</code></pre>"},{"location":"plate/#src.plate.Well","title":"<code>Well</code>  <code>dataclass</code>","text":"<p>A class to represent a well in a multiwell plate.</p> <p>This class provides functionalities to represent and manipulate the properties  of a well, including its name, plate ID, coordinate, index, color, and metadata.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the well (default: \"A1\").</p> <code>plate_id</code> <code>int</code> <p>The ID of the plate the well belongs to (default: 1).</p> <code>coordinate</code> <code>Tuple[int, int]</code> <p>The (row, column) coordinate of the well in the plate (default: (0, 0)).</p> <code>index</code> <code>int</code> <p>The index of the well (optional).</p> <code>rgb_color</code> <code>Tuple[float, float, float]</code> <p>The RGB color representation of the well (default: (1, 1, 1)).</p> <code>metadata</code> <code>Dict[str, Any]</code> <p>Additional metadata for the well (default: empty dictionary).</p> Example <p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5),)</p> Source code in <code>src/plate.py</code> <pre><code>@dataclass\nclass Well:\n    \"\"\"\n    A class to represent a well in a multiwell plate.\n\n    This class provides functionalities to represent and manipulate the properties \n    of a well, including its name, plate ID, coordinate, index, color, and metadata.\n\n    Attributes:\n        name (str): The name of the well (default: \"A1\").\n        plate_id (int): The ID of the plate the well belongs to (default: 1).\n        coordinate (Tuple[int, int]): The (row, column) coordinate of the well in the plate (default: (0, 0)).\n        index (int): The index of the well (optional).\n        rgb_color (Tuple[float, float, float]): The RGB color representation of the well (default: (1, 1, 1)).\n        metadata (Dict[str, Any]): Additional metadata for the well (default: empty dictionary).\n\n    Example:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5),)\n    \"\"\"\n    name: str = \"A1\"\n    plate_id: int = 1\n    coordinate: Tuple[int, int] = field(default_factory=lambda: (0, 0))\n    index: int = None\n    rgb_color: Tuple[float, float, float] = field(default_factory=lambda: (1, 1, 1))\n    metadata: Dict[str, Any] = field(default_factory=dict)\n\n    def as_dict(self):\n        \"\"\"\n        Converts the well object to a dictionary.\n\n        The method returns a dictionary representation of the well object with the \n        direct attributes of the well and the keys in the metadata attribute.\n\n        Returns:\n            dict: A dictionary representation of the well object.\n\n        Example:\n            Convert a Well instance to a dictionary:\n            &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n            &gt;&gt;&gt; well_dict = well.as_dict()\n            &gt;&gt;&gt; print(well_dict)\n            {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 1), 'index': 5, 'rgb_color': (0.5, 0.5, 0.5)}\n\n        \"\"\"\n        attrib_dict = asdict(self)\n        del attrib_dict[\"metadata\"]\n        attrib_dict.update(self.metadata)\n\n        return attrib_dict\n\n    def get_attribute_or_metadata(self, key: str):\n        \"\"\"\n        Get the value of a direct attribute or a key in the metadata dictionary.\n\n        This method first checks if the provided key corresponds to a direct \n        attribute of the well object. If not, it then checks if the key exists \n        in the metadata dictionary.\n\n        Parameters:\n            key (str): The attribute name or metadata key.\n\n        Returns:\n            Any: The value of the attribute or metadata key, if found. Returns 'NaN' if not found.\n\n        Example:\n        # Retrieve attribute and metadata values from a Well instance:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n        &gt;&gt;&gt; well.metadata = {\"sample_type\": \"plasma\"}    \n        &gt;&gt;&gt; well.get_attribute_or_metadata(\"plate_id\")\n        2\n        &gt;&gt;&gt; well.get_attribute_or_metadata(\"sample_type\")\n        'plasma'\n        \"\"\"\n        # Check if it's a direct attribute\n        if hasattr(self, key):\n            return getattr(self, key, \"NaN\")\n            # return getattr(self, key, \"\")\n\n        # Check if it's a key in metadata\n        return self.metadata.get(key, \"NaN\")\n</code></pre>"},{"location":"plate/#src.plate.Well.as_dict","title":"<code>as_dict()</code>","text":"<p>Converts the well object to a dictionary.</p> <p>The method returns a dictionary representation of the well object with the  direct attributes of the well and the keys in the metadata attribute.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary representation of the well object.</p> Example <p>Convert a Well instance to a dictionary:</p> <p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5)) well_dict = well.as_dict() print(well_dict) {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 1), 'index': 5, 'rgb_color': (0.5, 0.5, 0.5)}</p> Source code in <code>src/plate.py</code> <pre><code>def as_dict(self):\n    \"\"\"\n    Converts the well object to a dictionary.\n\n    The method returns a dictionary representation of the well object with the \n    direct attributes of the well and the keys in the metadata attribute.\n\n    Returns:\n        dict: A dictionary representation of the well object.\n\n    Example:\n        Convert a Well instance to a dictionary:\n        &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n        &gt;&gt;&gt; well_dict = well.as_dict()\n        &gt;&gt;&gt; print(well_dict)\n        {'name': 'B2', 'plate_id': 2, 'coordinate': (1, 1), 'index': 5, 'rgb_color': (0.5, 0.5, 0.5)}\n\n    \"\"\"\n    attrib_dict = asdict(self)\n    del attrib_dict[\"metadata\"]\n    attrib_dict.update(self.metadata)\n\n    return attrib_dict\n</code></pre>"},{"location":"plate/#src.plate.Well.get_attribute_or_metadata","title":"<code>get_attribute_or_metadata(key)</code>","text":"<p>Get the value of a direct attribute or a key in the metadata dictionary.</p> <p>This method first checks if the provided key corresponds to a direct  attribute of the well object. If not, it then checks if the key exists  in the metadata dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>key</code> <code>str</code> <p>The attribute name or metadata key.</p> required <p>Returns:</p> Name Type Description <code>Any</code> <p>The value of the attribute or metadata key, if found. Returns 'NaN' if not found.</p> <p>Example:</p>"},{"location":"plate/#src.plate.Well.get_attribute_or_metadata--retrieve-attribute-and-metadata-values-from-a-well-instance","title":"Retrieve attribute and metadata values from a Well instance:","text":"<p>well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5)) well.metadata = {\"sample_type\": \"plasma\"}   well.get_attribute_or_metadata(\"plate_id\") 2 well.get_attribute_or_metadata(\"sample_type\") 'plasma'</p> Source code in <code>src/plate.py</code> <pre><code>def get_attribute_or_metadata(self, key: str):\n    \"\"\"\n    Get the value of a direct attribute or a key in the metadata dictionary.\n\n    This method first checks if the provided key corresponds to a direct \n    attribute of the well object. If not, it then checks if the key exists \n    in the metadata dictionary.\n\n    Parameters:\n        key (str): The attribute name or metadata key.\n\n    Returns:\n        Any: The value of the attribute or metadata key, if found. Returns 'NaN' if not found.\n\n    Example:\n    # Retrieve attribute and metadata values from a Well instance:\n    &gt;&gt;&gt; well = Well(name=\"B2\", plate_id=2, coordinate=(1, 1), index=5, rgb_color=(0.5, 0.5, 0.5))\n    &gt;&gt;&gt; well.metadata = {\"sample_type\": \"plasma\"}    \n    &gt;&gt;&gt; well.get_attribute_or_metadata(\"plate_id\")\n    2\n    &gt;&gt;&gt; well.get_attribute_or_metadata(\"sample_type\")\n    'plasma'\n    \"\"\"\n    # Check if it's a direct attribute\n    if hasattr(self, key):\n        return getattr(self, key, \"NaN\")\n        # return getattr(self, key, \"\")\n\n    # Check if it's a key in metadata\n    return self.metadata.get(key, \"NaN\")\n</code></pre>"},{"location":"qc_configfile/","title":"QC Configuration File","text":""},{"location":"qc_configfile/#overview","title":"Overview","text":"<p>The QC configuration file is in the TOML (Tom's Obvious, Minimal Language) format. It defines the distribution of Quality Control (QC) and specimen samples within a multiwell plate. This file is structured into several key sections, each tailored for different aspects of the plate layout.</p>"},{"location":"qc_configfile/#example","title":"Example","text":"<pre><code>[QC]\n# should first well(s) be a QC round?\nstart_with_QC_round = true\n# how many non-QC samples to analyze until we start a round of QC samples? \nrun_QC_after_n_specimens = 11 \n\n[QC.names] \n# Describes the key names and descriptions of the QC samples used.\nEC = \"EC: External_Control_(matrix)\"\nPB = \"PB: Paper_Blank\"\nPO = \"PO: Pooled_specimens\"\n\n[QC.patterns]\n# start = [\"EC\", \"PB\"]\nthen_alternating = [[\"EC\", \"PB\"], [\"EC\", \"PO\"]]\n</code></pre>"},{"location":"qc_configfile/#sections","title":"Sections","text":""},{"location":"qc_configfile/#qc-section","title":"[QC] Section","text":"<p>This section includes general settings for the QC layout.</p> <ul> <li><code>start_with_QC_round</code> (boolean): Determines whether the first wells should contain QC samples. Set to <code>true</code> to start with a QC round; <code>false</code> otherwise.</li> <li><code>run_QC_after_n_specimens</code> (integer): The number of non-QC (specimen) samples to analyze before starting a new round of QC samples.</li> </ul>"},{"location":"qc_configfile/#qcnames-section","title":"[QC.names] Section","text":"<p>Describes the key names and descriptions of the QC samples used. For example:</p> <ul> <li><code>EC</code> = \"EC: External_Control_(matrix)\"</li> <li><code>PB</code> = \"PB: Paper_Blank\"</li> <li><code>PO</code> = \"PO: Pooled_specimens\"</li> </ul>"},{"location":"qc_configfile/#qcpatterns-section","title":"[QC.patterns] Section","text":"<p>Defines the hierarchy and patterns for QC sample placement throughout the plate.</p>"},{"location":"qc_configfile/#hierarchy-of-patterns","title":"Hierarchy of Patterns:","text":"<ul> <li>Specific Round Patterns: Highest priority. Specific instructions for individual rounds (e.g., <code>round_3</code>).</li> <li>Start/End Patterns: Determine patterns for the beginning (<code>start</code>) and end (<code>end</code>) of the plate.</li> <li>Repeat Pattern: Specifies a pattern (<code>repeat_pattern</code>) to be repeated a certain number of times.</li> <li>Alternating Patterns: Defines alternating patterns (<code>then_alternating</code>) that provide a general structure.</li> <li>Every N Rounds Patterns: Lowest priority. General patterns applied every N rounds (e.g., <code>every_4_rounds</code>).</li> </ul>"},{"location":"qc_configfile/#pattern-examples","title":"Pattern Examples:","text":"<ul> <li><code>round_3 = [\"EC\", \"PO\", \"PB\"]</code>: Specific pattern for round 3.</li> <li><code>every_4_rounds = [\"EC\", \"PB\"]</code>: Pattern applied every 4 rounds.</li> <li><code>start = [\"EC\", \"PB\"]</code>: Pattern for the start of the plate.</li> <li><code>then_alternating = [[\"PB\", \"PO\"], [\"EC\", \"PO\"]]</code>: Alternating patterns.</li> <li><code>end = [\"PB\"]</code>: Pattern for the end of the plate.</li> <li><code>repeat_pattern = { pattern = [\"EC\", \"PB\"], times = 3 }</code>: Repeats the specified pattern 3 times.</li> </ul> <p>Note</p> <p>Ensure that the sum of all patterns does not exceed the plate capacity and that each pattern is configured correctly to avoid layout errors.</p>"},{"location":"study/","title":"Study Documentation","text":""},{"location":"study/#src.study.Study","title":"<code>Study</code>","text":"<p>A class to manage and manipulate study-related data, including specimen records, plate layouts,  and sample distributions.</p> <p>This class provides functionalities for loading specimen records, sorting and randomizing  specimen order, distributing specimens across plates, and exporting data to various formats.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>Name of the study.</p> <code>plates</code> <code>list</code> <p>List of Plate objects used in the study.</p> <code>total_plates</code> <code>int</code> <p>Total number of plates in the study.</p> <code>specimen_records_df</code> <code>DataFrame</code> <p>Pandas DataFrame holding specimen records.</p> <code>records_file_path</code> <code>str</code> <p>Path to the file containing specimen records.</p> <code>_column_with_group_index</code> <code>str</code> <p>Column name in specimen_records_df that holds group indices.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Cancer\")\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.randomize_order(case_control=True)\n</code></pre> <pre><code>&gt;&gt;&gt; qc_plate = QCPlate(QC_config=\"./data/plate_config_dynamic.toml\")\n&gt;&gt;&gt; study.randomize_order()\n&gt;&gt;&gt; study.distribute_samples_to_plates()\n&gt;&gt;&gt; study.to_layout_lists()\n</code></pre> Source code in <code>src/study.py</code> <pre><code>class Study:\n    \"\"\"\n    A class to manage and manipulate study-related data, including specimen records, plate layouts, \n    and sample distributions.\n\n    This class provides functionalities for loading specimen records, sorting and randomizing \n    specimen order, distributing specimens across plates, and exporting data to various formats.\n\n    Attributes:\n        name (str): Name of the study.\n        plates (list): List of Plate objects used in the study.\n        total_plates (int): Total number of plates in the study.\n        specimen_records_df (DataFrame): Pandas DataFrame holding specimen records.\n        records_file_path (str): Path to the file containing specimen records.\n        _column_with_group_index (str): Column name in specimen_records_df that holds group indices.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Cancer\")\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.randomize_order(case_control=True)\n\n        &gt;&gt;&gt; qc_plate = QCPlate(QC_config=\"./data/plate_config_dynamic.toml\")\n        &gt;&gt;&gt; study.randomize_order()\n        &gt;&gt;&gt; study.distribute_samples_to_plates()\n        &gt;&gt;&gt; study.to_layout_lists()\n    \"\"\"\n\n\n    _default_distribute_samples_equally : bool = False\n\n    _batch_count : int = 0\n    _iter_count : int = 0\n    _default_seed = 1234 # seed number for the random number generator in case randomization of specimens should be reproducible\n    _N_permutations : int = 0\n    _column_with_group_index : str = \"\"\n\n    def __init__(self, study_name=None,) -&gt; None:\n        \"\"\"\n        Initializes a new instance of the Study class.\n\n        This constructor sets up a study with a specified name. If no name is provided, a default name \n        is generated using the current date.\n\n        Args:\n            study_name (Optional[str]): The name for the study. If None, a default name in the format \n                \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.\n\n        Examples:\n            &gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n            &gt;&gt;&gt; study1.name\n            \"Alzheimer's Research\"\n\n            &gt;&gt;&gt; study2 = Study()\n            &gt;&gt;&gt; study2.name\n            \"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n        \"\"\"\n\n        if study_name is None:\n            study_name = f\"Study_{datetime.date}\"\n\n        self.name = study_name\n\n    def __iter__(self) -&gt; Iterator[Union[Plate, QCPlate]]:\n        \"\"\"\n        Initialize the iterator for the Study class.\n\n        This method sets up the class to iterate over its plates, resetting the internal counter \n        to zero. It allows the Study instance to be used in a loop (e.g., a for loop), \n        facilitating iteration over its plates.\n\n        Returns:\n            Iterator[Union[Plate, QCPlate]]: An iterator that yields either `Plate` or `QCPlate` \n            instances, allowing the Study instance to be used in a loop.\n        \"\"\"\n        self._iter_count = 0\n        return self\n\n    def __next__(self) -&gt; Union[Plate, QCPlate]:\n        \"\"\"\n        Proceed to the next plate in the Study class during iteration.\n\n        This method returns the next plate in the study, which can be either a `Plate` or a `QCPlate` instance.\n        It is automatically called in each iteration of a loop. When all plates have been iterated over,\n        it raises the StopIteration exception.\n\n        Returns:\n            Union[Plate, QCPlate]: The next plate in the study, either a `Plate` or `QCPlate` instance.\n\n        Raises:\n            StopIteration: If all plates have been iterated over.\n        \"\"\"\n        if self._iter_count &lt; self.total_plates:\n            plate_to_return = self.plates[self._iter_count]\n            self._iter_count += 1\n            return plate_to_return\n        else:\n            raise StopIteration\n\n    def __len__(self) -&gt; int:\n        \"\"\"\n        Return the total number of plates in the Study.\n\n        This method enables the use of the len() function on the Study instance.\n\n        Returns:\n            int: The number of plates in the study.\n        \"\"\"\n        return len(self.plates)\n\n    def __repr__(self) -&gt; str:\n        \"\"\"\n        Return an unambiguous string representation of the Study instance.\n\n        This method is useful for debugging and logging purposes, as it represents the Study\n        object in a clear and concise way.\n\n        Returns:\n            str: A string representation of the Study instance.\n        \"\"\"\n        return f\"Study({self.name})\"\n\n    def __str__(self) -&gt; str:\n        \"\"\"\n        Return a readable string representation of the Study instance.\n\n        This method provides a user-friendly string representation of the Study, which includes\n        its name, the number of study specimens, and the total number of plates.\n\n        Returns:\n            str: A string describing the Study instance.\n        \"\"\"\n        return f\"{self.name}\\n {self.study_specimens} on {self.total_plates}\"\n\n    def __getitem__(self, index) -&gt; Union[Plate, QCPlate]:\n        \"\"\"\n        Retrieve a specific plate from the study by its index.\n\n        This method allows for direct access to a plate in the study using the indexing syntax.\n\n        Args:\n            index (int): The index of the plate to retrieve.\n\n        Returns:\n            Union[Plate, QCPlate]: The plate at the specified index.\n\n        Raises:\n            IndexError: If the index is out of range of the plates list.\n        \"\"\"\n        return self.plates[index]\n\n    def load_specimen_records(self, records_file: str, sample_group_id_column=None, sample_id_column=None) -&gt; None:\n        \"\"\"\n        Loads specimen records from a specified file into the study.\n\n        This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame.\n        It also identifies or sets the column used for grouping specimens.\n\n        Args:\n            records_file (str): The path to the file containing specimen records.\n            sample_group_id_column (Optional[str]): The column name in the file that represents the group ID of samples. \n                If None, the method attempts to find a suitable column automatically.\n\n        Raises:\n            FileExistsError: If the specified records_file does not exist.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n            &gt;&gt;&gt; study.specimen_records_df.shape\n            (200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n        \"\"\"\n        self.records_file_path = records_file\n        records_path = Path(records_file)\n\n        logger.debug(f\"Loading records file: {records_file}\")\n        extension = records_path.suffix\n\n        if not records_path.exists():\n            logger.error(f\"Could not find file {records_file}\")\n            raise FileExistsError(records_file)\n\n        if extension in [\".xlsx\", \".xls\"]:\n            logger.debug(\"Importing Excel file.\")\n            records = pd.read_excel(records_file)\n        elif extension == \".csv\":\n            logger.debug(\"Importing csv file.\")\n            records = pd.read_csv(records_file)\n        else:\n            logger.error(\"File extension not recognized\")\n            records = pd.DataFrame()\n\n        if sample_group_id_column is None:\n            self._column_with_group_index = Study._find_column_with_group_index(records)\n        else:\n            self._column_with_group_index = sample_group_id_column\n\n        logger.debug(f\"{records.shape[0]} specimens in file\")\n        logger.info(\"Metadata in file:\")\n        for col in records.columns:\n            logger.info(f\"\\t{col}\")\n\n        if sample_id_column:\n            logger.debug(f\"Sorting records in ascending order based on column '{sample_id_column}'\")\n            records = records.sort_values(by=[sample_id_column])\n\n        # if self._column_with_group_index:\n        #     logger.debug(f\"Sorting records in ascending order based on column '{self._column_with_group_index}'\")\n            # records = records.sort_values(by=[self._column_with_group_index])\n\n        self.specimen_records_df = records\n\n    def sort_records_within_groups(self, sortby_column: str) -&gt; None:\n        \"\"\"\n        Sorts specimen records within each group based on a specified column.\n\n        This method groups the specimen records by a predefined group index column and then sorts each group's records\n        based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame.\n        This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.\n\n        Args:\n            sortby_column (str): The column name in the specimen records DataFrame to sort by within each group.\n\n        Raises:\n            ValueError: If no group column is defined in the Study instance.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n            # This will sort the specimen records within each group based on the \"Age\" column.\n        \"\"\"\n        if self._column_with_group_index:\n            logger.info(f\"Sorting samples within {self._column_with_group_index} by {sortby_column}\")\n            # Step 1: Group the DataFrame by 'group_ID'\n            grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n            # Step 2: Sort each group by the 'sortby_column' column\n            sorted_groups = [group.sort_values(sortby_column) for _, group in grouped]\n\n            # Step 3: Concatenate the sorted groups back into a single DataFrame\n            self.specimen_records_df = pd.concat(sorted_groups)\n\n        else:\n            raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n\n    def position_sample_within_groups(self, sortby_column: str, sample_value: Any, position_index: int) -&gt; None:\n        \"\"\"\n        Repositions a specific sample within each group based on a specified value and index.\n\n        This method allows altering the position of a sample within each group in the specimen records DataFrame.\n        It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group\n        to the specified 'position_index'. The method is useful for customizing the order of samples within groups\n        based on specific criteria or requirements.\n\n        Args:\n            sortby_column (str): The column name in the specimen records DataFrame to identify the sample.\n            sample_value (Any): The value in the 'sortby_column' that identifies the sample to reposition.\n            position_index (int): The new index within the group where the sample should be positioned.\n\n        Raises:\n            ValueError: If no group column is defined in the Study instance.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n            # This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n        \"\"\"\n        if self._column_with_group_index:\n            logger.info(f\"Positioning sample within {self._column_with_group_index} based on {sortby_column} value {sample_value} at index {position_index}\")\n            # Step 1: Group the DataFrame by 'group_ID'\n            grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n            # Step 2: Modify each group\n            modified_groups = []\n            for _, group in grouped:\n                # Find the row to reposition\n                sample_row = group[group[sortby_column] == sample_value]\n\n                # Remove this row from the group\n                group = group[group[sortby_column] != sample_value]\n\n                # Split the group at the specified position index\n                first_part = group.iloc[:position_index]\n                second_part = group.iloc[position_index:]\n\n                # Concatenate first part, sample row, and second part\n                modified_group = pd.concat([first_part, sample_row, second_part])\n\n                modified_groups.append(modified_group)\n\n            # Step 3: Concatenate the modified groups back into a single DataFrame\n            self.specimen_records_df = pd.concat(modified_groups).reset_index(drop=True)\n\n        else:\n            raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n\n    def _add_specimens_to_plate(self, study_plate: object, specimen_samples_df: object) -&gt; None:\n        \"\"\"\n        Adds specimens from a DataFrame to a specified plate based on well metadata.\n\n        This method iterates through each well of the given plate and, if the well's metadata indicates \n        it should contain a specimen (as marked by \"sample_code\" == \"S\"), adds specimen data from the \n        DataFrame to the well's metadata. The method stops adding specimens once all have been placed \n        or the plate is filled.\n\n        Args:\n            study_plate (Plate): The plate object to which specimens will be added.\n            specimen_samples_df (pd.DataFrame): DataFrame containing specimen data to be added to the plate.\n\n        Notes:\n            - This is a private method intended for internal use within the class.\n            - The method assumes that 'study_plate' is an instance of 'Plate' or a compatible type, and\n            'specimen_samples_df' is a Pandas DataFrame with columns corresponding to metadata fields.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study_plate = Plate(...)  # Assume Plate is properly initialized\n            &gt;&gt;&gt; specimens_df = pd.DataFrame(...)  # DataFrame with specimen data\n            &gt;&gt;&gt; study._add_specimens_to_plate(study_plate, specimens_df)\n            # Specimens from specimens_df are now added to the study_plate based on its well metadata\n        \"\"\"\n\n        logger.debug(f\"Adding {len(specimen_samples_df)} samples to plate {study_plate.plate_id}\")\n        columns = specimen_samples_df.columns\n\n        # keep track on how many wells we should use per batch\n        N_specimens_left = len(specimen_samples_df)\n        plate_specimen_count = 0\n\n        for i, well in enumerate(study_plate):\n\n            if well.metadata[\"sample_code\"] == \"S\": \n                # add metadata key (and values) for each column in dataframe\n                for col in columns:\n                    well.metadata[col] = specimen_samples_df[col][plate_specimen_count]\n\n                plate_specimen_count += 1\n\n            else:\n                # add metadata key and nan value for each column in dataframe\n                for col in columns:\n                    well.metadata[col] = \"NaN\"\n\n            study_plate[i] = well\n\n            if plate_specimen_count &gt;= N_specimens_left:\n                    logger.debug(f\"\\t -&gt; Done. Last specimen placed in {well.name}\")\n                    break\n\n        return study_plate\n\n        # --- END OF FOOR LOOP ---\n\n    def to_dataframe(self) -&gt; pd.DataFrame:\n        \"\"\"\n        Converts the data from all plates in the study into a single Pandas DataFrame.\n\n        This method iterates over each plate in the study and converts its data to a DataFrame. \n        These DataFrames are then concatenated into a single DataFrame representing the entire study.\n\n        Returns:\n            pd.DataFrame: A DataFrame containing data from all plates in the study.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study_df = study.to_dataframe()\n            &gt;&gt;&gt; study_df.head()\n            # Displays the first few rows of the combined DataFrame for the study.\n        \"\"\"\n        dfs = []\n        for plate in self:\n            dfs.append(plate.as_dataframe())\n        return pd.concat(dfs).reset_index(drop=True)\n\n    def to_layout_lists(self, metadata_keys: list = [], \n                    file_format: str = \"csv\",\n                    folder_path: str = None,\n                    plate_name: str = \"plate\") -&gt; None:\n        \"\"\"\n        Exports the layout of each plate in the study to files in the specified format.\n\n        This method iterates over each plate in the study and exports its layout to a file. \n        The files are saved in a specified format (CSV by default) and stored in a designated folder.\n\n        Args:\n            metadata_keys (list, optional): A list of metadata keys to include in the exported files.\n            file_format (str, optional): The file format for the exported layouts (e.g., 'csv').\n            folder_path (str, optional): The path to the folder where the layout files will be saved. \n                If None, the current working directory is used.\n            plate_name (str, optional): A base name for the layout files.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                                    file_format=\"csv\", \n                                    folder_path=\"/path/to/layouts\", \n                                    plate_name=\"experiment_plate\")\n            # This will save layout files for each plate in the '/path/to/layouts' directory.\n        \"\"\"\n\n        if folder_path is None:\n            folder_path = Path.cwd()\n        else:\n            folder_path = Path(folder_path)\n\n        # New folder path for \"layout_lists\"\n        new_folder_path = folder_path / \"layout_lists\"\n\n        # Create the \"layout_lists\" folder if it does not exist\n        new_folder_path.mkdir(parents=True, exist_ok=True)\n\n        for plate in self:\n            file_name = f\"{self.name}_{plate_name}_{plate.plate_id}\"\n            # Update file path to include the new folder\n            file_path = new_folder_path / file_name\n\n            plate.to_file(file_path=str(file_path),\n                        file_format=file_format,\n                        metadata_keys=metadata_keys)\n\n    def to_layout_figures(self,\n                          annotation_metadata_key : str,\n                          color_metadata_key : str,\n                        file_format : str = \"pdf\",\n                        folder_path : str = None,\n                        plate_name : str = \"Plate\", **kwargs) -&gt; None:\n        \"\"\"\n        Creates and saves visual representations of each plate in the study as figures.\n\n        This method iterates over each plate in the study, generating a figure based on specified metadata keys\n        for annotation and coloring. The figures are saved in the specified file format in a designated folder.\n\n        Args:\n            annotation_metadata_key (str): The metadata key used for annotating elements in the figure.\n            color_metadata_key (str): The metadata key used for coloring elements in the figure.\n            file_format (str, optional): The format in which to save the figures (default is 'pdf').\n            folder_path (Optional[str]): The path to the folder where the figures will be saved. \n                If None, the current working directory is used.\n            plate_name (str, optional): A base name for the figure files.\n            **kwargs: Additional keyword arguments passed to the `as_figure` method of each plate.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                                    color_metadata_key=\"status\",\n                                    file_format=\"png\",\n                                    folder_path=\"/path/to/figures\",\n                                    plate_name=\"study_plate\")\n            # This will create and save figures for each plate in the '/path/to/figures' directory,\n            # with annotations and colorings based on 'sample_id' and 'status'.\n        \"\"\"\n\n        if folder_path is None:\n            folder_path = Path.cwd()\n        else:\n            folder_path = Path(folder_path)\n\n        # New folder path for \"layout_lists\"\n        new_folder_path = folder_path / \"layout_figures\"\n\n        # Create the \"layout_lists\" folder if it does not exist\n        new_folder_path.mkdir(parents=True, exist_ok=True)\n\n        for plate in self:\n            file_name = f\"{self.name}_{plate_name}_{plate.plate_id}_{annotation_metadata_key}_{color_metadata_key}.{file_format}\"\n            file_path = new_folder_path / file_name\n\n            # Define title        \n            title_str = f\"{self.name}: Plate {plate.plate_id}, showing {annotation_metadata_key} colored by {color_metadata_key}\"\n\n            fig = plate.as_figure(annotation_metadata_key, color_metadata_key, title_str=title_str, **kwargs)\n\n            logger.info(f\"Saving plate figure to {file_path}\")\n\n            fig.savefig(file_path)\n\n    def distribute_samples_to_plates(self, plate_layout: Union[Plate, QCPlate], allow_group_split=False, N_samples_desired_plate=None) -&gt; None:\n        \"\"\"\n        Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.\n\n        This method iterates through the study's specimen records and distributes them across multiple plates \n        according to the provided plate layout. It supports options to either keep specimen groups together or \n        allow splitting them across different plates. The method can also handle a specified number of samples \n        per plate if desired.\n\n        Args:\n            plate_layout (Union[Plate, QCPlate]): The layout template for the plates. This can be an instance of \n                'Plate' or 'QCPlate'.\n            allow_group_split (bool, optional): If False (default), keeps specimens within the same group on the \n                same plate. If True, allows splitting groups across plates.\n            N_samples_desired_plate (Optional[int], optional): The desired number of samples per plate. If not \n                specified, fills each plate to its capacity.\n\n        Raises:\n            ValueError: If the group column is not defined in the specimen records.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(...)\n            &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n            &gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n            # This will distribute the specimens across plates, keeping groups together.\n        \"\"\"\n\n        plate_number = 1\n        plates = []\n\n        # Copy the specimen data to work on\n        remaining_specimens = self.specimen_records_df.copy()\n\n        N_specimens = self.specimen_records_df.shape[0]\n\n        if N_samples_desired_plate is None:\n            N_samples_desired_plate = plate_layout.capacity\n\n        # N_QCsample_in_plate = plate_layout.get_metadata_as_numpy_array(\"QC\").sum()\n        # N_plates_estimate = N_specimens / (plate_layout._specimen_capacity)\n\n        while not remaining_specimens.empty:\n            current_plate = copy.deepcopy(plate_layout)\n            current_plate.plate_id = plate_number\n\n            # Select specimens for the current plate\n            N_remaining = remaining_specimens.shape[0]\n\n            # if the remaining samples can fit on a whole place we put them there,\n            # otherwise we place the desired number of samples on the plate.\n            # if not we \n            if N_remaining &lt; current_plate.capacity:\n                selected_specimens = remaining_specimens.head(current_plate.capacity)\n            else:\n                selected_specimens = remaining_specimens.head(N_samples_desired_plate)\n\n            if not allow_group_split:\n                # Extract unique group IDs from the selected specimens. This step identifies the distinct groups\n                # that are represented within the specimens currently being considered for this plate.\n                group_ids = selected_specimens[self._column_with_group_index].unique()\n\n                # Find all specimens in the remaining pool that belong to the same groups as the selected specimens.\n                specimens_in_groups = remaining_specimens[remaining_specimens[self._column_with_group_index].isin(group_ids)]\n\n                if len(specimens_in_groups) &gt; len(selected_specimens):\n                    # If there are more specimens in the remaining pool belonging to the same groups,\n                    # it indicates that the last group in 'selected_specimens' is split between this plate and the remaining pool.\n                    # To avoid splitting the group, we modify 'selected_specimens' to exclude this last group.\n\n                    # Determine the groups to keep on the current plate. This is done by excluding the last group ID\n                    # from the list of unique group IDs in the selected specimens. This way, we ensure that an entire group \n                    # is not split across plates.\n                    groups_to_keep = group_ids[:-1]\n\n                    # Update 'selected_specimens' to only include specimens from the groups that are not split.\n                    selected_specimens = selected_specimens[selected_specimens[self._column_with_group_index].isin(groups_to_keep)]\n\n            # Remove selected specimens from the pool\n            remaining_specimens.drop(index=selected_specimens.index, inplace=True)\n            selected_specimens.reset_index(drop=True, inplace=True)\n            remaining_specimens.reset_index(drop=True, inplace=True)\n\n            # Add specimens to the current plate\n            current_plate = self._add_specimens_to_plate(current_plate, selected_specimens)\n            plates.append(current_plate)\n\n            plate_number += 1\n\n        self.plates = plates\n        self.total_plates = plate_number - 1\n\n        logger.info(f\"Distributed samples across {self.total_plates} plates.\")\n\n    @staticmethod\n    def _find_column_with_group_index(specimen_records_df: pd.DataFrame) -&gt; str:\n        \"\"\"\n        Identifies the column in a DataFrame that likely represents group indices based on integer pairs.\n\n        This static method analyzes a provided DataFrame to determine which column could represent group indices.\n        It looks for columns with integer values where pairs of consecutive numbers are common, indicating a\n        potential grouping pattern. The method is specifically designed to identify groups based on pair numbers.\n\n        Args:\n            specimen_records_df (pd.DataFrame): The DataFrame containing specimen records.\n\n        Returns:\n            str: The name of the column that likely represents group indices. Returns an empty string if no suitable\n                column is found.\n\n        Examples:\n            &gt;&gt;&gt; specimen_records_df = pd.DataFrame({'GroupID': [1, 1, 2, 2, 3, 3], 'Data': [100, 101, 102, 103, 104, 105]})\n            &gt;&gt;&gt; Study._find_column_with_group_index(specimen_records_df)\n            'GroupID'\n        \"\"\"\n        int_cols = specimen_records_df.select_dtypes(\"int\")\n\n        logger.debug(f\"Looking for group index of study pairs in the following table columns:\")\n\n        for col_name in int_cols.columns:\n\n            logger.debug(f\"\\t\\t{col_name}\")\n\n            # sort in ascending order\n            int_col = int_cols[col_name].sort_values()\n            # compute difference: n_1 - n_2, n_2 - n_3, ...\n            int_diffs = np.diff(int_col)\n            # count instances were numbers were the same, i.e. diff == 0\n            n_zeros = np.sum(list(map(lambda x: x==0, int_diffs)))\n            # we assume column contains pairs if #pairs == #samples / 2\n            column_have_pairs = n_zeros == (int_col.shape[0]//2)\n\n            if column_have_pairs:# we found a column so let's assume it is the correct one\n                logger.info(f\"Found group index in column {col_name}\")\n                return col_name\n\n        return \"\" \n\n    def randomize_order(self, case_control : bool = None, reproducible=True) -&gt; None:\n        \"\"\"\n        Randomizes the order of specimen records in the study, optionally maintaining group integrity.\n\n        This method either randomizes the entire order of specimens or maintains the order within groups,\n        depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.\n\n        Args:\n            case_control (Optional[bool]): If True, maintains group order (samples within a group are not shuffled).\n                If False, shuffles all samples regardless of group. If None, the behavior is determined based on \n                the presence of a group index column.\n            reproducible (bool): If True, uses a fixed seed for randomization to ensure reproducibility.\n\n        Examples:\n            &gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n            &gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n            &gt;&gt;&gt; study.randomize_order(case_control=True)\n            &gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n        \"\"\"\n\n        if not len(self.specimen_records_df) &gt; 0:\n            logger.error(\"There are no study records loaded. Use 'load_specimen_records' method to import study records.\")\n            return\n\n        if case_control is None:\n            if self._column_with_group_index:\n                case_control = True\n            else:\n                case_control = False\n\n        specimen_records_df_copy = self.specimen_records_df.copy()\n\n        if case_control:\n            column_with_group_index = self._column_with_group_index\n\n            logger.info(f\"Randomly permuting group order (samples within group unchanged) using variable '{column_with_group_index}'\")\n            logger.debug(\"Creating multiindex dataframe\")\n            specimen_records_df_copy = specimen_records_df_copy.set_index([column_with_group_index, specimen_records_df_copy.index])\n            drop = False\n        else:\n            logger.info(f\"Randomly permuting sample order.\")\n            specimen_records_df_copy = specimen_records_df_copy.set_index([specimen_records_df_copy.index, specimen_records_df_copy.index])\n            column_with_group_index = 0\n            drop = True\n\n\n        group_IDs = np.unique(specimen_records_df_copy.index.get_level_values(0))\n\n        # Permute order in table\n        if reproducible:\n            logger.info(f\"Using a fixed seed to random number generator for reproducibility; \\\n                running this method will always give the same result.\")\n            logger.debug(f\"Using class-determined seed {self._default_seed} for random number generator\")\n            np.random.seed(self._default_seed)\n\n        permutation_order = np.random.permutation(group_IDs)\n\n        prev_index_str = \"index_before_permutation\"\n\n        # if multiple randomization rounds, remove old column = prev_index_str \n        if prev_index_str in specimen_records_df_copy.columns:\n            specimen_records_df_copy = specimen_records_df_copy.drop(columns=prev_index_str)\n\n        specimen_records_df_copy = specimen_records_df_copy \\\n                                    .loc[permutation_order]\\\n                                    .reset_index(level=column_with_group_index, drop=drop)\\\n                                    .reset_index(drop=False)\n\n        specimen_records_df_copy = specimen_records_df_copy.rename(columns = {\"index\": \"index_before_permutation\"})\n\n        self._N_permutations += 1\n        self.specimen_records_df = specimen_records_df_copy.copy()\n</code></pre>"},{"location":"study/#src.study.Study.__getitem__","title":"<code>__getitem__(index)</code>","text":"<p>Retrieve a specific plate from the study by its index.</p> <p>This method allows for direct access to a plate in the study using the indexing syntax.</p> <p>Parameters:</p> Name Type Description Default <code>index</code> <code>int</code> <p>The index of the plate to retrieve.</p> required <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Union[Plate, QCPlate]: The plate at the specified index.</p> <p>Raises:</p> Type Description <code>IndexError</code> <p>If the index is out of range of the plates list.</p> Source code in <code>src/study.py</code> <pre><code>def __getitem__(self, index) -&gt; Union[Plate, QCPlate]:\n    \"\"\"\n    Retrieve a specific plate from the study by its index.\n\n    This method allows for direct access to a plate in the study using the indexing syntax.\n\n    Args:\n        index (int): The index of the plate to retrieve.\n\n    Returns:\n        Union[Plate, QCPlate]: The plate at the specified index.\n\n    Raises:\n        IndexError: If the index is out of range of the plates list.\n    \"\"\"\n    return self.plates[index]\n</code></pre>"},{"location":"study/#src.study.Study.__init__","title":"<code>__init__(study_name=None)</code>","text":"<p>Initializes a new instance of the Study class.</p> <p>This constructor sets up a study with a specified name. If no name is provided, a default name  is generated using the current date.</p> <p>Parameters:</p> Name Type Description Default <code>study_name</code> <code>Optional[str]</code> <p>The name for the study. If None, a default name in the format  \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.</p> <code>None</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n&gt;&gt;&gt; study1.name\n\"Alzheimer's Research\"\n</code></pre> <pre><code>&gt;&gt;&gt; study2 = Study()\n&gt;&gt;&gt; study2.name\n\"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def __init__(self, study_name=None,) -&gt; None:\n    \"\"\"\n    Initializes a new instance of the Study class.\n\n    This constructor sets up a study with a specified name. If no name is provided, a default name \n    is generated using the current date.\n\n    Args:\n        study_name (Optional[str]): The name for the study. If None, a default name in the format \n            \"Study_YYYY-MM-DD\" is assigned, where YYYY-MM-DD represents the current date.\n\n    Examples:\n        &gt;&gt;&gt; study1 = Study(study_name=\"Alzheimer's Research\")\n        &gt;&gt;&gt; study1.name\n        \"Alzheimer's Research\"\n\n        &gt;&gt;&gt; study2 = Study()\n        &gt;&gt;&gt; study2.name\n        \"Study_2024-01-21\"  # Example output; actual output will vary based on the current date.\n    \"\"\"\n\n    if study_name is None:\n        study_name = f\"Study_{datetime.date}\"\n\n    self.name = study_name\n</code></pre>"},{"location":"study/#src.study.Study.__iter__","title":"<code>__iter__()</code>","text":"<p>Initialize the iterator for the Study class.</p> <p>This method sets up the class to iterate over its plates, resetting the internal counter  to zero. It allows the Study instance to be used in a loop (e.g., a for loop),  facilitating iteration over its plates.</p> <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Iterator[Union[Plate, QCPlate]]: An iterator that yields either <code>Plate</code> or <code>QCPlate</code> </p> <code>Union[Plate, QCPlate]</code> <p>instances, allowing the Study instance to be used in a loop.</p> Source code in <code>src/study.py</code> <pre><code>def __iter__(self) -&gt; Iterator[Union[Plate, QCPlate]]:\n    \"\"\"\n    Initialize the iterator for the Study class.\n\n    This method sets up the class to iterate over its plates, resetting the internal counter \n    to zero. It allows the Study instance to be used in a loop (e.g., a for loop), \n    facilitating iteration over its plates.\n\n    Returns:\n        Iterator[Union[Plate, QCPlate]]: An iterator that yields either `Plate` or `QCPlate` \n        instances, allowing the Study instance to be used in a loop.\n    \"\"\"\n    self._iter_count = 0\n    return self\n</code></pre>"},{"location":"study/#src.study.Study.__len__","title":"<code>__len__()</code>","text":"<p>Return the total number of plates in the Study.</p> <p>This method enables the use of the len() function on the Study instance.</p> <p>Returns:</p> Name Type Description <code>int</code> <code>int</code> <p>The number of plates in the study.</p> Source code in <code>src/study.py</code> <pre><code>def __len__(self) -&gt; int:\n    \"\"\"\n    Return the total number of plates in the Study.\n\n    This method enables the use of the len() function on the Study instance.\n\n    Returns:\n        int: The number of plates in the study.\n    \"\"\"\n    return len(self.plates)\n</code></pre>"},{"location":"study/#src.study.Study.__next__","title":"<code>__next__()</code>","text":"<p>Proceed to the next plate in the Study class during iteration.</p> <p>This method returns the next plate in the study, which can be either a <code>Plate</code> or a <code>QCPlate</code> instance. It is automatically called in each iteration of a loop. When all plates have been iterated over, it raises the StopIteration exception.</p> <p>Returns:</p> Type Description <code>Union[Plate, QCPlate]</code> <p>Union[Plate, QCPlate]: The next plate in the study, either a <code>Plate</code> or <code>QCPlate</code> instance.</p> <p>Raises:</p> Type Description <code>StopIteration</code> <p>If all plates have been iterated over.</p> Source code in <code>src/study.py</code> <pre><code>def __next__(self) -&gt; Union[Plate, QCPlate]:\n    \"\"\"\n    Proceed to the next plate in the Study class during iteration.\n\n    This method returns the next plate in the study, which can be either a `Plate` or a `QCPlate` instance.\n    It is automatically called in each iteration of a loop. When all plates have been iterated over,\n    it raises the StopIteration exception.\n\n    Returns:\n        Union[Plate, QCPlate]: The next plate in the study, either a `Plate` or `QCPlate` instance.\n\n    Raises:\n        StopIteration: If all plates have been iterated over.\n    \"\"\"\n    if self._iter_count &lt; self.total_plates:\n        plate_to_return = self.plates[self._iter_count]\n        self._iter_count += 1\n        return plate_to_return\n    else:\n        raise StopIteration\n</code></pre>"},{"location":"study/#src.study.Study.__repr__","title":"<code>__repr__()</code>","text":"<p>Return an unambiguous string representation of the Study instance.</p> <p>This method is useful for debugging and logging purposes, as it represents the Study object in a clear and concise way.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string representation of the Study instance.</p> Source code in <code>src/study.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return an unambiguous string representation of the Study instance.\n\n    This method is useful for debugging and logging purposes, as it represents the Study\n    object in a clear and concise way.\n\n    Returns:\n        str: A string representation of the Study instance.\n    \"\"\"\n    return f\"Study({self.name})\"\n</code></pre>"},{"location":"study/#src.study.Study.__str__","title":"<code>__str__()</code>","text":"<p>Return a readable string representation of the Study instance.</p> <p>This method provides a user-friendly string representation of the Study, which includes its name, the number of study specimens, and the total number of plates.</p> <p>Returns:</p> Name Type Description <code>str</code> <code>str</code> <p>A string describing the Study instance.</p> Source code in <code>src/study.py</code> <pre><code>def __str__(self) -&gt; str:\n    \"\"\"\n    Return a readable string representation of the Study instance.\n\n    This method provides a user-friendly string representation of the Study, which includes\n    its name, the number of study specimens, and the total number of plates.\n\n    Returns:\n        str: A string describing the Study instance.\n    \"\"\"\n    return f\"{self.name}\\n {self.study_specimens} on {self.total_plates}\"\n</code></pre>"},{"location":"study/#src.study.Study.distribute_samples_to_plates","title":"<code>distribute_samples_to_plates(plate_layout, allow_group_split=False, N_samples_desired_plate=None)</code>","text":"<p>Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.</p> <p>This method iterates through the study's specimen records and distributes them across multiple plates  according to the provided plate layout. It supports options to either keep specimen groups together or  allow splitting them across different plates. The method can also handle a specified number of samples  per plate if desired.</p> <p>Parameters:</p> Name Type Description Default <code>plate_layout</code> <code>Union[Plate, QCPlate]</code> <p>The layout template for the plates. This can be an instance of  'Plate' or 'QCPlate'.</p> required <code>allow_group_split</code> <code>bool</code> <p>If False (default), keeps specimens within the same group on the  same plate. If True, allows splitting groups across plates.</p> <code>False</code> <code>N_samples_desired_plate</code> <code>Optional[int]</code> <p>The desired number of samples per plate. If not  specified, fills each plate to its capacity.</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the group column is not defined in the specimen records.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n&gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n# This will distribute the specimens across plates, keeping groups together.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def distribute_samples_to_plates(self, plate_layout: Union[Plate, QCPlate], allow_group_split=False, N_samples_desired_plate=None) -&gt; None:\n    \"\"\"\n    Distributes specimens across multiple plates based on a specified layout, with an option to keep group integrity.\n\n    This method iterates through the study's specimen records and distributes them across multiple plates \n    according to the provided plate layout. It supports options to either keep specimen groups together or \n    allow splitting them across different plates. The method can also handle a specified number of samples \n    per plate if desired.\n\n    Args:\n        plate_layout (Union[Plate, QCPlate]): The layout template for the plates. This can be an instance of \n            'Plate' or 'QCPlate'.\n        allow_group_split (bool, optional): If False (default), keeps specimens within the same group on the \n            same plate. If True, allows splitting groups across plates.\n        N_samples_desired_plate (Optional[int], optional): The desired number of samples per plate. If not \n            specified, fills each plate to its capacity.\n\n    Raises:\n        ValueError: If the group column is not defined in the specimen records.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; plate_layout = Plate(...)  # Assume Plate is properly initialized\n        &gt;&gt;&gt; study.distribute_samples_to_plates(plate_layout, allow_group_split=False)\n        # This will distribute the specimens across plates, keeping groups together.\n    \"\"\"\n\n    plate_number = 1\n    plates = []\n\n    # Copy the specimen data to work on\n    remaining_specimens = self.specimen_records_df.copy()\n\n    N_specimens = self.specimen_records_df.shape[0]\n\n    if N_samples_desired_plate is None:\n        N_samples_desired_plate = plate_layout.capacity\n\n    # N_QCsample_in_plate = plate_layout.get_metadata_as_numpy_array(\"QC\").sum()\n    # N_plates_estimate = N_specimens / (plate_layout._specimen_capacity)\n\n    while not remaining_specimens.empty:\n        current_plate = copy.deepcopy(plate_layout)\n        current_plate.plate_id = plate_number\n\n        # Select specimens for the current plate\n        N_remaining = remaining_specimens.shape[0]\n\n        # if the remaining samples can fit on a whole place we put them there,\n        # otherwise we place the desired number of samples on the plate.\n        # if not we \n        if N_remaining &lt; current_plate.capacity:\n            selected_specimens = remaining_specimens.head(current_plate.capacity)\n        else:\n            selected_specimens = remaining_specimens.head(N_samples_desired_plate)\n\n        if not allow_group_split:\n            # Extract unique group IDs from the selected specimens. This step identifies the distinct groups\n            # that are represented within the specimens currently being considered for this plate.\n            group_ids = selected_specimens[self._column_with_group_index].unique()\n\n            # Find all specimens in the remaining pool that belong to the same groups as the selected specimens.\n            specimens_in_groups = remaining_specimens[remaining_specimens[self._column_with_group_index].isin(group_ids)]\n\n            if len(specimens_in_groups) &gt; len(selected_specimens):\n                # If there are more specimens in the remaining pool belonging to the same groups,\n                # it indicates that the last group in 'selected_specimens' is split between this plate and the remaining pool.\n                # To avoid splitting the group, we modify 'selected_specimens' to exclude this last group.\n\n                # Determine the groups to keep on the current plate. This is done by excluding the last group ID\n                # from the list of unique group IDs in the selected specimens. This way, we ensure that an entire group \n                # is not split across plates.\n                groups_to_keep = group_ids[:-1]\n\n                # Update 'selected_specimens' to only include specimens from the groups that are not split.\n                selected_specimens = selected_specimens[selected_specimens[self._column_with_group_index].isin(groups_to_keep)]\n\n        # Remove selected specimens from the pool\n        remaining_specimens.drop(index=selected_specimens.index, inplace=True)\n        selected_specimens.reset_index(drop=True, inplace=True)\n        remaining_specimens.reset_index(drop=True, inplace=True)\n\n        # Add specimens to the current plate\n        current_plate = self._add_specimens_to_plate(current_plate, selected_specimens)\n        plates.append(current_plate)\n\n        plate_number += 1\n\n    self.plates = plates\n    self.total_plates = plate_number - 1\n\n    logger.info(f\"Distributed samples across {self.total_plates} plates.\")\n</code></pre>"},{"location":"study/#src.study.Study.load_specimen_records","title":"<code>load_specimen_records(records_file, sample_group_id_column=None, sample_id_column=None)</code>","text":"<p>Loads specimen records from a specified file into the study.</p> <p>This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame. It also identifies or sets the column used for grouping specimens.</p> <p>Parameters:</p> Name Type Description Default <code>records_file</code> <code>str</code> <p>The path to the file containing specimen records.</p> required <code>sample_group_id_column</code> <code>Optional[str]</code> <p>The column name in the file that represents the group ID of samples.  If None, the method attempts to find a suitable column automatically.</p> <code>None</code> <p>Raises:</p> Type Description <code>FileExistsError</code> <p>If the specified records_file does not exist.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n&gt;&gt;&gt; study.specimen_records_df.shape\n(200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def load_specimen_records(self, records_file: str, sample_group_id_column=None, sample_id_column=None) -&gt; None:\n    \"\"\"\n    Loads specimen records from a specified file into the study.\n\n    This method reads specimen data from a file (Excel or CSV) and stores it in a DataFrame.\n    It also identifies or sets the column used for grouping specimens.\n\n    Args:\n        records_file (str): The path to the file containing specimen records.\n        sample_group_id_column (Optional[str]): The column name in the file that represents the group ID of samples. \n            If None, the method attempts to find a suitable column automatically.\n\n    Raises:\n        FileExistsError: If the specified records_file does not exist.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Oncology Study\")\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.xlsx\", sample_group_id_column=\"PatientGroup\")\n        &gt;&gt;&gt; study.specimen_records_df.shape\n        (200, 5)  # Example output, indicating 200 rows and 5 columns in the DataFrame.\n    \"\"\"\n    self.records_file_path = records_file\n    records_path = Path(records_file)\n\n    logger.debug(f\"Loading records file: {records_file}\")\n    extension = records_path.suffix\n\n    if not records_path.exists():\n        logger.error(f\"Could not find file {records_file}\")\n        raise FileExistsError(records_file)\n\n    if extension in [\".xlsx\", \".xls\"]:\n        logger.debug(\"Importing Excel file.\")\n        records = pd.read_excel(records_file)\n    elif extension == \".csv\":\n        logger.debug(\"Importing csv file.\")\n        records = pd.read_csv(records_file)\n    else:\n        logger.error(\"File extension not recognized\")\n        records = pd.DataFrame()\n\n    if sample_group_id_column is None:\n        self._column_with_group_index = Study._find_column_with_group_index(records)\n    else:\n        self._column_with_group_index = sample_group_id_column\n\n    logger.debug(f\"{records.shape[0]} specimens in file\")\n    logger.info(\"Metadata in file:\")\n    for col in records.columns:\n        logger.info(f\"\\t{col}\")\n\n    if sample_id_column:\n        logger.debug(f\"Sorting records in ascending order based on column '{sample_id_column}'\")\n        records = records.sort_values(by=[sample_id_column])\n\n    # if self._column_with_group_index:\n    #     logger.debug(f\"Sorting records in ascending order based on column '{self._column_with_group_index}'\")\n        # records = records.sort_values(by=[self._column_with_group_index])\n\n    self.specimen_records_df = records\n</code></pre>"},{"location":"study/#src.study.Study.position_sample_within_groups","title":"<code>position_sample_within_groups(sortby_column, sample_value, position_index)</code>","text":"<p>Repositions a specific sample within each group based on a specified value and index.</p> <p>This method allows altering the position of a sample within each group in the specimen records DataFrame. It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group to the specified 'position_index'. The method is useful for customizing the order of samples within groups based on specific criteria or requirements.</p> <p>Parameters:</p> Name Type Description Default <code>sortby_column</code> <code>str</code> <p>The column name in the specimen records DataFrame to identify the sample.</p> required <code>sample_value</code> <code>Any</code> <p>The value in the 'sortby_column' that identifies the sample to reposition.</p> required <code>position_index</code> <code>int</code> <p>The new index within the group where the sample should be positioned.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no group column is defined in the Study instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n# This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def position_sample_within_groups(self, sortby_column: str, sample_value: Any, position_index: int) -&gt; None:\n    \"\"\"\n    Repositions a specific sample within each group based on a specified value and index.\n\n    This method allows altering the position of a sample within each group in the specimen records DataFrame.\n    It locates a sample based on the 'sortby_column' and 'sample_value', then repositions this sample within its group\n    to the specified 'position_index'. The method is useful for customizing the order of samples within groups\n    based on specific criteria or requirements.\n\n    Args:\n        sortby_column (str): The column name in the specimen records DataFrame to identify the sample.\n        sample_value (Any): The value in the 'sortby_column' that identifies the sample to reposition.\n        position_index (int): The new index within the group where the sample should be positioned.\n\n    Raises:\n        ValueError: If no group column is defined in the Study instance.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.position_sample_within_groups(\"PatientID\", 12345, 2)\n        # This will move the sample with PatientID 12345 to the index 2 position within its respective group.\n    \"\"\"\n    if self._column_with_group_index:\n        logger.info(f\"Positioning sample within {self._column_with_group_index} based on {sortby_column} value {sample_value} at index {position_index}\")\n        # Step 1: Group the DataFrame by 'group_ID'\n        grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n        # Step 2: Modify each group\n        modified_groups = []\n        for _, group in grouped:\n            # Find the row to reposition\n            sample_row = group[group[sortby_column] == sample_value]\n\n            # Remove this row from the group\n            group = group[group[sortby_column] != sample_value]\n\n            # Split the group at the specified position index\n            first_part = group.iloc[:position_index]\n            second_part = group.iloc[position_index:]\n\n            # Concatenate first part, sample row, and second part\n            modified_group = pd.concat([first_part, sample_row, second_part])\n\n            modified_groups.append(modified_group)\n\n        # Step 3: Concatenate the modified groups back into a single DataFrame\n        self.specimen_records_df = pd.concat(modified_groups).reset_index(drop=True)\n\n    else:\n        raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n</code></pre>"},{"location":"study/#src.study.Study.randomize_order","title":"<code>randomize_order(case_control=None, reproducible=True)</code>","text":"<p>Randomizes the order of specimen records in the study, optionally maintaining group integrity.</p> <p>This method either randomizes the entire order of specimens or maintains the order within groups, depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.</p> <p>Parameters:</p> Name Type Description Default <code>case_control</code> <code>Optional[bool]</code> <p>If True, maintains group order (samples within a group are not shuffled). If False, shuffles all samples regardless of group. If None, the behavior is determined based on  the presence of a group index column.</p> <code>None</code> <code>reproducible</code> <code>bool</code> <p>If True, uses a fixed seed for randomization to ensure reproducibility.</p> <code>True</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n&gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.randomize_order(case_control=True)\n&gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def randomize_order(self, case_control : bool = None, reproducible=True) -&gt; None:\n    \"\"\"\n    Randomizes the order of specimen records in the study, optionally maintaining group integrity.\n\n    This method either randomizes the entire order of specimens or maintains the order within groups,\n    depending on the 'case_control' flag. It also allows for reproducible randomization using a fixed seed.\n\n    Args:\n        case_control (Optional[bool]): If True, maintains group order (samples within a group are not shuffled).\n            If False, shuffles all samples regardless of group. If None, the behavior is determined based on \n            the presence of a group index column.\n        reproducible (bool): If True, uses a fixed seed for randomization to ensure reproducibility.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(study_name=\"Diabetes Study\")\n        &gt;&gt;&gt; study.load_specimen_records(\"patients.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.randomize_order(case_control=True)\n        &gt;&gt;&gt; study.specimen_records_df.head(3)  # Example output showing randomized order within groups.\n    \"\"\"\n\n    if not len(self.specimen_records_df) &gt; 0:\n        logger.error(\"There are no study records loaded. Use 'load_specimen_records' method to import study records.\")\n        return\n\n    if case_control is None:\n        if self._column_with_group_index:\n            case_control = True\n        else:\n            case_control = False\n\n    specimen_records_df_copy = self.specimen_records_df.copy()\n\n    if case_control:\n        column_with_group_index = self._column_with_group_index\n\n        logger.info(f\"Randomly permuting group order (samples within group unchanged) using variable '{column_with_group_index}'\")\n        logger.debug(\"Creating multiindex dataframe\")\n        specimen_records_df_copy = specimen_records_df_copy.set_index([column_with_group_index, specimen_records_df_copy.index])\n        drop = False\n    else:\n        logger.info(f\"Randomly permuting sample order.\")\n        specimen_records_df_copy = specimen_records_df_copy.set_index([specimen_records_df_copy.index, specimen_records_df_copy.index])\n        column_with_group_index = 0\n        drop = True\n\n\n    group_IDs = np.unique(specimen_records_df_copy.index.get_level_values(0))\n\n    # Permute order in table\n    if reproducible:\n        logger.info(f\"Using a fixed seed to random number generator for reproducibility; \\\n            running this method will always give the same result.\")\n        logger.debug(f\"Using class-determined seed {self._default_seed} for random number generator\")\n        np.random.seed(self._default_seed)\n\n    permutation_order = np.random.permutation(group_IDs)\n\n    prev_index_str = \"index_before_permutation\"\n\n    # if multiple randomization rounds, remove old column = prev_index_str \n    if prev_index_str in specimen_records_df_copy.columns:\n        specimen_records_df_copy = specimen_records_df_copy.drop(columns=prev_index_str)\n\n    specimen_records_df_copy = specimen_records_df_copy \\\n                                .loc[permutation_order]\\\n                                .reset_index(level=column_with_group_index, drop=drop)\\\n                                .reset_index(drop=False)\n\n    specimen_records_df_copy = specimen_records_df_copy.rename(columns = {\"index\": \"index_before_permutation\"})\n\n    self._N_permutations += 1\n    self.specimen_records_df = specimen_records_df_copy.copy()\n</code></pre>"},{"location":"study/#src.study.Study.sort_records_within_groups","title":"<code>sort_records_within_groups(sortby_column)</code>","text":"<p>Sorts specimen records within each group based on a specified column.</p> <p>This method groups the specimen records by a predefined group index column and then sorts each group's records based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame. This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.</p> <p>Parameters:</p> Name Type Description Default <code>sortby_column</code> <code>str</code> <p>The column name in the specimen records DataFrame to sort by within each group.</p> required <p>Raises:</p> Type Description <code>ValueError</code> <p>If no group column is defined in the Study instance.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n&gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n# This will sort the specimen records within each group based on the \"Age\" column.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def sort_records_within_groups(self, sortby_column: str) -&gt; None:\n    \"\"\"\n    Sorts specimen records within each group based on a specified column.\n\n    This method groups the specimen records by a predefined group index column and then sorts each group's records\n    based on the specified 'sortby_column'. The sorted groups are then concatenated back into the main DataFrame.\n    This is useful for organizing records in a manner that respects the grouping while ordering the records within each group.\n\n    Args:\n        sortby_column (str): The column name in the specimen records DataFrame to sort by within each group.\n\n    Raises:\n        ValueError: If no group column is defined in the Study instance.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.load_specimen_records(\"specimens.csv\", sample_group_id_column=\"GroupID\")\n        &gt;&gt;&gt; study.sort_records_within_groups(\"Age\")\n        # This will sort the specimen records within each group based on the \"Age\" column.\n    \"\"\"\n    if self._column_with_group_index:\n        logger.info(f\"Sorting samples within {self._column_with_group_index} by {sortby_column}\")\n        # Step 1: Group the DataFrame by 'group_ID'\n        grouped = self.specimen_records_df.groupby(self._column_with_group_index)\n\n        # Step 2: Sort each group by the 'sortby_column' column\n        sorted_groups = [group.sort_values(sortby_column) for _, group in grouped]\n\n        # Step 3: Concatenate the sorted groups back into a single DataFrame\n        self.specimen_records_df = pd.concat(sorted_groups)\n\n    else:\n        raise ValueError(f\"No group column defined: self._column_with_group_index: {self._column_with_group_index}\")\n</code></pre>"},{"location":"study/#src.study.Study.to_dataframe","title":"<code>to_dataframe()</code>","text":"<p>Converts the data from all plates in the study into a single Pandas DataFrame.</p> <p>This method iterates over each plate in the study and converts its data to a DataFrame.  These DataFrames are then concatenated into a single DataFrame representing the entire study.</p> <p>Returns:</p> Type Description <code>DataFrame</code> <p>pd.DataFrame: A DataFrame containing data from all plates in the study.</p> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study_df = study.to_dataframe()\n&gt;&gt;&gt; study_df.head()\n# Displays the first few rows of the combined DataFrame for the study.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def to_dataframe(self) -&gt; pd.DataFrame:\n    \"\"\"\n    Converts the data from all plates in the study into a single Pandas DataFrame.\n\n    This method iterates over each plate in the study and converts its data to a DataFrame. \n    These DataFrames are then concatenated into a single DataFrame representing the entire study.\n\n    Returns:\n        pd.DataFrame: A DataFrame containing data from all plates in the study.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study_df = study.to_dataframe()\n        &gt;&gt;&gt; study_df.head()\n        # Displays the first few rows of the combined DataFrame for the study.\n    \"\"\"\n    dfs = []\n    for plate in self:\n        dfs.append(plate.as_dataframe())\n    return pd.concat(dfs).reset_index(drop=True)\n</code></pre>"},{"location":"study/#src.study.Study.to_layout_figures","title":"<code>to_layout_figures(annotation_metadata_key, color_metadata_key, file_format='pdf', folder_path=None, plate_name='Plate', **kwargs)</code>","text":"<p>Creates and saves visual representations of each plate in the study as figures.</p> <p>This method iterates over each plate in the study, generating a figure based on specified metadata keys for annotation and coloring. The figures are saved in the specified file format in a designated folder.</p> <p>Parameters:</p> Name Type Description Default <code>annotation_metadata_key</code> <code>str</code> <p>The metadata key used for annotating elements in the figure.</p> required <code>color_metadata_key</code> <code>str</code> <p>The metadata key used for coloring elements in the figure.</p> required <code>file_format</code> <code>str</code> <p>The format in which to save the figures (default is 'pdf').</p> <code>'pdf'</code> <code>folder_path</code> <code>Optional[str]</code> <p>The path to the folder where the figures will be saved.  If None, the current working directory is used.</p> <code>None</code> <code>plate_name</code> <code>str</code> <p>A base name for the figure files.</p> <code>'Plate'</code> <code>**kwargs</code> <p>Additional keyword arguments passed to the <code>as_figure</code> method of each plate.</p> <code>{}</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                        color_metadata_key=\"status\",\n                        file_format=\"png\",\n                        folder_path=\"/path/to/figures\",\n                        plate_name=\"study_plate\")\n# This will create and save figures for each plate in the '/path/to/figures' directory,\n# with annotations and colorings based on 'sample_id' and 'status'.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def to_layout_figures(self,\n                      annotation_metadata_key : str,\n                      color_metadata_key : str,\n                    file_format : str = \"pdf\",\n                    folder_path : str = None,\n                    plate_name : str = \"Plate\", **kwargs) -&gt; None:\n    \"\"\"\n    Creates and saves visual representations of each plate in the study as figures.\n\n    This method iterates over each plate in the study, generating a figure based on specified metadata keys\n    for annotation and coloring. The figures are saved in the specified file format in a designated folder.\n\n    Args:\n        annotation_metadata_key (str): The metadata key used for annotating elements in the figure.\n        color_metadata_key (str): The metadata key used for coloring elements in the figure.\n        file_format (str, optional): The format in which to save the figures (default is 'pdf').\n        folder_path (Optional[str]): The path to the folder where the figures will be saved. \n            If None, the current working directory is used.\n        plate_name (str, optional): A base name for the figure files.\n        **kwargs: Additional keyword arguments passed to the `as_figure` method of each plate.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.to_layout_figures(annotation_metadata_key=\"sample_id\",\n                                color_metadata_key=\"status\",\n                                file_format=\"png\",\n                                folder_path=\"/path/to/figures\",\n                                plate_name=\"study_plate\")\n        # This will create and save figures for each plate in the '/path/to/figures' directory,\n        # with annotations and colorings based on 'sample_id' and 'status'.\n    \"\"\"\n\n    if folder_path is None:\n        folder_path = Path.cwd()\n    else:\n        folder_path = Path(folder_path)\n\n    # New folder path for \"layout_lists\"\n    new_folder_path = folder_path / \"layout_figures\"\n\n    # Create the \"layout_lists\" folder if it does not exist\n    new_folder_path.mkdir(parents=True, exist_ok=True)\n\n    for plate in self:\n        file_name = f\"{self.name}_{plate_name}_{plate.plate_id}_{annotation_metadata_key}_{color_metadata_key}.{file_format}\"\n        file_path = new_folder_path / file_name\n\n        # Define title        \n        title_str = f\"{self.name}: Plate {plate.plate_id}, showing {annotation_metadata_key} colored by {color_metadata_key}\"\n\n        fig = plate.as_figure(annotation_metadata_key, color_metadata_key, title_str=title_str, **kwargs)\n\n        logger.info(f\"Saving plate figure to {file_path}\")\n\n        fig.savefig(file_path)\n</code></pre>"},{"location":"study/#src.study.Study.to_layout_lists","title":"<code>to_layout_lists(metadata_keys=[], file_format='csv', folder_path=None, plate_name='plate')</code>","text":"<p>Exports the layout of each plate in the study to files in the specified format.</p> <p>This method iterates over each plate in the study and exports its layout to a file.  The files are saved in a specified format (CSV by default) and stored in a designated folder.</p> <p>Parameters:</p> Name Type Description Default <code>metadata_keys</code> <code>list</code> <p>A list of metadata keys to include in the exported files.</p> <code>[]</code> <code>file_format</code> <code>str</code> <p>The file format for the exported layouts (e.g., 'csv').</p> <code>'csv'</code> <code>folder_path</code> <code>str</code> <p>The path to the folder where the layout files will be saved.  If None, the current working directory is used.</p> <code>None</code> <code>plate_name</code> <code>str</code> <p>A base name for the layout files.</p> <code>'plate'</code> <p>Examples:</p> <pre><code>&gt;&gt;&gt; study = Study(...)\n&gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                        file_format=\"csv\", \n                        folder_path=\"/path/to/layouts\", \n                        plate_name=\"experiment_plate\")\n# This will save layout files for each plate in the '/path/to/layouts' directory.\n</code></pre> Source code in <code>src/study.py</code> <pre><code>def to_layout_lists(self, metadata_keys: list = [], \n                file_format: str = \"csv\",\n                folder_path: str = None,\n                plate_name: str = \"plate\") -&gt; None:\n    \"\"\"\n    Exports the layout of each plate in the study to files in the specified format.\n\n    This method iterates over each plate in the study and exports its layout to a file. \n    The files are saved in a specified format (CSV by default) and stored in a designated folder.\n\n    Args:\n        metadata_keys (list, optional): A list of metadata keys to include in the exported files.\n        file_format (str, optional): The file format for the exported layouts (e.g., 'csv').\n        folder_path (str, optional): The path to the folder where the layout files will be saved. \n            If None, the current working directory is used.\n        plate_name (str, optional): A base name for the layout files.\n\n    Examples:\n        &gt;&gt;&gt; study = Study(...)\n        &gt;&gt;&gt; study.to_layout_lists(metadata_keys=[\"sample_type\", \"concentration\"], \n                                file_format=\"csv\", \n                                folder_path=\"/path/to/layouts\", \n                                plate_name=\"experiment_plate\")\n        # This will save layout files for each plate in the '/path/to/layouts' directory.\n    \"\"\"\n\n    if folder_path is None:\n        folder_path = Path.cwd()\n    else:\n        folder_path = Path(folder_path)\n\n    # New folder path for \"layout_lists\"\n    new_folder_path = folder_path / \"layout_lists\"\n\n    # Create the \"layout_lists\" folder if it does not exist\n    new_folder_path.mkdir(parents=True, exist_ok=True)\n\n    for plate in self:\n        file_name = f\"{self.name}_{plate_name}_{plate.plate_id}\"\n        # Update file path to include the new folder\n        file_path = new_folder_path / file_name\n\n        plate.to_file(file_path=str(file_path),\n                    file_format=file_format,\n                    metadata_keys=metadata_keys)\n</code></pre>"}]}